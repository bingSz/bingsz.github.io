[{"content":"这篇博客主要是介绍一下超分辨相关算法。在之前已经接触了很多超分辨算法，但一直都没有时间记录，这篇博客就把之前的超分辨算法做一个总结。\n1.回波信号模型 在本文开始之前，我们先来介绍一下雷达阵列信号的回波信号模型。假设空间中存在$N$个阵元，并且阵元按照均匀线阵排列，如图1.1所示。\n图1.1：均匀线阵\r两个阵元之间的间距为$d$，目标回波到达方向与第一个阵元轴向方向所呈夹角为$\\theta$。为了方便，本文假设阵列回波信号为一个窄带信号，并且遵循远场假设。窄带信号指的是回波信号的包络是缓变的，从而每个阵元接收到的信号包络都可看作是一样的，因此每个阵元接收到的信号仅仅是相位上存在差异。远场假设指的是当目标充分远时，目标回波信号可看作平行射入阵列，因此每个阵元所接收到的信号夹角都是一致的。\n在上述两个假设前提下，若第$t$个目标在第$1$个阵元所对应的回波数字采样信号为$\\mathbf{s}_t \\in \\mathbb{C}^{1 \\times L}$，其中$L$为采样点数，那么第$n$个阵元的回波信号可表示为\n$$ \\mathbf{x}_n = \\sum_{t=1}^{T}\\mathbf{s}_t \\exp\\left(j 2\\pi \\frac{(n-1)d\\sin\\theta_t}{\\lambda}\\right) + \\mathbf{n}_n $$\n其中$T$为目标个数，$\\theta_t$为目标$t$的回波夹角，$\\mathbf{n}_n$表示第$n$个阵元回波信号的噪声信号。为了更加方便的使用矩阵语言来描述，记源信号矩阵$\\mathbf{S} = \\begin{bmatrix} \\mathbf{s}_1 \u0026amp; \\mathbf{s}_2 \u0026amp; \\cdots \u0026amp; \\mathbf{s}_N \\end{bmatrix}^{\\mathrm{T}}$，噪声信号矩阵$\\mathbf{N} = \\begin{bmatrix} \\mathbf{n}_1 \u0026amp; \\mathbf{n}_2 \u0026amp; \\cdots \u0026amp; \\mathbf{n}_N \\end{bmatrix}^{\\mathrm{T}}$，导向矢量矩阵$\\mathbf{A}$为\n$$ \\begin{aligned} \\mathbf{A} =\u0026amp; \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ \\exp\\left(j 2\\pi \\frac{d\\sin\\theta_1}{\\lambda}\\right) \u0026amp; \\exp\\left(j 2\\pi \\frac{d\\sin\\theta_2}{\\lambda}\\right) \u0026amp; \\cdots \u0026amp; \\exp\\left(j 2\\pi \\frac{d\\sin\\theta_T}{\\lambda}\\right) \\\\ \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \\\\ \\exp\\left(j 2\\pi \\frac{(N-1)d\\sin\\theta_1}{\\lambda}\\right) \u0026amp; \\exp\\left(j 2\\pi \\frac{(N-1)d\\sin\\theta_2}{\\lambda}\\right) \u0026amp; \\cdots \u0026amp; \\exp\\left(j 2\\pi \\frac{(N-1)d\\sin\\theta_T}{\\lambda}\\right) \\end{bmatrix} \\\\ =\u0026amp; \\begin{bmatrix} \\mathbf{a}(\\theta_1) \u0026amp; \\mathbf{a}(\\theta_2) \u0026amp; \\cdots \u0026amp; \\mathbf{a}(\\theta_T) \\end{bmatrix} \\end{aligned} $$\n其中，$\\mathbf{a}(\\theta_t)$被称为目标$t$的导向矢量。那么，阵元接收到的目标回波信号矩阵$\\mathbf{X} = \\begin{bmatrix} \\mathbf{x}_1 \u0026amp; \\mathbf{x}_2 \u0026amp; \\cdots \u0026amp; \\mathbf{x}_N \\end{bmatrix}^{\\mathrm{T}}$为\n$$ \\mathbf{X} = \\mathbf{A} \\mathbf{S} + \\mathbf{N} $$\n从另一个角度来说，某次快拍下，阵列信号（即$\\mathbf{X}$的列向量）实际上就是一个数字信号。在多目标情况下，阵列信号相当于包含了多个数字频率成分，而DOA估计则是估计该数字采样信号的各个频率成分。为了对于第$t$个目标不发生频率混叠，要求上式的数字角频率小于$\\pi$，即\n$$ \\begin{aligned} \\frac{2\\pi d|\\sin\\theta_t|}{\\lambda} \u0026lt; \\pi \\\\ \\Rightarrow d \u0026lt; \\frac{\\lambda}{2 |\\sin \\theta_t|} \\end{aligned} $$\n当探测范围为$-\\pi$至$+\\pi$时，$d$应当满足$d \u0026lt; \\frac{\\lambda}{2}$。为了方便，本文取$d = \\frac{\\lambda}{2}$，那么此时目标$t$的导向矢量可写为\n$$ \\mathbf{a}(\\theta_t) = \\begin{bmatrix} \\exp\\left(j \\pi \\sin\\theta_1\\right) \\\\ \\exp\\left(j \\pi 2\\sin\\theta_1\\right) \\\\ \\cdots \\\\ \\exp\\left(j \\pi (N-1)\\sin\\theta_1\\right) \\end{bmatrix} $$\n2.常规算法 既然前文提到，DOA估计本质上是估计回波信号的各个频率成分，那么最简单的一个方法就是傅里叶变换。假设阵列回波信号的一次快拍为$\\mathbf{x}$，对其作傅里叶变换得到$\\mathbf{y} = \\text{FFT}(\\mathbf{x})$，对$\\mathbf{y}$进行谱峰搜索即可得到目标回波的到达角估计。这种方法虽然简单，但存在分辨率低的问题。\n关于雷达角度估计分辨率，可以从多个角度来理解。从阵列孔径来理解，阵列的3dB波束宽度为\n$$ \\theta_{\\text{3dB}}=\\frac{\\lambda}{D} $$\n其中$D$为阵列孔径。当阵元间距为半波长时，$D=\\frac{N\\lambda}{2}$。带入上式即可得到\n$$ \\theta_{\\text{3dB}} = \\frac{2}{N} $$\n从FFT的频率分辨率来理解，FFT的频率分辨率为$\\frac{1}{N}$。因此两个信号的空域频率应当满足\n$$ \\frac{|\\sin\\theta_1 - \\sin\\theta_2|}{2} \\ge \\frac{1}{N} $$\n当目标位于$0^{\\circ}$附近时，可以得到角度分辨率为$\\frac{2}{N}$。当然，一般教科书上给的理解都是从原始公式出发。对导向矢量作FFT后，可以得到其结果为一个Sinc函数，根据Sinc函数的3dB波束宽度即可得到角度分辨率，这里就不再赘述了。\n总而言之，传统常规算法所得到的角度分辨率为$\\frac{2}{N}$，该分辨率受限于阵列孔径大小，因而也被称为瑞丽限。当阵列的角度分辨率低于瑞丽限时，这类算法被称为超分辨算法。超分辨算法有许多种类，本文主要介绍基于谱分析的超分辨算法。\n3.Capon算法 Capon算法基于一个比较朴素的思想，希望在检测某个方向上的目标回波时，先对回波信号作一个线性变换，使得其它方向上的回波最小，以此来减小其它目标回波对测角结果的影响。\n针对某次快拍阵列信号，经过$\\mathbf{w}$的线性变化后，阵列信号可被写为$\\mathbf{w}^{\\mathrm{H}}\\mathbf{x}$，从而目标能量为$(\\mathbf{w}^{\\mathrm{H}}\\mathbf{x})(\\mathbf{w}^{\\mathrm{H}}\\mathbf{x})^{\\mathrm{H}} = \\mathbf{w}^{\\mathrm{H}}\\mathbf{R}\\mathbf{w}$，其中$\\mathbf{R}=\\mathbf{x}\\mathbf{x}^{\\mathrm{H}}$。约束特定方向$\\theta_0$上的能量为固定值，而其它方向上的能量最小，可写出如下所示的优化问题\n$$ \\begin{cases} \\min \\quad \u0026amp; \\mathbf{w}^{\\mathrm{H}}\\mathbf{R}\\mathbf{w} \\\\ \\text{s.t.} \u0026amp; \\mathbf{w}^{\\mathrm{H}}\\mathbf{a}(\\theta_0) = 1 \\end{cases} $$\n为了求解上述优化问题，构建拉格朗日乘子$L$\n$$ L = \\frac{1}{2}\\mathbf{w}^{\\mathrm{H}}\\mathbf{R}\\mathbf{w} - \\lambda(\\mathbf{w}^{\\mathrm{H}}\\mathbf{a}(\\theta_0) - 1) $$\n对$\\mathbf{w}$求导，并令其导数为$0$可得\n$$ \\begin{aligned} \\frac{\\partial L}{\\partial \\mathbf{w}} = \\mathbf{R}\\mathbf{w} - \\lambda\\mathbf{a}(\\theta_0) = 0 \\\\ \\Rightarrow \\mathbf{w} = \\lambda \\mathbf{R}^{-1}\\mathbf{a}(\\theta_0) \\end{aligned} $$\n将上式代入到约束条件中可以计算得到\n$$ \\mathbf{w} = \\frac{\\mathbf{R}^{-1}\\mathbf{a}(\\theta_0)}{\\mathbf{a}(\\theta_0)^{\\mathrm{H}}\\mathbf{R}^{-1}\\mathbf{a}(\\theta_0)} $$\n回波信号在$\\theta_0$方向上的能量$P(\\theta_0)$为\n$$ \\begin{aligned} P(\\theta_0) =\u0026amp; \\left|\\mathbf{w}^{\\mathrm{H}}\\mathbf{R}\\mathbf{w}\\right| \\\\ =\u0026amp; \\left|\\frac{\\mathbf{a}(\\theta_0)^{\\mathrm{H}}{\\mathbf{R}^{-1}}^{\\mathrm{H}}\\mathbf{a}(\\theta_0)}{\\lVert \\mathbf{a}(\\theta_0)^{\\mathrm{H}}\\mathbf{R}^{-1}\\mathbf{a}(\\theta_0) \\rVert^2}\\right| \\\\ =\u0026amp; \\left|\\frac{\\mathbf{a}(\\theta_0)^{\\mathrm{H}}{\\mathbf{R}^{-1}}\\mathbf{a}(\\theta_0)}{\\lVert \\mathbf{a}(\\theta_0)^{\\mathrm{H}}\\mathbf{R}^{-1}\\mathbf{a}(\\theta_0) \\rVert^2}\\right| \\\\ =\u0026amp; \\left|\\frac{1}{\\mathbf{a}(\\theta_0)^{\\mathrm{H}}\\mathbf{R}^{-1}\\mathbf{a}(\\theta_0)}\\right| \\end{aligned} $$\n通过遍历$\\theta_0$，即可得到回波信号在各个方向上的能量大小。随后进行谱峰搜索即可得到目标角度的估计。\n4.MUSIC算法 Capon算法仅利用了回波信号的协方差矩阵这一个信息，实际上由于信号分布与噪声分布的区别，通常我们还能够估计得到空域中的目标个数。利用目标个数这一个信息，我们可以仅利用协方差矩阵中的有用分量而抛弃无关分量来进一步得到更优的估计性能。假设目标回波的协方差矩阵为$\\mathbf{R}=\\text{E}\\left(\\mathbf{x}\\mathbf{x}^{\\mathrm{H}}\\right)$，根据回波信号模型，协方差矩阵可表示为\n$$ \\mathbf{R} = \\mathbf{A}\\mathbf{R}_s\\mathbf{A}^{\\mathrm{H}} + \\sigma^2 \\mathbf{I} $$\n其中$\\mathbf{R}_s$表示源信号矩阵的协方差，$\\sigma^2$表示噪声强度，$\\mathbf{I}$表示对角矩阵。从上式可以看到，信号分量$\\mathbf{A}\\mathbf{R}_s\\mathbf{A}^{\\mathrm{H}}$集中在某一个低秩空间内，而噪声分量$\\sigma^2\\mathbf{I}$分散在整个空间中，并且信号分量能量大于噪声分量能量。因而进一步可以推断，大特征值所对应的特征向量为信号与噪声的主成分，而小特征值所对应的特征向量为噪声的主成分。对$\\mathbf{R}$作特征值分解可以得到\n$$ \\mathbf{R} = \\mathbf{E}\\mathbf{V}\\mathbf{E}^{\\mathrm{H}} = \\mathbf{E}_s\\mathbf{V}_s\\mathbf{E}_s^{\\mathrm{H}}+\\mathbf{E}_n\\mathbf{V}_n\\mathbf{E}_n^{\\mathrm{H}} $$\n其中$\\mathbf{E}$表示特征向量矩阵，$\\mathbf{V}$表示特征值对角矩阵，$\\mathbf{E}_s$与$\\mathbf{V}_s$分别表示源信号对应的特征向量与特征值，$\\mathbf{E}_n$与$\\mathbf{V}_n$分别表示噪声信号对应的特征向量与特征值。上述分割方法相当于把信号分为了信号子空间$\\mathbf{E}_s$与噪声子空间$\\mathbf{E}_n$。\n由于源信号所对应的特征向量相当于源信号所张成空间的主成分，因此在源信号导向矢量之间两两正交情况下，特征向量等于源信号导向矢量，但更一般的，源信号导向矢量之间通常并不正交，因此特征向量相当于是源信号导向矢量正交化后的结果。若直接使用源信号特征向量来作角度估计，通常无法得到一个精确的结果。\n为了得到一个精确的目标角度估计结果，可以将导向矢量$\\mathbf{a}(\\theta_0)$投影至噪声子空间中。由于实对称矩阵的特征向量之间相互正交，因此信号子空间与噪声子空间之间是正交的。$\\mathbf{a}(\\theta_0)$投影至噪声子空间的分量越小，表明$\\mathbf{a}(\\theta_0)$越多分量处于信号子空间，从而目标为该角度的可能性越大。与Capon算法类似，计算导向矢量投影至噪声子空间的大小\n$$ P(\\theta_0) = \\frac{1}{\\lVert \\mathbf{a}(\\theta_0)^{\\mathrm{H}}\\mathbf{E}_n \\rVert^2} = \\frac{1}{\\mathbf{a}(\\theta_0)^{\\mathrm{H}}\\mathbf{E}_n\\mathbf{E}_n^{\\mathrm{H}}\\mathbf{a}(\\theta_0)} $$\n随后遍历$\\theta_0$便能得到每个回波角度情况下的估计。而实际应用中，通常无法知道目标回波的协方差矩阵，因此首先需要对回波协方差矩阵进行一个估计\n$$ \\hat{\\mathbf{R}} = \\frac{1}{L}\\sum_{i=1}^{L}\\mathbf{x}_{:,i}\\mathbf{x}_{:,i}^{\\mathrm{H}} = \\frac{1}{L}\\mathbf{X}\\mathbf{X}^{\\mathrm{H}} $$\n其中$\\mathbf{x}_{:,i}$表示第$i$次快拍阵列采样信号。随后根据$\\hat{\\mathbf{R}}$进行后续的操作即可得到目标角度估计。\n5.ESPRIT算法 当然，Capon算法与MUSIC算法的一个共同点是两个算法都要进行角度遍历并进行谱峰搜索才能得到目标角度估计，因此性能较低。ESPRIT算法根据旋转不变子空间的方式来进行角度估计。假设目标回波信号为$\\mathbf{X}=\\mathbf{A}\\mathbf{S}+\\mathbf{N}$，将$N$个阵元分为两个子阵，分别为第$1$个阵元至第$N-1$个阵元，与第$2$个阵元至第$N$个阵元。记第$1$至第$N-1$个阵元回波信号构成的矩阵为$\\mathbf{X}_1 = \\mathbf{A}_1\\mathbf{S}+\\mathbf{N}_1$，第$2$至第$N$构成的矩阵为$\\mathbf{X}_2 = \\mathbf{A}_2\\mathbf{S}+\\mathbf{N}_2$，那么如下关系成立\n$$ \\mathbf{A}_2 = \\mathbf{A}_1 \\mathbf{\\Phi} $$\n其中\n$$ \\mathbf{\\Phi} = \\begin{bmatrix} \\exp(j \\pi \\sin\\theta_1) \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \\\\ 0 \u0026amp; \\exp(j \\pi \\sin\\theta_2) \u0026amp; \\cdots \u0026amp; 0 \\\\ \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \\\\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; \\exp(j \\pi \\sin\\theta_T) \\end{bmatrix} $$\n令$\\mathbf{X}_0$为两个子阵回波信号行方向上的拼接，进一步可得\n$$ \\mathbf{X}_0 = \\begin{bmatrix} \\mathbf{X}_1 \\\\ \\mathbf{X}_2 \\end{bmatrix} = \\mathbf{A}_1 \\begin{bmatrix} \\mathbf{I} \\\\ \\mathbf{\\Phi} \\end{bmatrix}\\mathbf{S} + \\mathbf{N}_0 = \\bar{\\mathbf{A}}\\mathbf{S}+\\mathbf{N}_0 $$\n其中$\\bar{\\mathbf{A}}=\\begin{bmatrix} \\mathbf{A}_1 \\\\ \\mathbf{A}_1\\mathbf{\\Phi} \\end{bmatrix}$。与MUSIC算法一样，仍然估计回波信号的协方差矩阵\n$$ \\hat{\\mathbf{R}}_X = \\frac{1}{L}\\mathbf{X}_0\\mathbf{X}_0^{\\mathrm{H}} \\approx \\bar{\\mathbf{A}}\\hat{\\mathbf{R}_S}\\bar{\\mathbf{A}}^{\\mathrm{H}} + \\sigma^2\\mathbf{I} $$\n其中，$\\hat{\\mathbf{R}}_S=\\frac{1}{L}\\mathbf{S}\\mathbf{S}^{\\mathrm{H}}$。对$\\hat{\\mathbf{R}}_X$作特征值分解后，可以得到\n$$ \\hat{\\mathbf{R}}_X=\\mathbf{E}_s\\mathbf{V}_s\\mathbf{E}_s + \\mathbf{E}_n\\mathbf{V}_n\\mathbf{E}_n $$\n其中$\\mathbf{E}_s$与$\\mathbf{E}_n$分别对应信号子空间与噪声子空间。由于$\\mathbf{E}_s$所张成的空间应当就等于$\\bar{\\mathbf{A}}$所张成的空间，因此存在一个可逆矩阵$\\mathbf{P}$，使得\n$$ \\mathbf{E}_s = \\bar{\\mathbf{A}}\\mathbf{P} $$\n将$\\mathbf{E}_s$分为与$\\mathbf{A}_1$大小相等的两部分，可以得到\n$$ \\mathbf{E}_s = \\begin{bmatrix} \\mathbf{E}_x \\\\ \\mathbf{E}_y \\end{bmatrix} = \\bar{\\mathbf{A}}\\mathbf{P} = \\begin{bmatrix} \\mathbf{A}_1\\mathbf{P} \\\\ \\mathbf{A}_1\\mathbf{\\Phi}\\mathbf{P} \\end{bmatrix} $$\n进一步有\n$$ \\mathbf{E}_y = \\mathbf{E}_x\\mathbf{P}^{-1}\\mathbf{\\Phi}\\mathbf{P} = \\mathbf{E}_x\\mathbf{T} $$\n可以发现，$\\mathbf{T}$与$\\mathbf{\\Phi}$相似，因此两者具有相同的特征值；同时，$\\mathbf{\\Phi}$的特征值恰好对应目标回波角度，因此只需要估计$\\mathbf{T}$，并求其特征值便能得到目标回波角度估计。最简单的估计方式便是令\n$$ \\mathbf{T}=\\mathbf{E}_x^{\\dagger}\\mathbf{E}_y = (\\mathbf{E}_x^{\\mathrm{H}}\\mathbf{E}_x)^{-1}\\mathbf{E}_x^{\\mathrm{H}}\\mathbf{E}_y $$\n其中$\\cdot^{\\dagger}$表示矩阵的伪逆。估计得到$\\mathbf{T}$后，对其求特征值，并进行一些转化，便得到了目标的角度估计。\n6.克拉美罗界 前文提到了在常规算法下，目标回波角度受瑞利界限制，那么超分辨算法的角度分辨率的理论下界又是多少呢？克拉美罗界指的是，对于一个受参数$\\theta$控制的概率密度函数$P(x; \\theta)$而言，对$\\theta$的无偏估计方差满足如下关系\n$$ \\text{Var}(\\theta) \\ge \\frac{1}{-\\mathrm{E}(\\frac{\\partial^2\\ln P(x; \\theta)}{\\partial\\theta^2})} = \\frac{1}{I(\\theta)} $$\n矩阵情形下，概率密度函数$P(\\mathbf{X}; \\Theta)$对$\\Theta=\\begin{bmatrix} \\theta_1 \u0026amp; \\theta_2 \u0026amp; \\cdots \\theta_M \\end{bmatrix}$的无偏估计满足如下关系\n$$ \\text{Cov}(\\Theta) \\ge I(\\Theta)^{-1} $$\n其中$I(\\Theta)$表示费歇尔信息量，其定义如下所示\n$$ I(\\Theta) = -\\begin{bmatrix} \\frac{\\partial^2\\ln P(\\mathbf{X}; \\Theta)}{\\partial\\theta_1\\partial\\theta_1} \u0026amp; \\frac{\\partial^2\\ln P(\\mathbf{X}; \\Theta)}{\\partial\\theta_1\\partial\\theta_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2\\ln P(\\mathbf{X}; \\Theta)}{\\partial\\theta_1\\partial\\theta_M} \\\\ \\frac{\\partial^2\\ln P(\\mathbf{X}; \\Theta)}{\\partial\\theta_2\\partial\\theta_1} \u0026amp; \\frac{\\partial^2\\ln P(\\mathbf{X}; \\Theta)}{\\partial\\theta_2\\partial\\theta_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2\\ln P(\\mathbf{X}; \\Theta)}{\\partial\\theta_2\\partial\\theta_M} \\\\ \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \\\\ \\frac{\\partial^2\\ln P(\\mathbf{X}; \\Theta)}{\\partial\\theta_M\\partial\\theta_1} \u0026amp; \\frac{\\partial^2\\ln P(\\mathbf{X}; \\Theta)}{\\partial\\theta_M\\partial\\theta_2} \u0026amp; \\cdots \u0026amp; \\frac{\\partial^2\\ln P(\\mathbf{X}; \\Theta)}{\\partial\\theta_M\\partial\\theta_M} \\\\ \\end{bmatrix} $$\n6.1 克拉美罗界证明 此处只给出标量情形下的证明。由于\n$$ \\int_{-\\infty}^{+\\infty}P(x; \\theta)\\mathrm{d}x = 1 $$\n因此有\n$$ \\begin{aligned} \\frac{\\partial}{\\partial \\theta}\\int_{-\\infty}^{+\\infty}P(x; \\theta)\\mathrm{d}x = 0 \\\\ \\Rightarrow \\int_{-\\infty}^{+\\infty}\\frac{\\partial}{\\partial \\theta}P(x; \\theta)\\mathrm{d}x = 0 \\end{aligned} $$\n注意到$\\frac{\\partial}{\\partial \\theta}P(x; \\theta) = P(x; \\theta)\\frac{\\partial}{\\partial \\theta} \\ln P(x; \\theta)$，因此有\n$$ \\int_{-\\infty}^{+\\infty}P(x; \\theta)\\frac{\\partial}{\\partial \\theta} \\ln P(x; \\theta)\\mathrm{d}x = 0 \\tag{6.1} $$\n即\n$$ \\int_{-\\infty}^{+\\infty}\\theta P(x; \\theta)\\frac{\\partial}{\\partial \\theta} \\ln P(x; \\theta)\\mathrm{d}x = 0 \\tag{6.2} $$\n从另一个角度而言，由于这个估计是一个无偏估计，因此有\n$$ \\int_{-\\infty}^{+\\infty} \\hat{\\theta} P(x; \\theta)\\mathrm{d}x = \\theta $$\n同理可得\n$$ \\int_{-\\infty}^{+\\infty}\\hat{\\theta} P(x; \\theta)\\frac{\\partial}{\\partial \\theta} \\ln P(x; \\theta)\\mathrm{d}x = 1 \\tag{6.3} $$\n两式相减$(6.3) - (6.2)$可得\n$$ \\int_{-\\infty}^{+\\infty}(\\hat{\\theta} - \\theta) P(x; \\theta)\\frac{\\partial}{\\partial \\theta} \\ln P(x; \\theta)\\mathrm{d}x = 1 $$\n即\n$$ \\mathrm{E}\\left((\\hat{\\theta} - \\theta)\\frac{\\partial}{\\partial \\theta} \\ln P(x; \\theta)\\right) = 1 $$\n由柯西不等式可得\n$$ 1 = \\mathrm{E}\\left[(\\hat{\\theta} - \\theta)\\frac{\\partial}{\\partial \\theta} \\ln P(x; \\theta)\\right]^2 \\le \\mathrm{E}\\left[(\\hat{\\theta} - \\theta)^2 \\right]\\mathrm{E}\\left[ (\\frac{\\partial}{\\partial \\theta} \\ln P(x; \\theta))^2 \\right] $$\n即\n$$ \\text{Var}(\\theta) \\ge \\frac{1}{\\mathrm{E}\\left[ (\\frac{\\partial}{\\partial \\theta} \\ln P(x; \\theta))^2 \\right]} $$\n由$(6.1)$进一步可得\n$$ \\begin{aligned} \u0026amp;\\frac{\\partial}{\\partial \\theta}\\int_{-\\infty}^{+\\infty}P(x; \\theta)\\frac{\\partial}{\\partial \\theta} \\ln P(x; \\theta)\\mathrm{d}x = 0 \\\\ \\Rightarrow \\\\ \u0026amp;\\int_{-\\infty}^{+\\infty}P(x; \\theta)\\left[\\frac{\\partial}{\\partial \\theta} \\ln P(x; \\theta)\\right]^2\\mathrm{d}x \\\\ \u0026amp;+ \\int_{-\\infty}^{+\\infty}P(x; \\theta)\\frac{\\partial^2}{\\partial \\theta^2} \\ln P(x; \\theta)\\mathrm{d}x = 0 \\end{aligned} $$\n因此有$\\mathrm{E}\\left[ (\\frac{\\partial}{\\partial \\theta} \\ln P(x; \\theta))^2 \\right] = -\\mathrm{E}\\left[\\frac{\\partial^2}{\\partial \\theta^2} \\ln P(x; \\theta)\\right]$，最终可得\n$$ \\text{Var}(\\theta) \\ge \\frac{1}{-\\mathrm{E}\\left[\\frac{\\partial^2}{\\partial \\theta^2} \\ln P(x; \\theta)\\right]} $$\n至此就完成了标量情况下的证明。\n6.2. CMA条件下DOA估计的克拉美罗界 CMA条件指的是Conditional Model Assumption，指的是目标回波信号是一个确定的未知参数，而非一个随机变量。 假设目标回波信号模型为\n$$ \\mathbf{X} = \\mathbf{A} \\mathbf{S} + \\mathbf{N} $$\n并且$\\mathbf{S}=\\begin{bmatrix}s_1 \u0026amp; s_2 \u0026amp; \\cdots \u0026amp; s_T\\end{bmatrix}^{\\mathrm{T}}$是一个恒定的向量，$\\mathbf{N}$服从复高斯分布。那么$\\mathbf{X} \\sim \\mathcal{CN}(\\mathbf{A}\\mathbf{S}, \\sigma^2 \\mathbf{I})$，其中$\\mathcal{CN}$表示复高斯分布，$\\sigma^2$表示噪声方差。令$\\mathbf{Y}=\\mathbf{A}\\mathbf{S}$，进一步可得概率密度函数为\n$$ \\begin{aligned} P(\\mathbf{X}; \\Theta) =\u0026amp; \\frac{1}{(2\\pi)^{N}|\\mathbf{C}|}\\exp\\left\\{-\\frac{1}{2}\\left[\\text{Re}(\\mathbf{X})-\\text{Re}(\\mathbf{Y})\\right]^{\\mathrm{T}}\\mathbf{C}^{-1}\\left[\\text{Re}(\\mathbf{X})-\\text{Re}(\\mathbf{Y})\\right]\\right\\} \\\\ \u0026amp; \\cdot \\exp\\left\\{-\\frac{1}{2}\\left[\\text{Im}(\\mathbf{X})-\\text{Im}(\\mathbf{Y})\\right]^{\\mathrm{T}}\\mathbf{C}^{-1}\\left[\\text{Im}(\\mathbf{X})-\\text{Im}(\\mathbf{Y})\\right]\\right\\} \\end{aligned} $$\n其中\n$$ \\mathbf{C} = \\begin{bmatrix} \\frac{\\sigma^2}{2} \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \\\\ 0 \u0026amp; \\frac{\\sigma^2}{2} \u0026amp; \\cdots \u0026amp; 0 \\\\ \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \\\\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; \\frac{\\sigma^2}{2} \\end{bmatrix} $$\n假设待估计参数$\\Theta=\\begin{bmatrix} \\theta_1 \u0026amp; \\theta_2 \u0026amp; \\cdots \u0026amp; \\theta_T \u0026amp; s_1 \u0026amp; s_2 \u0026amp; \\cdots \u0026amp; s_T \\end{bmatrix}$，其中$\\sigma_1^2$表示目标$1$回波的能量，以此类推。考虑到在复高斯分布情况下，实部方差与虚部方差一致，那么可以得到\n$$ P(\\mathbf{X}; \\Theta) = \\frac{1}{(2\\pi)^{N}|\\mathbf{C}|}\\exp\\left\\{-\\left[\\text{Re}(\\mathbf{X})-\\text{Re}(\\mathbf{Y})\\right]^{\\mathrm{T}}\\mathbf{C}^{-1}\\left[\\text{Re}(\\mathbf{X})-\\text{Re}(\\mathbf{Y})\\right]\\right\\} $$\n从而有\n$$ \\begin{aligned} \\frac{\\partial \\ln P(\\mathbf{X}; \\Theta)}{\\partial \\theta_i} =\u0026amp; -\\frac{\\partial}{\\partial \\theta_i}\\left[\\text{Re}(\\mathbf{X})-\\text{Re}(\\mathbf{Y})\\right]^{\\mathrm{T}}\\mathbf{C}^{-1}\\left[\\text{Re}(\\mathbf{X})-\\text{Re}(\\mathbf{Y})\\right] \\\\ =\u0026amp; -\\frac{2}{\\sigma^2}\\frac{\\partial}{\\partial \\theta_i}\\left[\\text{Re}(\\mathbf{X})-\\text{Re}(\\mathbf{Y})\\right]^{\\mathrm{T}}\\left[\\text{Re}(\\mathbf{X})-\\text{Re}(\\mathbf{Y})\\right] \\\\ =\u0026amp; -\\frac{1}{\\sigma^2}\\text{Re}\\left[\\frac{\\partial}{\\partial \\theta_i}(\\mathbf{X}-\\mathbf{Y})^{\\mathrm{H}}(\\mathbf{X}-\\mathbf{Y})\\right] \\\\ =\u0026amp; \\frac{2}{\\sigma^2}\\text{Re}\\left[ (\\mathbf{X}-\\mathbf{Y})^{\\mathrm{H}} \\frac{\\partial \\mathbf{Y}}{\\partial \\theta_i} \\right] \\end{aligned} $$\n进而\n$$ \\begin{aligned} -\\frac{\\partial^2 \\ln P(\\mathbf{X}; \\Theta)}{\\partial \\theta_i \\partial \\theta_j} =\u0026amp; \\frac{2}{\\sigma^2}\\text{Re}\\left[ \\frac{\\partial \\mathbf{Y}^{\\mathrm{H}}}{\\partial \\theta_i} \\frac{\\partial \\mathbf{Y}}{\\partial \\theta_j} \\right] \\\\ =\u0026amp; \\frac{2}{\\sigma^2}\\text{Re}\\left[\\text{tr}\\left( \\frac{\\partial \\mathbf{Y}}{\\partial \\theta_i} \\frac{\\partial \\mathbf{Y}^{\\mathrm{H}}}{\\partial \\theta_j} \\right)\\right] \\\\ =\u0026amp; \\frac{2}{\\sigma^2}\\text{Re}\\left[\\text{tr}\\left( \\frac{\\partial \\mathbf{A}}{\\partial \\theta_i} \\mathbf{R}_S \\frac{\\partial \\mathbf{A}^{\\mathrm{H}}}{\\partial \\theta_j} \\right)\\right] \\end{aligned} $$\n其中$\\mathbf{R}_S = \\text{E}(\\mathbf{S}\\mathbf{S}^{\\mathrm{H}})$。同理有\n$$ \\begin{aligned} -\\frac{\\partial^2 \\ln P(\\mathbf{X}; \\Theta)}{\\partial s_i \\partial \\theta_j} =\u0026amp; \\frac{2}{\\sigma^2}\\text{Re}\\left[\\text{tr}\\left( \\mathbf{A}\\frac{\\partial \\mathbf{S}}{\\partial s_i} \\mathbf{S}^{\\mathrm{H}} \\frac{\\partial \\mathbf{A}^{\\mathrm{H}}}{\\partial \\theta_j} \\right)\\right] \\\\ -\\frac{\\partial^2 \\ln P(\\mathbf{X}; \\Theta)}{\\partial \\theta_i \\partial s_j} =\u0026amp; \\frac{2}{\\sigma^2}\\text{Re}\\left[\\text{tr}\\left( \\frac{\\partial \\mathbf{A}}{\\partial \\theta_i}\\mathbf{S} \\frac{\\partial \\mathbf{S}^{\\mathrm{H}}}{\\partial s_j}\\mathbf{A}^{\\mathrm{H}} \\right)\\right] \\\\ -\\frac{\\partial^2 \\ln P(\\mathbf{X}; \\Theta)}{\\partial s_i \\partial s_j} =\u0026amp; \\frac{2}{\\sigma^2}\\text{Re}\\left[\\text{tr}\\left( \\mathbf{A}\\frac{\\partial \\mathbf{S}}{\\partial s_i} \\frac{\\partial \\mathbf{S}^{\\mathrm{H}}}{\\partial s_j}\\mathbf{A}^{\\mathrm{H}} \\right)\\right] \\end{aligned} $$\n令$\\mathbf{F}(\\theta, \\theta)_{i,j}=-\\frac{\\partial^2 \\ln P(\\mathbf{X}; \\Theta)}{\\partial \\theta_i \\partial \\theta_j}$，$\\mathbf{F}(s, \\theta)_{i,j}=-\\frac{\\partial^2 \\ln P(\\mathbf{X}; \\Theta)}{\\partial s_i \\partial \\theta_j}$，$\\mathbf{F}(\\theta, s)_{i,j}=-\\frac{\\partial^2 \\ln P(\\mathbf{X}; \\Theta)}{\\partial \\theta_i \\partial s_j}$，$\\mathbf{F}(s, s)_{i,j}=-\\frac{\\partial^2 \\ln P(\\mathbf{X}; \\Theta)}{\\partial s_i \\partial s_j}$，构造分块矩阵可得\n$$ \\mathbf{FIM} = \\begin{bmatrix} \\mathbf{F}(\\theta, \\theta) \u0026amp; \\mathbf{F}(\\theta, s) \\\\ \\mathbf{F}(s, \\theta) \u0026amp; \\mathbf{F}(s, s) \\end{bmatrix} $$\n随后利用分块矩阵求逆即可计算得到各个变量方差的理论下界。\n6.3. UMA条件下DOA估计的克拉美罗界 与CMA条件不同的是，UMA条件指的是目标回波信号是一个随机变量。此时回波信号模型仍然为\n$$ \\mathbf{X} = \\mathbf{A}\\mathbf{S}+\\mathbf{N} $$\n但是，$\\mathbf{X} \\sim \\mathcal{CN}(0, \\mathbf{A}\\mathbf{R}_S\\mathbf{A}^{\\mathrm{H}} + \\sigma^2\\mathbf{I})$。并且，本文还假设$\\mathbf{R}_S=\\text{diag}(\\sigma_1^2, \\sigma_2^2, \\cdots, \\sigma_T^2)$。与上一节一致，可以得到此时的概率密度函数为\n$$ P(\\mathbf{X}; \\Theta) = \\frac{1}{(2\\pi)^N 2^{N}|\\mathbf{R}|}\\exp\\left\\{-\\frac{1}{2}\\text{Re}(\\mathbf{X})^{\\mathrm{T}}\\mathbf{\\mathbf{R}}^{-1}\\text{Re}(\\mathbf{X})\\right\\} $$\n其中$\\mathbf{R}=\\mathbf{A}\\mathbf{R}_S\\mathbf{A}^{\\mathrm{H}} + \\sigma^2\\mathbf{I}$。同理可求得\n$$ \\frac{\\partial \\ln P(\\mathbf{X}; \\Theta)}{\\partial \\theta_i} = -\\text{tr}\\left( \\frac{\\partial \\mathbf{R}}{\\partial \\theta_i} \\mathbf{R}^{-1} \\right) + \\mathbf{X}^{\\mathrm{H}}\\mathbf{R}^{-1}\\frac{\\partial \\mathbf{R}}{\\partial \\theta_i}\\mathbf{R}^{-1}\\mathbf{X} $$\n","permalink":"https://bingsz.github.io/en/posts/superres/","summary":"这篇博客主要是介绍一下超分辨相关算法。在之前已经接触了很多超分辨算法，但一直都没有时间记录，这篇博客就把之前的超分辨算法做一个总结。 1.回波信号模型 在本文开始之前，我们先来介绍一下雷达阵列信号的回波信号模型。假设空间中存在$N$个阵元，并且阵元按照均匀线阵排列，如图1.1所示。 图","title":"DOA估计的超分辨率算法以及克拉美罗界"},{"content":"张量具有强大的表示能力，许多问题可以通过张量来进行建模，并利用张量相关工具来得到简化。例如，利用张量工具，能够对互质阵列所接收的信号进行建模；也可以利用张量工具对信号的统计特征进行建模。\n盲源分离是一种在无先验信息下进行信号源分离的工具，通过最大化信号源之间的独立性来进行信号源分离。更具体地，假设信号源$i$发出的信号为 $\\mathbf{s}_i = \\begin{bmatrix} s_{i1} \u0026amp; s_{i2} \u0026amp; \\cdots \u0026amp; s_{iL} \\end{bmatrix}$ ，$L$为采样点数，令信号源矩阵$\\mathbf{S}$为\n$$ \\mathbf{S}=\\begin{bmatrix}\\mathbf{s}_1 \\ \\mathbf{s}_2 \\ \\cdots \\ \\mathbf{s}_N\\end{bmatrix} \\in \\mathbb{C}^{N \\times L} $$\n其中$N$表示信号源个数。若接收信号基于瞬时混合假设，那么阵元接收信号可表示为\n$$ \\mathbf{X}=\\mathbf{A}\\mathbf{S} = \\begin{bmatrix} \\mathbf{x}_1 \u0026amp; \\mathbf{x}_2 \u0026amp; \\cdots \u0026amp; \\mathbf{x}_L \\end{bmatrix}\\in \\mathbb{C}^{M \\times L} $$\n其中$M$为阵元个数，在本文中，为了方便假设$M=N$，$\\mathbf{A} \\in \\mathbb{C}^{M \\times N}$为混合矩阵。盲源分离算法通过最大化$\\mathbf{X}$的各个信号之间的独立性来进行信号分离。盲源分离算法有三种理解角度，分别为信息熵角度，统计量角度与似然角度。从信息熵角度来理解盲源分离算法的话，盲源分离算法相当于最大化信号之间的互信息，从而每个信息能够提供更多的信息；从统计量角度而言，盲源分离算法通过最大化高阶统计量来分离信号，因为根据中心极限定理，越多不相关信号的求和，其结果越趋向于高斯分布；从似然角度而言，盲源分离算法对信号源模型进行先验概率的建模，随后最大化后验概率来进行信号源分离。但不论从哪个角度来理解盲源分离，都能够表示为如下所示的优化问题\n$$ \\begin{cases} \\max \u0026amp; G(\\mathbf{w}^{\\mathrm{H}}\\mathbf{X}) \\\\ \\text{s.t.} \u0026amp; \\mathbf{w}^{\\mathrm{H}}\\mathbf{w}=1 \\end{cases} \\tag{1} $$\n其中$G(\\cdot)$表示对照函数，用来衡量信号之间的独立性，$\\mathbf{w}$表示解混矢量，在理想情况下，$\\mathbf{w}$应当为$\\mathbf{A}$的广义逆的列向量。FastICA等算法利用牛顿迭代法对上述优化问题进行求解，并取得了较高的效率。可以看到的是，FastICA的每次更新迭代都涉及到整个数据集，因此在采样点数$L$较大的情况下，带来巨大的计算开销。更特殊的，若假设信号为实数信号，混合矩阵$\\mathbf{A}$为一个实矩阵，令$G$为向量元素的三次方和，那么$(1)$可以表示为\n$$ \\begin{cases} \\max \u0026amp; \\sum_{i=1}^{L}(\\mathbf{w}^{\\mathrm{T}}\\mathbf{x}_i)^3 \\\\ \\text{s.t.} \u0026amp; \\mathbf{w}^{\\mathrm{H}}\\mathbf{w}=1 \\end{cases} \\tag{2} $$\n注意到，若令$\\mathcal{S}=\\frac{1}{L}\\sum_{i=1}^{L}\\mathbf{x}_i \\circ \\mathbf{x}_i \\circ \\mathbf{x}_i$，其中$\\circ$表示直积，那么有\n$$ \\frac{1}{L}\\sum_{i=1}^{L}(\\mathbf{w}^{\\mathrm{T}}\\mathbf{x}_i)^3 = \\mathcal{S} \\times_1 \\mathbf{w} \\times_2 \\mathbf{w} \\times_3 \\mathbf{w} $$\n其中$\\times_n$表示$n$模积（本文中为了方便，将$\\mathcal{S} \\times_n \\mathbf{w}^{\\mathrm{T}}$写为$\\mathcal{S} \\times_n \\mathbf{w}$）。忽略常数项，$(2)$可等价为\n$$ \\begin{cases} \\max \u0026amp; \\mathcal{S} \\times_1 \\mathbf{w} \\times_2 \\mathbf{w} \\times_3 \\mathbf{w} \\\\ \\text{s.t.} \u0026amp; \\mathbf{w}^{\\mathrm{H}}\\mathbf{w}=1 \\end{cases} \\tag{3} $$\n构造拉格朗日算子$L_a$\n$$ L_a = \\frac{1}{3}\\mathcal{S} \\times_1 \\mathbf{w} \\times_2 \\mathbf{w} \\times_3 \\mathbf{w} - \\frac{1}{2}\\lambda (\\mathbf{w}^{\\mathrm{H}}\\mathbf{w} - 1) $$\n对其关于$\\mathbf{w}$求导，可以得到\n$$ \\frac{\\partial L_a}{\\partial \\mathbf{w}} = \\mathcal{S} \\times_2 \\mathbf{w} \\times_3 \\mathbf{w} - \\lambda \\mathbf{w} $$\n令导数为0，有\n$$ \\mathcal{S} \\times_2 \\mathbf{w} \\times_3 \\mathbf{w} = \\lambda \\mathbf{w} $$\n这意味着，$\\mathbf{w}$为$\\mathcal{S}$的特征矢量。对于特征矢量的求解，可以使用不动点迭代来计算$\\mathbf{w}$，即\n$$ \\mathbf{w} \\leftarrow \\mathcal{S} \\times_2 \\mathbf{w} \\times_3 \\mathbf{w}, \\mathbf{w} \\leftarrow \\frac{\\mathbf{w}}{\\lVert \\mathbf{w} \\rVert} $$\n为了求得所有的解混矢量，同时防止后续的$\\mathbf{w}$迭代到与之前解混矢量相同的解中，我们需要应用约束。在PSA算法中，应用正交约束来保持解的唯一性。假设$\\mathbf{W}_k=\\begin{bmatrix} \\mathbf{w}_1 \u0026amp; \\mathbf{w}_2 \u0026amp; \\cdots \u0026amp; \\mathbf{w}_k \\end{bmatrix}$为前$k$个解混矢量构成的解混矩阵，那么对于第$k+1$个解混矢量，迭代公式可变化为\n$$ \\mathbf{w}_{k+1} \\leftarrow \\mathbf{P}_k\\left(\\mathcal{S} \\times_2 \\mathbf{w}_{k+1} \\times_3 \\mathbf{w}_{k+1}\\right), \\mathbf{w}_{k+1} \\leftarrow \\frac{\\mathbf{w}_{k+1}}{\\lVert \\mathbf{w}_{k+1} \\rVert} \\tag{4} $$\n其中$\\mathbf{P}_k=(\\mathbf{I}-\\mathbf{W}_k\\mathbf{W}_k^{\\mathrm{T}})$，为$\\mathbf{W}_k$正交补空间的投影矩阵。\n当然，PSA作者也说了，正交约束对于求解解混矩阵$\\mathbf{W}_N$是一个过于强的条件，因为与矩阵不同的是，$\\mathcal{S}$的特征矢量并不一定是正交的。利用正交约束并不能够获得一个精确的解，仅仅只有第一个解混矢量是精确的。为了得到一个更精确的解，NPSA引入了非正交约束。我们改写一下PSA的迭代公式，$(4)$可以被改写为\n$$ \\mathbf{w}_{k+1} \\leftarrow \\mathcal{S} \\times_1 \\mathbf{P}_k \\times_2 \\mathbf{w}_{k+1} \\times_3 \\mathbf{w}_{k+1}, \\mathbf{w}_{k+1} \\leftarrow \\frac{\\mathbf{w}_{k+1}}{\\lVert \\mathbf{w}_{k+1} \\rVert} $$\n根据PSA的正交约束假设，$\\mathbf{w}_{k+1}$与$\\mathbf{W}_k$构成的子空间正交，因此经过$\\mathbf{P}k$投影后，$\\mathbf{w}{k+1}$不变，于是上式可以被写为\n$$ \\mathbf{w}_{k+1} \\leftarrow \\mathcal{S} \\times_1 \\mathbf{P}_k \\times_2 \\mathbf{P}_k\\mathbf{w}_{k+1} \\times_3 \\mathbf{P}_k\\mathbf{w}_{k+1}, \\mathbf{w}_{k+1} \\leftarrow \\frac{\\mathbf{w}_{k+1}}{\\lVert \\mathbf{w}_{k+1} \\rVert} $$\n进一步有\n$$ \\mathbf{w}_{k+1} \\leftarrow \\mathcal{S}_k \\times_2 \\mathbf{w}_{k+1} \\times_3 \\mathbf{w}_{k+1}, \\mathbf{w}_{k+1} \\leftarrow \\frac{\\mathbf{w}_{k+1}}{\\lVert \\mathbf{w}_{k+1} \\rVert} $$\n其中$\\mathcal{S}_k = \\mathcal{S} \\times_1 \\mathbf{P}_k \\times_2 \\mathbf{P}_k \\times_3 \\mathbf{P}_k$。由于$\\mathbf{P}_k$是一个投影矩阵，并且$\\mathbf{W}_k$中的每个向量之间都正交，因此有\n$$ \\mathbf{P}_k = \\prod_{i=1}^{k}\\left(\\mathbf{I}-\\mathbf{w}_i\\mathbf{w}_i^{\\mathrm{T}}\\right) = \\prod_{i=1}^{k}\\bar{\\mathbf{P}}_i $$\n其中$\\bar{\\mathbf{P}}_i=\\mathbf{I}-\\mathbf{w}_i\\mathbf{w}_i^{\\mathrm{T}}$。根据向量拉直$\\mathrm{vec}(\\cdot)$的相关性质，对于$\\mathcal{S}\\times_1 \\mathbf{P}_k \\times_2 \\mathbf{P}_k \\times_3 \\mathbf{P}_k$，我们有\n$$ \\mathrm{vec}(\\mathcal{S}\\times_1 \\mathbf{P}_k \\times_2 \\mathbf{P}_k \\times_3 \\mathbf{P}_k) = \\left(\\mathbf{P}_k \\otimes \\mathbf{P}_k \\otimes \\mathbf{P}_k\\right)\\mathrm{vec}(\\mathcal{S}) $$\n其中$\\otimes$表示克罗内克积。根据克罗内克积相关性质，我们可以得到\n$$ \\begin{aligned} \\mathbf{P}_k \\otimes \\mathbf{P}_k \\otimes \\mathbf{P}_k =\u0026amp; \\left(\\prod_{i=1}^{k}\\left(\\mathbf{I}-\\mathbf{w}_i\\mathbf{w}_i^{\\mathrm{T}}\\right)\\right) \\otimes \\left(\\prod_{i=1}^{k}\\left(\\mathbf{I}-\\mathbf{w}_i\\mathbf{w}_i^{\\mathrm{T}}\\right) \\right)\\otimes \\left(\\prod_{i=1}^{k}\\left(\\mathbf{I}-\\mathbf{w}_i\\mathbf{w}_i^{\\mathrm{T}}\\right) \\right) \\ =\u0026amp; \\prod_{i=1}^{k}\\left(\\mathbf{I}-\\mathbf{w}_i\\mathbf{w}_i^{\\mathrm{T}}\\right)\\otimes \\left(\\mathbf{I}-\\mathbf{w}_i\\mathbf{w}_i^{\\mathrm{T}}\\right)\\otimes \\left(\\mathbf{I}-\\mathbf{w}_i\\mathbf{w}_i^{\\mathrm{T}}\\right) \\end{aligned} $$\n这意味着事实上我们有\n$$ \\mathrm{vec}(\\mathcal{S}_k) = \\left( \\left(\\mathbf{I}-\\mathbf{w}_k\\mathbf{w}_k^{\\mathrm{T}}\\right)\\otimes \\left(\\mathbf{I}-\\mathbf{w}_k\\mathbf{w}_k^{\\mathrm{T}}\\right)\\otimes \\left(\\mathbf{I}-\\mathbf{w}_k\\mathbf{w}_k^{\\mathrm{T}}\\right) \\right) \\mathrm{vec}(\\mathcal{S}_{k-1}) \\tag{5} $$\n注意到，$\\left(\\mathbf{I}-\\mathbf{w}_k\\mathbf{w}_k^{\\mathrm{T}}\\right)\\otimes \\left(\\mathbf{I}-\\mathbf{w}_k\\mathbf{w}_k^{\\mathrm{T}}\\right)\\otimes \\left(\\mathbf{I}-\\mathbf{w}_k\\mathbf{w}_k^{\\mathrm{T}}\\right)$事实上就是作了一个投影，但同时也把其余有关$\\mathbf{w}_k$的分量全都去除了，例如$\\mathbf{u}\\otimes \\mathbf{w}_k\\otimes \\mathbf{v}$经过上述投影后便是一个零向量。因此这个正交投影显然是一个过强的投影。为了求得所有的解混矢量$\\mathbf{w}$，我们只需要去除$\\mathbf{w}_k\\otimes\\mathbf{w}_k\\otimes\\mathbf{w}_k$即可，因此对于$(5)$的投影矢量，可以将其改写为\n$$ \\mathrm{vec}(\\mathcal{S}_k) = \\left( \\mathbf{I}-\\left(\\mathbf{w}_k\\otimes\\mathbf{w}_k\\otimes\\mathbf{w}_k\\right)\\left(\\mathbf{w}_k\\otimes\\mathbf{w}_k\\otimes\\mathbf{w}_k\\right)^{\\mathrm{T}}\\right) \\mathrm{vec}(\\mathcal{S}_{k-1}) $$\n当然，如果是基于这种向量拉直的形式，无疑具有很大的计算量，为了降低计算量，作者又进行了后续的推导，具体可见《矩阵之美》一书中。最终可得\n$$ \\mathcal{S}_k=\\mathcal{S}_{k-1}-\\left(\\mathcal{S}_{k-1}\\times_1\\mathbf{w}_k\\times_2\\mathbf{w}_k\\times_3\\mathbf{w}_k\\right)(\\mathbf{w}_k \\circ \\mathbf{w}_k \\circ \\mathbf{w}_k) $$\n这样我们就完成了整体算法推导，具体算法流程如下所示\n初始化$k=1$ 计算$\\mathcal{S}_{k-1}$ 迭代计算$\\mathbf{w}_{k} \\leftarrow \\mathcal{S}_{k-1} \\times_2 \\mathbf{w}_{k} \\times_3 \\mathbf{w}_{k}, \\mathbf{w}_{k} \\leftarrow \\frac{\\mathbf{w}_{k}}{\\lVert \\mathbf{w}_{k} \\rVert}$，直到收敛 令$k=2, 3, \\cdots, N$，并重复步骤2至步骤3，直到得到所有解混矢量 最终$\\mathbf{W}_N=\\begin{bmatrix} \\mathbf{w}_1 \u0026amp; \\mathbf{w}_2 \u0026amp; \\cdots \u0026amp; \\mathbf{w}_N \\end{bmatrix}$，即为最终解混矩阵 ","permalink":"https://bingsz.github.io/en/posts/psanpsa/","summary":"张量具有强大的表示能力，许多问题可以通过张量来进行建模，并利用张量相关工具来得到简化。例如，利用张量工具，能够对互质阵列所接收的信号进行建模；也可以利用张量工具对信号的统计特征进行建模。 盲源分离是一种在无先验信息下进行信号源分离的工具，通过最大化信号源之间的独立性来进行信号源分离","title":"张量与盲源分离之间的联系"},{"content":" 这篇文章主要参考《组网雷达多帧检测前跟踪算法研究》（王经鹤）这一篇论文。\n目前雷达的跟踪框架通常是先检测后跟踪，先检测后跟踪（Detect Before Track, DBT）算法的原理是，首先进行回波信号检测得到目标的点迹，随后进行点迹与航迹的配对，最后得到目标的航迹。这种跟踪方法比较符合直觉，因此应用广泛。另一种跟踪框架是检测前跟踪框架（Track Before Detect, TBD），检测前跟踪框架指的是通过多帧信号之间的关联性来得到目标在每一帧的点迹，从而得到目标在这几帧的航迹。检测前跟踪算法并没有直接的对单独某帧作目标检测，而是融合了多帧的回波信号来作检测。这相当于作了一个帧间的非相参积累，因此在同一信噪比情况下，能够得到更高的检测概率。\n组网雷达多帧检测前跟踪算法采用的是分布式信号融合手段，即首先在各个雷达处进行检测前跟踪得到目标在这几帧的航迹，随后将这几帧航迹信息输送至融合中心进行航迹融合。\n1. TBD原理 记雷达发射信号如下所示 $$ s(t) = u(t)\\exp(j\\pi \\mu t^2) $$ 其中$\\mu$为线性调频信号的调频率，$u(t)$为信号的包络。通常，目标的多普勒频率远远小于载频，因此这里忽略了多普勒频率。经过目标反射被雷达接收机后得到如下回波信号 $$ x(t) = u(t-\\tau)\\exp(j\\pi \\mu (t-\\tau)^2) $$ 其中$\\tau=\\frac{2R}{c}$，$R$为目标距离，$\\tau$表示目标的双程延时。上述信号经过采样后在接收机处得到如下离散回波信号 $$ \\mathbf{x}_i=\\begin{pmatrix} x(0) \u0026amp; x(T_s) \u0026amp; x(2T_s) \u0026amp; \u0026hellip; \u0026amp; x((n-1)T_s) \\end{pmatrix} $$ 其中下标$i$表示这是在一个CPI（相参处理时间）中的第$i$个回波，$T_s$表示采样周期，$n$表示采样点数。一个CPI内的回波信号矩阵可如下表示 $$ \\mathbf{x} = \\begin{pmatrix} \\mathbf{x}_1 \\\\ \\mathbf{x}_2 \\\\ \u0026hellip; \\\\ \\mathbf{x}_N \\end{pmatrix} $$ 其中$N$表示一个CPI内总共有$N$个回波。对$\\mathbf{x}$在列方向上作FFT，即可得到多普勒-距离二维矩阵，记其为$\\mathbf{X}$。为了方便，将雷达在一个CPI内得到的多普勒-距离二维矩阵记为一帧，并将第$i$帧记为$\\mathbf{X}_i$。多帧检测前跟踪算法指的是利用$\\mathbf{X}_1$，$\\mathbf{X}_2$，\u0026hellip;，$\\mathbf{X}_m$这$m$帧来作检测前跟踪（PS：原文中还考虑了天线的俯仰角与方位角，此处为了方便只考虑了距离与多普勒频率，但可以容易地推广到这四个因素）。\n目前的多帧检测前跟踪算法主要有基于动态规划的检测前跟踪算法，基于概率密度的检测前跟踪算法等，此处介绍基于动态规划的检测前跟踪算法。（PS：下面的一些记号与原文中的将会有一些不一致）\n基于动态规划的检测前跟踪算法基于下式展开\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\arg \\max_{i_m, j_m} I(\\mathbf{X}_m, i_m, j_m) \\\\ \u0026amp;\\mathrm{s.t} \\quad I(\\mathbf{X}_m(i_m, j_m)) \u0026gt; L \\end{aligned} \\right. \\tag{1.1} $$\n其中$\\mathbf{X}_m(i_m, j_m)$表示$\\mathbf{X}_m$的第$i_m$行、第$j_m$列的元素，$i_m$与$j_m$取遍整个矩阵$\\mathbf{X}_m$，$I(\\cdot)$为一个值函数，理想情况下，这个函数的值应当与存在目标的概率呈正相关，$L$为检测门限，仅当值函数大于该值时，才表明具有目标。在文章中，作者给出了一种值函数如下所示 $$ I(\\mathbf{X}_m, i_m, j_m) = |\\mathbf{X}_m(i_m, j_m)|+\\arg \\max_{i_{m-1}, j_{m-1} \\in \\tau(i_m, j_m)} I(\\mathbf{X}_{m-1}, i_{m-1}, j_{m-1}) $$ 其中$|\\mathbf{X}_m(i_m, j_m)|$表示$\\mathbf{X}_m(i_m, j_m)$的模值，$\\tau(i_m, j_m)$表示当目标位于$\\mathbf{X}_m$的第$i_m$行、第$j_m$列时，$m-1$帧目标可能存在的位置集合。当求解得到符合$(1.1)$式要求的$(i_m, j_m)$后，其对应的$(i_{m-1}, j_{m-1})$，\u0026hellip;，$(i_1, j_1)$便构成了目标的航迹。\n从上述推导来看，基于动态规划的检测前跟踪算法具有的一个隐含假设是，第$k$帧的目标回波信号幅值应当在其周围取到最大值，否则在信噪比过小，周围噪声幅值高于信号幅值时，便会形成一个错误的点迹。这一部分内容将在后续的仿真中体现出来。\n2. 组网雷达航迹融合 组网雷达航迹融合过程主要有：空间对准，时间对准，航迹配对，航迹融合。不过时空对准，航迹配对并不是本节重点，本节着重介绍航迹融合。\n2.1 空间对准 每个雷达在经过上述的TBD算法后，可以得到目标距雷达的距离信息。结合雷达对目标的角度测量信息，可以将上述雷达得到的目标点迹从各雷达自身的极坐标系转换至绝对坐标系下。记目标在绝对坐标系下的状态量为$\\mathbf{x}$（与前文的回波信号矩阵$\\mathbf{x}$区分开来） $$ \\mathbf{x} = \\begin{pmatrix} x \u0026amp; \\dot{x} \u0026amp; y \u0026amp; \\dot{y} \u0026amp; z \u0026amp; \\dot{z} \\end{pmatrix}^T $$ 上述的不加粗$x$，$y$，$z$分别表示绝对坐标系下的值，$\\dot{x}$表示$x$的微分，即$x$方向上的速度。需要注意的是，原文（包括本文）假设目标符合匀速运动模型，因此目标状态量中没有包含目标的加速度。\n2.2 时间对准 每个雷达得到的目标航迹不一定位于同一时刻，因此有必要将各个雷达得到的航迹转换至同一时间维度下。原文中给出的一种转换方法是基于线性插值的转换方法。记雷达站k得到的第p帧航迹时刻为$t_k^p$，融合中心的时刻为$t_1$，$t_2$，\u0026hellip;，$t_m$，那么雷达站k的航迹可通过如下公式转换至融合中心的时间维度下（原文中的这个公式有一个小笔误）\n$$ \\hat{x}_k^p = \\left\\{ \\begin{aligned} x_k^p + (t_p - t_k^p)\\frac{x_k^p - x_k^{p+1}}{t_k^p - t_k^{p+1}} \u0026amp; \u0026amp; t_k^p \\leq t_p \\leq t_k^{p+1} \\\\ x_k^m + (t_p - t_k^m)\\frac{x_k^{m-1} - x_k^{m}}{t_k^{m-1} - t_k^{m}} \u0026amp; \u0026amp; t_k^m \u0026lt; t_p \\\\ x_k^1 + (t_p - t_k^1)\\frac{x_k^1 - x_k^{2}}{t_k^1 - t_k^{2}} \u0026amp; \u0026amp; t_p \u0026lt; t_k^1 \\end{aligned} \\right. $$\n其中$\\hat{x}_k^p$表示融合中心时间维度下的雷达站k得到的目标在第p帧时的航迹。对于$y_k^p$与$z_k^p$同理通过上式公式转换至融合中心时间维度下。最终记融合中心维度下的雷达站k的第p帧航迹信息为$\\hat{\\mathbf{x}}^p_k$\n2.3 航迹配对 航迹配对通常是在某个准则下，比较两条航迹的误差，当误差小于可接受值时，便认为两条航迹为同一条；当一条航迹的误差大于其它任何一条航迹时，便认为这是一条虚警航迹。原文中（虽然没有提及，但显然是）采用L-∞范数来作为航迹配对时的两条航迹误差。具体步骤如下\n首先考虑值函数最大的一条航迹，计算这条航迹与其它航迹之间的L-∞范数（即两条航迹相差绝对值的最大值）来作为误差，若误差小于一个可接受值，则认为这两条航迹为同一条 当配对完值函数最大的一条航迹后，将这些航迹从待配对航迹中删除，并重复步骤1，直到所有航迹都配对完或只剩下虚警航迹。 2.4 航迹融合 2.4.1 基本原理 此处的组网雷达航迹融合算法基于贝叶斯滤波框架，采用最大后验概率的方式来作融合。具体来说，记$\\mathbf{x}^{1:p}$表示第1帧至第$p$帧的融合结果，那么基于最大后验概率的融合方式如下所示 $$ \\mathbf{x}^{1:p} = \\int \\mathbf{x}^{1:p}P(\\mathbf{x}^{1:p} | \\hat{\\mathbf{x}}_{1:K}^{1:p}) \\mathrm{d} \\mathbf{x}^{1:p} $$ 其中$K$表示雷达站个数，$\\hat{\\mathbf{x}}_{1:K}^{1:p}$表示各个雷达站的第p帧目标观测数据。由于点迹间具有相关性，因此为了评估后验概率，原文中使用了广义协方差交叉融合方法，如下所示 $$ P(\\mathbf{x}^{1:p} | \\hat{\\mathbf{x}}_{1:K}^{1:p}) = \\frac{\\displaystyle\\prod_{k}P(\\mathbf{x}^{1:p} | \\hat{\\mathbf{x}}_k^{1:p})^{\\omega_k}}{\\displaystyle{\\int}\\prod_{k}P(\\mathbf{\\chi}^{1:p} | \\hat{\\mathbf{x}}_k^{1:p})^{\\omega_k} \\mathrm{d}\\chi^{1:p}} \\tag{2.1} $$ 其中$\\omega_k\u0026gt;0$且$\\sum_k \\omega_k = 1$。为了使用序贯重要性采样的粒子滤波算法，我们期望找到$P(\\mathbf{x}^{1:p} | \\hat{\\mathbf{x}}_{1:K}^{1:p})$与$P(\\mathbf{x}^{1:p-1} | \\hat{\\mathbf{x}}_{1:K}^{1:p-1})$之间的关系，注意到 $$ \\begin{aligned} P(\\mathbf{x}^{1:p}|\\hat{\\mathbf{x}}_{k}^{1:p}) =\u0026amp; \\frac{P(\\mathbf{x}^{p}, \\hat{\\mathbf{x}}_{k}^{p}|\\hat{\\mathbf{x}}_{k}^{1:p-1}, \\mathbf{x}^{1:p-1})P(\\mathbf{x}^{1:p-1}|\\hat{\\mathbf{x}}_{k}^{1:p-1})}{P(\\hat{\\mathbf{x}}_{k}^{p}|\\hat{\\mathbf{x}}_{k}^{1:p-1})} \\end{aligned} \\tag{2.2} $$ 由于独立观测假设（$\\hat{\\mathbf{x}}_k^p$仅与$\\mathbf{x}^p$有关）与一阶齐次马尔科夫假设（$\\mathbf{x}^p$仅与$\\mathbf{x}^{p-1}$有关），可以得到 $$ \\begin{aligned} P(\\mathbf{x}^{p}, \\hat{\\mathbf{x}}_{k}^{p}|\\hat{\\mathbf{x}}_{k}^{1:p-1}, \\mathbf{x}^{1:p-1}) =\u0026amp; P(\\mathbf{x}^{p}, \\hat{\\mathbf{x}}_{k}^{p}|\\mathbf{x}^{p-1}) \\\\ =\u0026amp; P(\\hat{\\mathbf{x}}_{k}^{p}|\\mathbf{x}^{p})P(\\mathbf{x}^{p}|\\mathbf{x}^{p-1}) \\end{aligned} $$ 将上式代入$(2.2)$式中，可以得到 $$ P(\\mathbf{x}^{1:p}|\\hat{\\mathbf{x}}_{k}^{1:p}) = \\frac{P(\\hat{\\mathbf{x}}_{k}^{p}|\\mathbf{x}^{p})P(\\mathbf{x}^{p}|\\mathbf{x}^{p-1})}{P(\\hat{\\mathbf{x}}_{k}^{p}|\\hat{\\mathbf{x}}_{k}^{1:p-1})}P(\\mathbf{x}^{1:p-1}|\\hat{\\mathbf{x}}_{k}^{1:p-1}) $$ 这样就得到了$P(\\mathbf{x}^{1:p}|\\hat{\\mathbf{x}}_{k}^{1:p})$的递推式。将上式代入到$(2.1)$式中可以得到（原文中此处有个笔误） $$ \\begin{aligned} P(\\mathbf{x}^{1:p} | \\hat{\\mathbf{x}}_{1:K}^{1:p}) =\u0026amp; \\frac{\\displaystyle\\prod_{k}P(\\mathbf{x}^{1:p} | \\hat{\\mathbf{x}}_k^{1:p})^{\\omega_k}}{\\displaystyle{\\int}\\prod_{k}P(\\mathbf{\\chi}^{1:p} | \\hat{\\mathbf{x}}_k^{1:p})^{\\omega_k} \\mathrm{d}\\chi^{1:p}} \\\\ =\u0026amp; \\frac{P(\\mathbf{x}^{p}|\\mathbf{x}^{p-1})\\displaystyle\\prod_{k}P(\\hat{\\mathbf{x}}_{k}^{p}|\\mathbf{x}^{p})^{\\omega_k}P(\\mathbf{x}^{1:p-1}|\\hat{\\mathbf{x}}_{k}^{1:p-1})^{\\omega_k}}{\\displaystyle{\\int}\\prod_{k}P(\\mathbf{\\chi}^{1:p} | \\hat{\\mathbf{x}}_k^{1:p})^{\\omega_k} \\mathrm{d}\\chi^{1:p} \\displaystyle\\prod_kP(\\hat{\\mathbf{x}}_{k}^{p}|\\hat{\\mathbf{x}}_{k}^{1:p-1})} \\\\ =\u0026amp; \\mathrm{C} P(\\mathbf{x}^{p}|\\mathbf{x}^{p-1})\\displaystyle\\prod_{k}P(\\hat{\\mathbf{x}}_{k}^{p}|\\mathbf{x}^{p})^{\\omega_k}P(\\mathbf{x}^{1:p-1} | \\hat{\\mathbf{x}}_{1:K}^{1:p-1}) \\end{aligned} \\tag{2.3} $$ 其中$\\mathrm{C}$如下所示，注意到$\\mathrm{C}$是一个常数，只起到一个概率正则功能。因此在使用粒子滤波时，并不需要考虑这一项，对粒子作归一化权重即可。 $$ \\mathrm{C} = \\frac{\\displaystyle\\int\\prod_{k}P(\\mathbf{\\chi}^{1:p-1} | \\hat{\\mathbf{x}}_k^{1:p-1})^{\\omega_k} \\mathrm{d}\\chi^{1:p-1}}{\\displaystyle\\int\\prod_{k}P(\\mathbf{\\chi}^{1:p} | \\hat{\\mathbf{x}}_k^{1:p})^{\\omega_k} \\mathrm{d}\\chi^{1:p}\\displaystyle\\prod_kP(\\hat{\\mathbf{x}}_{k}^{p}|\\hat{\\mathbf{x}}_{k}^{1:p-1})} $$\n2.4.2 粒子滤波算法 粒子滤波算法是基于蒙特卡洛方法的一种滤波算法，利用大量的随机粒子来近似目标分布。重新考虑期望公式 $$ E = \\int x P(x) \\mathrm{d}x $$ 若令$x_i\\sim P(x)$（$i = 1, 2, \u0026hellip;, N$），那么上式可写为 $$ E \\approx \\frac{1}{N}\\sum_i x_i $$ 当$N$充分大时，上式便可以用来精确的近似$E$。但是$P(x)$通常是难以求解的，引入重要性分布$Q(x)$，期望公式可改写为 $$ E=\\int \\frac{P(x)}{Q(x)}x Q(x) \\mathrm{d}x $$ 上式可理解为，一个加权的$Q(x)$期望可以用来表示$P(x)$期望，进一步用近似的思想令$x_i\\sim Q(x)$（$i = 1, 2, \u0026hellip;, N$），那么有 $$ E \\approx \\frac{1}{N} \\sum_i \\frac{P(x_i)}{Q(x_i)}x_i = \\frac{1}{N} \\sum_i w_i x_i $$ 上式中$w_i$即为$x_i$的权重，通过一个加权的$x_i$的和，可以用满足$Q(x)$分布的$x_i$来近似$P(x)$的期望。注意到，由于$x_i \\sim Q(x)$，因此 $$ \\begin{aligned} \\sum_i \\frac{w_i}{N} =\u0026amp; \\frac{1}{N}\\sum_i\\frac{P(x_i)}{Q(x_i)} \\\\ \\approx \u0026amp; \\int \\frac{P(x)}{Q(x)}Q(x) \\mathrm{d}x = 1 \\end{aligned} $$ 所以为了有更佳的性能，可以使用归一化的$\\hat{w}_i$来代替$w_i$ $$ \\begin{aligned} E \\approx \u0026amp; \\sum_i \\frac{w_i}{N} x_i = \\sum_i \\hat{w}_i x_i \\\\ \\hat{w}_i =\u0026amp; \\frac{w_i}{\\displaystyle\\sum_i w_i} \\end{aligned} \\tag{2.4} $$ 这样做的一个好处是在计算$\\hat{w}_i$时不再需要关心$\\frac{P(x)}{Q(x)}$的常数项，从而使得计算变得非常简便。\n目标状态估计中，通常使用序贯重要性采样来获得一系列粒子。序贯重要性采样指的是下一时刻的粒子状态与权重由该时刻粒子采样、更新而来。在序贯重要性采样中，为了求解该时刻粒子权重与下一时刻粒子权重之间的关系，需要求解该时刻概率密度函数与下一时刻概率密度函数之间的关系，即求解$P(x_{1:k}|z_{1:k})$（对应于本文中就是$P(\\mathbf{x}^{1:p}|\\hat{\\mathbf{x}}_{1:K}^{1:p})$）与$P(x_{1:k-1}|z_{1:k-1})$之间的关系，由贝叶斯公式可以得到 $$ \\begin{aligned} P(x_{1:k}|z_{1:k}) =\u0026amp; \\frac{P(x_k, z_k|x_{k-1})P(x_{1:k-1}|z_{1:k-1})}{P(z_k|z_{1:k-1})} \\\\ =\u0026amp; \\frac{P(z_k|x_k)P(x_k|x_{k-1})P(x_{1:k-1}|z_{1:k-1})}{P(z_k|z_{1:k-1})} \\end{aligned} $$ 注意到 $$ Q(x_{1:k}|z_{1:k})=Q(x_k|x_{k-1}, z_{1:k})Q(x_{1:k-1}|z_{1:k-1}) $$ 因此有 $$ w_i^k = \\frac{P(x_{1:k}^i|z_{1:k})}{Q(x_{1:k}^i|z_{1:k})} = \\frac{P(z_k|x_k^i)P(x_k^i|x_{k-1}^i)}{P(z_k|z_{1:k-1})Q(x_k^i|x_{k-1}^i, z_{1:k})}w_i^{k-1} \\tag{2.5} $$ 其中$w_i^k$表示$k$时刻的第$i$个粒子，$x_k^i$表示$k$时刻的第$i$个粒子。因为后续有归一化步骤，因此这里可以不考虑常数项，得到 $$ w_i^k = \\frac{P(z_k|x_k^i)P(x_k^i|x_{k-1}^i)}{Q(x_k^i|x_{k-1}^i, z_{1:k})}w_i^{k-1} $$ 这样就得到了权重更新公式，下一时刻的粒子权重可以由该时刻粒子的权重得到。在实际应用过程中，为了方便，令$Q(x_k|x_{k-1}, z_{1:k}) = P(x_k|x_{k-1})$，这样便可以得到 $$ w_i^k = P(z_k|x_k^i)w_i^{k-1} $$ 当取$Q(x_k|x_{k-1}, z_{1:k}) = P(x_k|x_{k-1})$时，相当于令$x_k^i \\sim P(x_k^i | x_{k-1}^i)$后作一个加权求和，因此$k$时刻的粒子状态可以由$k-1$时刻的粒子状态通过$P(x_k^i | x_{k-1}^i)$采样得来。这就完成了从这一时刻的粒子状态与权重更新到下一时刻的粒子状态与权重了，随后利用$(2.4)$式便完成了目标状态估计。\n总结来说，粒子滤波算法的步骤如下所示\n初始化粒子$x_i^0 \\sim P(x_0)$，$P(x_0)$表示粒子初始状态分布，初始化权重$w_i^0 = \\frac{1}{N}$ 更新粒子状态，$x_i^k \\sim P(x_i^k | x_i^{k-1})$ 根据观测值$z_k$计算得到$k$时刻$i$粒子的权重$w_i^k$，并归一化得到$\\hat{w}_i^k$ 对$k$时刻粒子作加权求和得到$k$时刻的状态估计量，重复2-4步，直到得到所有时刻的估计状态量 但是在实际应用中，通常会发生粒子退化的情况。粒子退化指的是经过多次迭代后，大部分粒子都处于低似然区域，这使得最终不能很好地得到状态估计量。粒子退化的另一个直观理解是，经过多次迭代后，大部分粒子“跑偏”了真实目标状态量而无法返回到正常轨迹上来。为了解决这一问题，学者提出了粒子重采样方法。粒子重采样方法指的是在粒子更新完成后，权重大的粒子更倾向于保留下来，权重小的粒子更倾向于舍弃，这样便使得大部分粒子都位于高似然区域。具体做法是，按照归一化权重作为各个粒子被抽取到的概率进行$N$次抽取。这样在保证了粒子数目不变（$N$个粒子）的同时，也使得位于高似然区域粒子被保留下来，而低似然区域粒子被舍弃。\n因此粒子滤波算法的完整步骤为\n初始化粒子$x_i^0 \\sim P(x_0)$，$P(x_0)$表示粒子初始状态分布，初始化权重$w_i^0 = \\frac{1}{N}$ 更新粒子状态，$x_i^k \\sim P(x_i^k | x_i^{k-1})$ 根据观测值$z_k$计算得到$k$时刻$i$粒子的权重$w_i^k$，并归一化得到$\\hat{w}_i^k$ 对$k$时刻粒子作加权求和得到$k$时刻的状态估计量，并作重采样，重复2-4步，直到得到所有时刻的估计状态量 2.4.3 基于粒子滤波的组网雷达航迹融合方法 将$(2.3)$式代入到$(2.5)$式中，可以得到 $$ \\begin{aligned} w_i^k =\u0026amp; \\frac{P(x_{1:k}^i|z_{1:k})}{Q(x_{1:k}^i|z_{1:k})} \\\\ \\propto \u0026amp; (\\displaystyle\\prod_{k}P(\\hat{\\mathbf{x}}_{k}^{p}|\\mathbf{x}^{p})^{\\omega_k})w_i^{k-1} \\end{aligned} $$ 这样便得到了组网雷达航迹融合中的权值更新方式。总结来说，基于组网雷达的多帧检测前跟踪算法的完整步骤如下所示\n所有雷达先在本地执行多帧检测前跟踪算法，得到一系列目标航迹$\\mathbf{x}_k^p$ 各个雷达站将得到的航迹传送至融合中心，并由融合中心进行时空校准与航迹配对 融合中心按照上文给出的粒子滤波算法步骤进行粒子滤波，得到最终的融合目标航迹 3. 仿真分析 假设有两个雷达站，两个雷达站的方位如下所示\n雷达站编号 x y z 1 0 0 0 2 1km 0 0 目标位于$(2\\mathrm{km}, 2\\mathrm{km}, 0)^T$处，作速度为$(200\\mathrm{m/s}, 0, 0)^T$的匀速运动。假设雷达回波信号经过匹配滤波后的信噪比为$-10\\mathrm{dB}$，雷达相参积累个数为$100$个，经过相参积累后回波的信噪比为$10\\mathrm{dB}$，但此时仍然无法从多普勒-距离二维矩阵中检测到目标，结果如下所示\n图3.1：单帧检测结果\r对目标作10帧的检测前跟踪可得到如下所示结果\n图3.2：雷达站本地检测前跟踪结果\r可以看到此时两个雷达站得到的目标航迹与真实航迹偏差较大，当两雷达站将目标航迹传送至融合中心后，利用粒子滤波可以得到两者综合之后的航迹如下所示\n图3.3：航迹融合结果\r可以看到融合后的航迹误差相比两雷达站各自的航迹误差较小，这说明组网雷达多帧检测前融合算法完成了雷达检测前跟踪任务与航迹融合任务。\n","permalink":"https://bingsz.github.io/en/posts/nettedradartbd/","summary":"这篇文章主要参考《组网雷达多帧检测前跟踪算法研究》（王经鹤）这一篇论文。 目前雷达的跟踪框架通常是先检测后跟踪，先检测后跟踪（Detect Before Track, DBT）算法的原理是，首先进行回波信号检测得到目标的点迹，随后进行点迹与航迹的配对，最后得到目标的航迹。这种跟踪方法比较符合直觉，因此应用广","title":"组网雷达多帧检测前跟踪算法"},{"content":" 这一题目是摘自我的大学生创新训练项目，本文主要论证一下圆周外扫描的毫米波合成孔径雷达的可实现性。\n1. 基本原理 基于圆周外扫描的毫米波合成孔径雷达（下文简称CSSAR（Circular Scan SAR）系统）的基本系统组成草图如下所示\n图1.1：系统组成草图\r主要组成部分有雷达，转动轴与转动轨道。雷达在转动轨道上绕着转动轴旋转，同时在旋转过程中收发电磁波完成信号采集过程。随后雷达将采集得到的信号传输至上位机，上位机利用雷达成像算法来得到最终的成像结果。\n一方面来说，传统的SAR系统通常基于一个直线轨迹采集信号回波数据（如固定在一个直轨道上，或者固定在飞机上），而上述系统是基于一个圆周轨道的，因此有必要论证一下方案的合理性。从另一个方面来说，基于圆周轨道的旋转在极短时间内可以近似为作切线方向的直线运动，因此上述系统具备一定的可行性，还需进一步论证。\n2. 基本参数推导 2.1. 方位维分辨率 2.1.1. 基本公式推导 雷达距离维分辨率主要取决于毫米波雷达本身，而与本文所讨论的CSSAR并无直接关系，因此本文不对距离维分辨率作推导。\nCSSAR系统的俯视图如下所示。其中目标与雷达的距离为$R$，雷达旋转半径为$r$，转动角速度为$\\omega_r$，转动轴与目标的连线和转动轴与雷达的连线夹角记为$\\alpha$。\n图2.1：系统组成俯视图\r记雷达与目标之间的距离为$R_0$，根据余弦定理有 $$ R_0 = \\sqrt{R^2+r^2-2Rr\\cos \\alpha} \\tag{2.1} $$ 假设雷达发射线性调频信号，调频率为$\\mu$，于是发射信号可以表示为 $$ x_s(t)=u(t)\\exp (j\\pi \\mu t^2) \\exp(j 2\\pi f_0 t) \\tag{2.2} $$ 其中$u(t)$表示发射信号的包络。发射信号经过目标发射后，可得接收信号（已下变频）为 $$ \\begin{aligned} x_r(t)=\u0026amp;u(t-\\frac{2R_0}{c})\\exp(j\\pi \\mu (t-\\frac{2R_0}{c})^2)\\exp(-j4\\pi f_0 \\frac{R_0}{c}) \\\\ =\u0026amp; u(t-\\frac{2R_0}{c})\\exp(j\\pi \\mu (t-\\frac{2R_0}{c})^2) \\\\ \u0026amp; \\qquad \\qquad \\exp(-j4\\pi f_0 \\frac{\\sqrt{R^2+r^2-2Rr\\cos \\alpha}}{c}) \\end{aligned} \\tag{2.3} $$ 已知$\\sqrt{1+x} \\approx 1+\\frac{x}{2}$，于是有$\\sqrt{R^2+r^2-2Rr\\cos \\alpha} \\approx R+\\frac{r^2-2Rr\\cos \\alpha}{2R}$。但该近似在本系统中达不到精确度要求，因此需要在该近似的基础上添加一个修正因子，观察可知近似误差可近似为仅与$R$与$r$有关，记为$\\beta(r, R)$，于是有下式成立 $$ \\sqrt{R^2+r^2-2Rr\\cos\\alpha} \\approx R+\\frac{r^2-2Rr\\cos \\alpha}{2R\\beta(r, R)} \\tag{2.4} $$ 同时对$\\cos\\alpha$作二阶麦克劳林级数展开后可得到$\\cos\\alpha \\approx 1+\\frac{\\alpha^2}{2}=1+\\frac{\\omega^2t^2}{2}$，其中$\\omega$为雷达旋转角速度。同样，将该近似代入公式后也是无法达到系统精度要求的，因此取一个修正因子$\\gamma(r, R)$，可得到如下公式 $$ \\sqrt{R^2+r^2-2Rr\\cos\\alpha} \\approx R+\\frac{r^2}{2R\\beta(r, R)}-\\frac{r}{\\beta(r, R)}+\\frac{\\gamma(r, R)r\\omega^2t^2}{2\\beta(r, R)} \\tag{2.5} $$ 接下来进行仿真分析上述近似是否有效，取$R=2$，$r=0.5$，$\\beta=0.875$，$\\gamma=1.145$，$\\omega=\\pi\\ \\mathrm{rad} /s$时，可以得到如下所示结果\n图2.2：近似比较\r图2.3：近似误差\r此时近似的最大误差为$1.6 \\times 10^{-4}$，小于毫米波波长的$\\frac{1}{32}$，因此近似是合理的。将上述近似代入$(2.3)$式，忽略常数项，可以得到 $$ x_r(t)=u(t-\\frac{2R_0}{c})\\exp(j\\pi \\mu (t-\\frac{2R_0}{c})^2)\\exp(-j\\pi f_0 \\frac{\\gamma(r, R)\\omega_r^2t^2}{cR\\beta(r, R)}) \\tag{2.6} $$ 从上式观察可得，慢时间维上的多普勒调频率为 $$ \\mu_d = \\frac{f_0 \\gamma(r, R) \\omega_r^2}{cR\\beta(r, R)} $$ 假设天线方向图波束宽度为$\\theta_w$，于是可得到驻留时间为 $$ T_d = \\frac{\\theta_w}{\\omega_r} $$ 因此慢时间维上的线性调频信号带宽为 $$ B = T_d\\mu_d=\\frac{\\theta_wf_0 \\gamma(r, R)\\omega_r}{c R\\beta(r, R)} $$ 因此脉冲压缩后的脉冲宽度为 $$ \\tau = \\frac{c R\\beta(r, R)}{\\theta_wf_0 \\gamma(r, R)\\omega_r} $$ 于是可得方位维上的分辨率为 $$ \\rho_\\theta = \\tau \\omega_r R = \\frac{cR^2\\beta(r, R)}{\\theta_wf_0 \\gamma(r, R)} \\tag{2.7} $$ 取下述参数代入公式，计算可得$\\rho_\\theta \\approx 2.7 \\mathrm{mm}$。\n参数 值 r 0.5m R 2m $\\omega_r$ $\\pi /\\mathrm{s}$ $\\beta(0.5, 2)$ 0.875 $\\gamma(0.5, 2)$ 2.289 $\\theta_w$ $40^\\circ$ $f_0$ $60\\mathrm{GHz}$ 2.1.2. $\\beta(r, R)$与$\\gamma(r, R)$推导 首先考虑$\\beta(r, R)$的计算，已知$\\beta(r, R)$是为了补偿下式公式在$\\alpha=0$时的近似而提出的，因此$\\beta(r, R)$的选择应当使得当$\\alpha$为0时，下式两端相等。 $$ \\sqrt{R^2+r^2-2Rr\\cos \\alpha} \\approx R + \\frac{r^2-2Rr\\cos \\alpha}{2R\\beta(r, R)} $$ 于是可得 $$ \\beta(r, R) = \\frac{r^2-2Rr}{2R(\\sqrt{R^2+r^2-2Rr} - R)} \\tag{2.8} $$ 然后考虑$\\gamma(r, R)$补偿因子的选择问题。$\\gamma(r, R)$的提出是由于下式的右端在二次项方面不能很好拟合左端。因此，为了得到$\\gamma(r, R)$参数，需要对下式作最小二乘拟合 $$ \\sqrt{R^2+r^2-2Rr\\cos (\\omega_r t)} \\approx R + \\frac{r^2}{2R\\beta(r, R)} - \\frac{r}{\\beta(r, R)} + \\frac{\\gamma(r, R)\\omega_r^2 t^2}{4R\\beta(r, R)} $$\n但是对上式作最小二乘拟合所得到的公式非常复杂，而我们推导这两个参数只是为了计算这种雷达结构的方位维分辨率，因此可进一步对$\\gamma(r, R)$作近似。我们对上式两边求二阶导数可得\n$$ \\frac{ARr\\omega_r^2 \\cos(\\omega_r t) - R^2r^2\\omega_r^2\\sin^2(\\omega_r t)}{A^{\\frac{3}{2}}} = \\frac{\\gamma(r, R)\\omega_r^2}{2R\\beta(r, R)} \\tag{2.9} $$\n其中$A = R^2+r^2-2Rr\\cos(\\omega_r t)$。\n为了近似求得$\\gamma(r, R)$，可对$(2.9)$式的左端取离散点，然后求平均值来近似得到一段区间上的二阶导数值的平均值，最后求解出$\\gamma(r, R)$。\n例如，若已知波束在$t \\in (-t_0, t_0)$上照射到物体上，则可取$t=\\frac{t_0}{2}$，来作为$(2.9)$式左端的近似，于是可求得$\\gamma(r, R)$的近似值为\n$$ \\gamma(r, R) \\approx \\frac{2R\\beta(r, R)(ARr\\omega_r^2 \\cos(\\omega_r t) - R^2r^2\\omega_r^2\\sin^2(\\omega_r t))}{\\omega_r^2 A^{\\frac{3}{2}}} \\tag{2.10} $$\n将$(2.8)$式与$(2.10)$式代入$(2.7)$式中，便可求得方位维分辨率。若将同样的数据代入，可得到方位分辨率为$\\text{2.8mm}$，与之前的预估值近似。\n2.2. 脉冲重复频率 由第二节的回波模型可以得到\n$$ \\begin{align*} x_r(t) = u(t - \\frac{2R_0}{c})\u0026amp;\\exp(j\\pi \\mu (t - \\frac{2R_0}{c})^2) \\\\ \u0026amp;\\ \\ \\exp(-j4\\pi f_0 \\frac{\\sqrt{R^2+r^2-2Rr\\cos \\alpha}}{c}) \\end{align*} $$\n将第二个指数项的近似代入，并且忽略常数项可得\n$$ x_r(t) = u(t - \\frac{2R_0}{c})\\exp(j\\pi \\mu (t - \\frac{2R_0}{c})^2)\\exp(-j\\pi f_0 \\frac{\\gamma(r, R)\\omega_r^2 t^2}{cR\\beta(r, R)}) $$\n于是驻留时间为$T_d = \\frac{\\theta_w}{\\omega_r}$，于是可以得到信号带宽为\n$$ B = \\frac{\\theta_w f_0\\gamma(r, R)\\omega_r}{cR\\beta(r, R)} $$\n雷达在慢时间维上的积累等价于对上述信号进行一个采样，因此脉冲重复频率应当\n$$ f_d \\geq 2B = \\frac{2\\theta_w f_0\\gamma(r, R)\\omega_r}{cR\\beta(r, R)} \\tag{2.11} $$\n取$R=\\text{2m}$, $r=\\text{0.5m}, \\omega_r = \\pi \\text{/s}, \\beta(0.5, 2) = 0.875, \\gamma(0.5, 2) = 2.289, \\theta_w = 40^{\\circ}, f_0 = \\text{60GHz}$，代入上述公式可计算得$f_d \\geq \\text{1148Hz}$\n2.3. 数据传输速率要求 由于雷达开发板自身的容量较小，因此一个方法是将数据上传至上位机进行处理，因此本节对上传速率进行推导。 假设脉冲重复频率为$f_d$，在快时间维上采样点数为$n_0$，若$\\text{ADC}$采样位数为$n_A$比特，且使用$\\text{IQ}$正交采样，有$n_t$个发射天线，$n_r$个接收天线。于是有每秒数据量（KB）为 $$ D = \\frac{f_d n_0 n_A n_t n_r}{4096} $$ 因此通讯速率应当大于$D$。若取$f_d = \\text{2000Hz}, n_0 = 256, n_A = 16, n_t = 3, n_r = 4$，可计算得 $$ D = \\frac{2000 \\times 256 \\times 16 \\times 3 \\times 4}{4096} = 24000\\text{KB} \\approx 24\\text{MB} $$\n2.4. 伺服系统的角速度徙动影响 根据图1.1给出的结构可以发现，现实世界中的伺服系统转动时的角速度通常不能保持为一个恒定的值，而角速度的这种徙动会对雷达的成像精度造成影响，本节对这种影响进行一个分析。 直接对回波信号作一个近似，可得 $$ x_r(t) = u(t - \\frac{2R_0}{c})\\exp(j\\pi \\mu (t - \\frac{2R_0}{c})^2)\\exp(-j\\pi f_0 \\frac{\\gamma(r, R)\\omega_r^2 t^2}{cR\\beta(r, R)}) $$ 可以看到，角速度徙动带来的影响主要在第二个指数项。假设期望角速度为$\\omega_s$，而角速度徙动带来的误差为$\\Delta \\omega_s$，于是在某一时刻，角速度的值可以被表示为$\\omega_r = \\omega_s+ \\Delta \\omega_s$。不妨假设$\\Delta \\omega_s$服从均值为$0$，方差为$\\sigma_s^2$的一个高斯正态分布。将$\\omega_r = \\omega_s+ \\Delta \\omega_s$代入上式的第二个指数项，可以得到 $$ \\exp(-j\\pi f_0 \\frac{\\gamma(r, R)\\omega_r^2 t^2}{cR\\beta(r, R)}) = \\exp(-j\\pi f_0 \\frac{\\gamma(r, R)(\\omega_s + \\Delta \\omega_s)^2 t^2}{cR\\beta(r, R)}) $$ 通常$\\omega_r \\gg \\Delta \\omega_s$，于是忽略高阶项可得$(\\omega_s + \\Delta \\omega_s)^2 \\approx \\omega_s^2 + 2\\omega_s \\Delta \\omega_s$，将其代入上式可以得到 $$ \\begin{align*} \\exp(-j\\pi f_0 \\frac{\\gamma(r, R)\\omega_r^2 t^2}{cR\\beta(r, R)}) =\u0026amp; \\exp(-j\\pi f_0 \\frac{\\gamma(r, R)(\\omega_s + \\Delta \\omega_s)^2 t^2}{cR\\beta(r, R)}) \\\\ =\u0026amp; \\exp(-j\\pi f_0 \\frac{\\gamma(r, R)\\omega_s^2 t^2}{cR\\beta(r, R)} - j\\pi f_0 \\frac{2\\gamma(r, R)\\omega_s\\Delta\\omega_s t^2}{cR\\beta(r, R)}) \\end{align*} $$ 可以看到，角速度徙动带来的误差相当于在原本线性调频信号的基础上，增加了一个相位抖动项，记为$\\Delta \\phi$，于是有 $$ \\Delta \\phi = \\pi f_0 \\frac{2\\gamma(r, R)\\omega_s\\Delta\\omega_s t^2}{cR\\beta(r, R)} $$ 已知$\\Delta \\omega_s$的方差为$\\sigma_s^2$，因此$\\Delta \\phi$的方差为 $$ \\sigma_{\\Delta \\phi}^2 = \\pi^2 f_0^2 \\frac{4\\gamma(r, R)^2\\omega_s^2\\sigma_s^2 t^4}{c^2R^2\\beta(r, R)^2} $$ 接下来我们使用蒙特卡洛模拟的方法来获得加入了相位抖动后的主副瓣比的变化。结果如下图所示\n图2.4：角速度抖动影响\r可以看到，当相位抖动方差$\\sigma_{\\Delta \\phi}^2 \\leq 3$时，主副瓣比与无徙动时的主副瓣比相近，而主副瓣比在方差为$4$左右时急剧下降。若令$\\sigma_{\\Delta \\phi}^2 \\leq 3$，则可解得$\\sigma_s^2 \\leq 7.7 \\times 10^{-4}$。根据$3\\sigma$原则，这意味着伺服系统转动时的角速度抖动应当在$2^{\\circ}\\text{/s}$左右\n3. 仿真结果 假设空间中三个点目标方位如下所示\n点目标编号 x y z 1 0 3 0 2 3 4 0 3 0 4 0 \u0026emsp;\u0026emsp;仿真得到回波信号如下所示\r图3.1：角速度抖动影响\r快时间维上作FFT可得\n图3.2：角速度抖动影响\r作距离徙动校正与成像后，可得如下结果\n图3.3：角速度抖动影响\r从仿真结果来看本系统已经完成了初步的成像工作，但从仿真结果可明显看出点目标成像结果发散，这是因为由于雷达的圆周轨道特性而导致的目标间的大距离徙动差，因此本项目的下一个重点内容应当是算法的改进与优化。\n","permalink":"https://bingsz.github.io/en/posts/cssar/","summary":"这一题目是摘自我的大学生创新训练项目，本文主要论证一下圆周外扫描的毫米波合成孔径雷达的可实现性。 1. 基本原理 基于圆周外扫描的毫米波合成孔径雷达（下文简称CSSAR（Circular Scan SAR）系统）的基本系统组成草图如下所示 图1.1：系统组成草图 主要组成部分有雷达，转动轴与转动轨道。","title":"基于圆周外扫描的毫米波合成孔径雷达"},{"content":" 卡尔曼滤波是基于贝叶斯滤波框架提出的一种基于高斯正态分布假设的线性滤波算法（这几个词将在后文进行介绍）。目前网络上的大部分关于卡尔曼滤波算法的讲解都没有从贝叶斯滤波框架出发推导，因此本文从贝叶斯滤波框架来推导卡尔曼滤波\n1. 贝叶斯滤波框架 贝叶斯滤波框架基于贝叶斯模型展开，贝叶斯模型主要包含目标状态值与观测值，并且存在如下所示的关系\n$$ \\begin{aligned} \\mathbf{x}_{k+1}=f(\\mathbf{x}_k)+\\mathbf{Q} \\\\ \\mathbf{z}_k=g(\\mathbf{x}_k)+\\mathbf{R} \\end{aligned} \\tag{1.1} $$\n其中$\\mathbf{x}_k$表示$k$时刻的目标状态向量，$f(\\cdot)$表示目标状态转移函数，描述了这一时刻与下一时刻目标状态的关系（从另一个角度来说，这一时刻的状态仅与上一时刻有关，因此贝叶斯滤波框架蕴含了一阶马尔可夫假设），$\\mathbf{Q}$为噪声向量；$\\mathbf{z}_k$表示$k$时刻的系统观测值，该值仅与当前目标状态有关（这意味着贝叶斯滤波框架蕴含了独立观测假设，即观测值仅与当前状态有关），$g(\\cdot)$表示目标状态$\\mathbf{x}_k$与观测值$\\mathbf{z}_k$之间的关系，$\\mathbf{R}$表示观测过程中引入的噪声向量。\n贝叶斯滤波的核心问题是求解$P(\\mathbf{x}_k|\\mathbf{z}_{1:k})$，表示已知$1$到$k$时刻的观测值$\\mathbf{z}_{1:k}$时，目标状态$\\mathbf{x}_k$的后验概率。当求解得到$P(\\mathbf{x}_k|\\mathbf{z}_{1:k})$后，在最小均方误差准则下（下文中均基于最小均方误差准则展开），当前状态$\\mathbf{x}_k$的估计可以通过求解上述概率的期望来得到，如下所示（为了方便，下文中所有的积分均指定积分，不表明积分限表示对整个区间积分）\n$$ \\hat{\\mathbf{x}}_k=\\int \\mathbf{x}_k P(\\mathbf{x}_k|\\mathbf{z}_{1:k}) \\mathrm{d}\\mathbf{x}_k $$\n为了求解得到上述概率函数，贝叶斯滤波主要包含两个步骤：预测步与更新步。预测步指的是根据当前所得的目标状态信息来预测下一时刻的目标状态信息，即求解$P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})$；更新步指的是根据观测结果来修正之前所预测的值，即求解$P(\\mathbf{x}_k|\\mathbf{z}_{1:k})$。通常而言，预测步的概率密度函数是通过柯莫哥洛夫公式来求解的，如下所示 $$ P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})=\\int P(\\mathbf{x}_k|\\mathbf{x}_{k-1})P(\\mathbf{x}_{k-1}|\\mathbf{z}_{1:k-1})\\mathrm{d}\\mathbf{x}_{k-1} $$ 其中$P(\\mathbf{x}_k|\\mathbf{x}_{k-1})$表示目标的状态转移概率，即在已知上一时刻的状态信息估计值基础上，当前时刻状态信息为$\\mathbf{x}_k$的概率；$P(\\mathbf{x}_{k-1}|\\mathbf{z}_{1:k-1})$表示上一个更新步的结果。更新步指的是利用观测信息来修正上述预测值，如下所示 $$ \\begin{aligned} P(\\mathbf{x}_k|\\mathbf{z}_{1:k})=\u0026amp;P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1}, \\mathbf{z}_k) \\\\ =\u0026amp; \\frac{P(\\mathbf{x}_k, \\mathbf{z}_k|\\mathbf{z}_{1:k-1})}{P(\\mathbf{z}_k|\\mathbf{z}_{1:k-1})} \\\\ =\u0026amp; \\frac{P(\\mathbf{x}_k, \\mathbf{z}_k|\\mathbf{z}_{1:k-1})}{P(\\mathbf{z}_k|\\mathbf{z}_{1:k-1})} \\\\ =\u0026amp; \\frac{P(\\mathbf{z}_k|\\mathbf{z}_{1:k-1}, \\mathbf{x}_k)P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})}{P(\\mathbf{z}_k|\\mathbf{z}_{1:k-1})} \\end{aligned} \\tag{1.2} $$ 需要注意的是，贝叶斯滤波基于独立观测假设而推导，独立观测假设指的是$k$时刻的观测值仅与$k$时刻的目标状态值有关。换言之，有下式成立 $$ P(\\mathbf{z}_k|\\mathbf{z}_{1:k-1}, \\mathbf{x}_k) = P(\\mathbf{z}_k|\\mathbf{x}_k) $$ 将上式代入到$(1.2)$式中，可以得到 $$ P(\\mathbf{x}_k|\\mathbf{z}_{1:k})=\\frac{P(\\mathbf{z}_k|\\mathbf{x}_k)P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})}{P(\\mathbf{z}_k|\\mathbf{z}_{1:k-1})} $$ 再来观察一下上式，$P(\\mathbf{z}_k|\\mathbf{z}_{1:k-1})$是一个常数，因为它仅与观测值有关，而观测值是人为无法改变的。这个常数的意义在于保持概率密度函数的正则性（即整个区间内积分为1）。$P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})$便是之前所求的预测步概率密度函数，预测步概率密度函数已经通过柯莫哥洛夫公式求解得到，仅与目标的状态转移概率与上一个更新步结果有关。$P(\\mathbf{z}_k|\\mathbf{x}_k)$表示的是已知当前目标状态为$\\mathbf{x}_k$时，观测到$\\mathbf{z}_k$的概率，这一概率可通过$(1.1)$式中的目标状态与观测值之间的关系得到。\n总结来说，贝叶斯滤波框架的步骤如下所示\n根据上一时刻的目标状态来得到这一时刻的预测值，即求解$P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})$。 根据当前时刻的观测值来修正当前时刻的预测值，即求解$P(\\mathbf{x}_k|\\mathbf{z}_{1:k})$。这一部分相当于加入了该状态的观测值这一新的信息。 一般而言，上述概率密度函数并不容易求解，当$(1.1)$式中的$f(\\cdot)$与$g(\\cdot)$均为线性函数，并且噪声符合高斯正态分布时，贝叶斯滤波的近似形式便是卡尔曼滤波。为了更好理解贝叶斯滤波框架，接下来以卡尔曼滤波为例，利用贝叶斯滤波框架来推导卡尔曼滤波的公式。\n2. 卡尔曼滤波原理 卡尔曼滤波是贝叶斯滤波的简化形式。当贝叶斯滤波中的$\\mathbf{Q}$与$\\mathbf{R}$均符合高斯正态分布，且$f(\\cdot)$与$g(\\cdot)$均为线性函数时，贝叶斯滤波便退化为了卡尔曼滤波。进一步地，$(1.1)$式化为如下形式 $$ \\begin{aligned} \\mathbf{x}_{k+1}=\\mathbf{F}\\mathbf{x}_k+\\mathbf{Q} \\\\ \\mathbf{z}_k = \\mathbf{H}\\mathbf{x}_k+\\mathbf{R} \\end{aligned} \\tag{2.1} $$ 其中$\\mathbf{F}$被称为状态转移矩阵，表示该时刻与下一时刻状态的关联，$\\mathbf{H}$被称为观测矩阵，表示观测值与状态值之间的联系。假设$\\mathbf{Q}$与$\\mathbf{R}$分别服从均值为$0$，协方差为$\\mathbf{P_Q}$与$\\mathbf{P_R}$的正态分布，$k$时刻的目标状态值$\\mathbf{x}_k$服从均值为最优估计值$\\hat{\\mathbf{x}}_k$、协方差为$\\mathbf{P}_{k-1}$的高斯正态分布。根据贝叶斯滤波框架的原理，首先需要计算预测步的概率密度函数，如下所示 $$ P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})=\\int P(\\mathbf{x}_k|\\mathbf{x}_{k-1})P(\\mathbf{x}_{k-1}|\\mathbf{z}_{1:k-1}) \\mathrm{d} \\mathbf{x}_{k-1} $$ 对于$P(\\mathbf{x}_k|\\mathbf{x}_{k-1})$，由$(2.1)$式中的状态转移方程，可以得到 $$ P(\\mathbf{x}_k|\\mathbf{x}_{k-1})=\\mathcal{N}(\\mathbf{x}_k; \\mathbf{F}\\mathbf{x}_{k-1}, \\mathbf{P_Q}) $$ 其中$N(\\mu, \\Sigma^2)$表示均值为$\\mu$，协方差为$\\Sigma^2$的高斯正态分布概率密度函数。根据假设可知$P(\\mathbf{x}_{k-1}|\\mathbf{z}_{1:k-1})$满足如下关系 $$ P(\\mathbf{x}_{k-1}|\\mathbf{z}_{1:k-1})=\\mathcal{N}(\\mathbf{x}_{k-1}; \\hat{\\mathbf{x}}_{k-1}, \\mathbf{P}_{k-1}) $$ 因此接下来需要重点求解的便是如下所示的一个积分 $$ \\begin{aligned} P(\\mathbf{x}_k | \\mathbf{z}_{1:k-1})=\u0026amp;\\int \\mathcal{N}(\\mathbf{F}\\mathbf{x}_{k-1}, \\mathbf{P_Q})\\mathcal{N}(\\hat{\\mathbf{x}}_{k-1}, \\mathbf{P}_{k-1}) \\mathrm{d} \\mathbf{x}_{k-1} \\\\ =\u0026amp; \\frac{1}{(2\\pi)^{D}}\\frac{1}{|\\mathbf{P_Q}|^{\\frac{1}{2}}|\\mathbf{P}_{k-1}|^{\\frac{1}{2}}} \\int \\exp(-\\frac{1}{2}(\\mathbf{x}_k-\\mathbf{F}\\mathbf{x}_{k-1})^T\\mathbf{P_Q^{-1}}(\\mathbf{x}_k-\\mathbf{F}\\mathbf{x}_{k-1})) \\\\ \u0026amp;\\exp(-\\frac{1}{2}(\\mathbf{x}_{k-1}-\\hat{\\mathbf{x}}_{k-1})^T\\mathbf{P}_{k-1}^{-1}(\\mathbf{x}_{k-1}-\\hat{\\mathbf{x}}_{k-1}))\\mathrm{d}\\mathbf{x}_{k-1} \\\\ \u0026amp; \\\\ \u0026amp; \\end{aligned} \\tag{2.2} $$ 上述积分的求解较为复杂，事实上，上述公式可以通过高斯变量的贝叶斯定理来求解，通过高斯变量的贝叶斯定理可以直接得到 $$ P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})=\\mathcal{N}(\\mathbf{x}_k; \\mathbf{F}\\mathbf{x}_{k-1}, \\mathbf{F}\\mathbf{P}_{k-1}\\mathbf{F}^T+\\mathbf{P_Q}) $$ 根据观测方程，可以得到 $$ P(\\mathbf{z}_k|\\mathbf{x}_k)=\\mathcal{N}(\\mathbf{z}_k; \\mathbf{H}\\mathbf{x}_k, \\mathbf{P_R}) $$ 代入到贝叶斯滤波框架的更新步公式中，可以得到 $$ P(\\mathbf{x}_k|\\mathbf{z}_{1:k})=C\\mathcal{N}(\\mathbf{x}_k; \\mathbf{F}\\mathbf{x}_{k-1}, \\mathbf{F}\\mathbf{P}_{k-1}\\mathbf{F}^T+\\mathbf{P_Q})\\mathcal{N}(\\mathbf{z}_k; \\mathbf{H}\\mathbf{x}_k, \\mathbf{P_R}) $$ 其中$C$为一个常数。根据“高斯分布的相乘原理”（这部分在第四节中），可以得到 $$ \\begin{aligned} P(\\mathbf{x}_k|\\mathbf{z}_{1:k})=\u0026amp;\\mathcal{N}(\\mathbf{x}_k; \\mathbf{F}\\mathbf{x}_{k-1}+\\mathbf{K}(\\mathbf{z}_k-\\mathbf{H}\\mathbf{F}\\mathbf{x}_{k-1}), \\mathbf{P}_{k-1}-\\mathbf{K}\\mathbf{H}\\mathbf{P}_{k-1}) \\\\ =\u0026amp; \\mathcal{N}(\\mathbf{x}_k; \\hat{\\mathbf{x}}_{k}+\\mathbf{K}(\\mathbf{z}_k-\\mathbf{H}\\hat{\\mathbf{x}}_{k}), \\mathbf{P}_{k-1}-\\mathbf{K}\\mathbf{H}\\mathbf{P}_{k-1}) \\end{aligned}\\tag{2.3} $$ 其中$\\mathbf{K}=\\mathbf{T}_{k}\\mathbf{H}^T(\\mathbf{H}\\mathbf{T}_{k}\\mathbf{H}^T+\\mathbf{P_R})^{-1}$，$\\mathbf{T}_k=\\mathbf{F}\\mathbf{P}_{k-1}\\mathbf{F}^T+\\mathbf{P_Q}$，$\\hat{\\mathbf{x}}_k=\\mathbf{F}\\mathbf{x}_{k-1}$。从$(2.3)$式中可以发现 $$ \\begin{aligned} \\mathbf{x}_{k}=\u0026amp;\\hat{\\mathbf{x}}_{k}+\\mathbf{K}(\\mathbf{z}_k-\\mathbf{H}\\hat{\\mathbf{x}}_{k}) \\\\ \\mathbf{P}_k =\u0026amp; \\mathbf{T}_{k}-\\mathbf{K}\\mathbf{H}\\mathbf{T}_{k} \\end{aligned} \\tag{2.4} $$ 这就得到了$k$时刻的目标状态估计值。\n再梳理一下推导过程：\n根据贝叶斯滤波框架，首先需要求解$P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})$，在卡尔曼滤波的推导过程中，求解出来为$P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})=\\mathcal{N}(\\mathbf{x}_k; \\mathbf{F}\\mathbf{x}_{k-1}, \\mathbf{F}\\mathbf{P}_{k-1}\\mathbf{F}^T+\\mathbf{P_Q})$。 随后，根据求解出来的$P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})$，来进一步求解$P(\\mathbf{x}_k|\\mathbf{z}_{1:k})$，在卡尔曼滤波的推导过程中，$P(\\mathbf{x}_k|\\mathbf{z}_{1:k})=\\mathcal{N}(\\mathbf{x}_k; \\hat{\\mathbf{x}}_{k}+\\mathbf{K}(\\mathbf{z}_k-\\mathbf{H}\\hat{\\mathbf{x}}_{k}), \\mathbf{P}_{k-1}-\\mathbf{K}\\mathbf{H}\\mathbf{P}_{k-1})$。 最后，根据某个准则来计算估计值。在卡尔曼滤波推导过程中，根据最小均方误差准则，选取的最优估计值$\\mathbf{x}_{k}$为概率密度函数的期望。 总结来说，卡尔曼滤波的滤波过程如下所示\n首先根据上一时刻的最优估计值$\\mathbf{x}_{k-1}$，计算出该时刻的预测值$\\hat{\\mathbf{x}}_{k}=\\mathbf{F}\\mathbf{x}_{k-1}$ 随后利用观测信息得到该时刻的最优估计值为$\\mathbf{x}_k=\\hat{\\mathbf{x}}_{k}+\\mathbf{K}(\\mathbf{z}_k-\\mathbf{H}\\hat{\\mathbf{x}}_{k})$ 最后，更新该时刻最优估计值的协方差$\\mathbf{P}_k$以供下一时刻的更新使用，$\\mathbf{P}_{k}=\\mathbf{P}_{k-1}-\\mathbf{K}\\mathbf{H}\\mathbf{P}_{k-1}$ 在许多的卡尔曼滤波推导过程中还引入了控制项$\\mathbf{u}_k$，这一项存在与否并不影响推导的最终结果，只是在实际应用中需要注意的是，当给予系统一个命令时，需要对应的在预测值上加上该命令对目标状态的影响。\n3. 卡尔曼滤波的一个例子 当利用卡尔曼滤波来估计小车的运动状态时，为了方便，假设小车作一维匀速直线运动，同时小车不受外部动力影响（即控制项$\\mathbf{u}_k$为$0$），那么小车的运动状态可以建模为 $$ \\mathbf{x}_k = \\begin{pmatrix} p_k \\\\ v_k \\end{pmatrix} $$ 小车的状态转移矩阵$\\mathbf{F}$为 $$ \\mathbf{F}=\\begin{pmatrix} 1 \u0026amp; \\Delta T \\\\ 0 \u0026amp; 1 \\end{pmatrix} $$ 其中$\\Delta T$表示传感器的采样周期。于是可以得到下一时刻的状态预测值为 $$ \\hat{\\mathbf{x}}_{k+1}=\\mathbf{F}\\mathbf{x}_k=\\begin{pmatrix} p_k+\\Delta T v_k \\\\ v_k \\end{pmatrix} $$ 假设传感器直接采样小车的位置与速度，那么观测矩阵$\\mathbf{H}$即是单位矩阵（可以看看$(2.1)$式，观测矩阵表示的是传感器采样的值与目标状态值之间的联系，并不是所有场景下传感器都是直接采样目标的状态值）。\n在上述公式中，$\\mathbf{P_Q}$表示的是外界不确定性，例如风力对小车状态的影响，路面不平整对小车状态的影响等等。总而言之，这个量可以根据小车的实际使用场景而被计算出来，此处视其为一个已知量。$\\mathbf{P_R}$也是同理的，这个量表示的是传感器误差，可以通过传感器本身的性能而被计算出来。$\\mathbf{P}_k$表示的是最优估计值的协方差，这个值可通过$\\mathbf{P}_{k-1}$而被计算出来，假设$0$时刻的$\\mathbf{P}_0=\\mathbf{P_Q}$。当得到$k+1$时刻的观测值时，便可以通过$(2.4)$式计算出$k+1$时刻的最优估计值与估计协方差。\n4. 推导过程中的一些细节问题 4.1. 高斯变量的贝叶斯定理 高斯变量的贝叶斯定理指的是，当 $$ \\begin{aligned} P(\\mathbf{y}|\\mathbf{x}) =\u0026amp; \\mathcal{N}(\\mathbf{y}; \\mathbf{A}\\mathbf{x}+\\mathbf{b}, \\Sigma_1) \\\\ P(\\mathbf{x}) =\u0026amp; \\mathcal{N}(\\mathbf{x}; \\mathbf{\\mu}, \\Sigma_2) \\end{aligned} $$ 有下式成立 $$ P(\\mathbf{y})=\\mathcal{N}(\\mathbf{y}; \\mathbf{A}\\mathbf{\\mu}+\\mathbf{b}, \\Sigma_1+\\mathbf{A}\\Sigma_2\\mathbf{A}^T) $$ 高斯变量的贝叶斯定理的推导略显繁琐，此处就不推导了。本节来尝试一下直接推导$P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})$。\n考虑$(2.2)$式的积分内的指数项，可以得到 $$ \\begin{aligned} \u0026amp;\\exp(-\\frac{1}{2}(\\mathbf{x}_k-\\mathbf{F}\\mathbf{x}_{k-1})^T\\mathbf{P_Q^{-1}}(\\mathbf{x}_k-\\mathbf{F}\\mathbf{x}_{k-1})) \\\\ =\u0026amp;\\exp(-\\frac{1}{2}(\\mathbf{x}_k^T\\mathbf{P_Q^{-1}}\\mathbf{x}_k-\\mathbf{x}_{k-1}^T\\mathbf{F}^T\\mathbf{P_Q^{-1}}\\mathbf{x}_k - \\mathbf{x}_k^T\\mathbf{P_Q^{-1}}\\mathbf{F}\\mathbf{x}_{k-1}+\\mathbf{x}_{k-1}^T\\mathbf{F}^T\\mathbf{P_Q^{-1}}\\mathbf{F}\\mathbf{x}_{k-1})) \\end{aligned}\\tag{4.1} $$ 注意到，由于$\\mathbf{P_Q}$为一个对称矩阵，因此$\\mathbf{P_Q^{-1}}$也是一个对称矩阵，从而有下式成立 $$ (\\mathbf{F}\\mathbf{x}_{k-1})^T\\mathbf{P_Q^{-1}}\\mathbf{x}_k=\\mathbf{x}_k^T\\mathbf{P_Q^{-1}}(\\mathbf{F}\\mathbf{x}_{k-1}) $$ 因此$(4.1)$式可以化简为 $$ \\begin{aligned} \u0026amp;\\exp(-\\frac{1}{2}(\\mathbf{x}_k-\\mathbf{F}\\mathbf{x}_{k-1})^T\\mathbf{P_Q^{-1}}(\\mathbf{x}_k-\\mathbf{F}\\mathbf{x}_{k-1})) \\\\ =\u0026amp;\\exp(-\\frac{1}{2}(\\mathbf{x}_k^T\\mathbf{P_Q^{-1}}\\mathbf{x}_k-2\\mathbf{x}_k^T\\mathbf{P_Q^{-1}}\\mathbf{F}\\mathbf{x}_{k-1}+\\mathbf{x}_{k-1}^T\\mathbf{F}^T\\mathbf{P_Q^{-1}}\\mathbf{F}\\mathbf{x}_{k-1})) \\end{aligned} \\tag{4.2} $$ 同理可以得到 $$ \\begin{aligned} \u0026amp;\\exp(-\\frac{1}{2}(\\mathbf{x}_{k-1}-\\hat{\\mathbf{x}}_{k-1})^T\\mathbf{P}_{k-1}^{-1}(\\mathbf{x}_{k-1}-\\hat{\\mathbf{x}}_{k-1})) \\\\ =\u0026amp; \\exp(-\\frac{1}{2}(\\mathbf{x}_{k-1}^T\\mathbf{P}_{k-1}^{-1}\\mathbf{x}_{k-1} - 2 \\hat{\\mathbf{x}}_{k-1}^T\\mathbf{P}_{k-1}^{-1}\\mathbf{x}_{k-1} + \\hat{\\mathbf{x}}_{k-1}^T\\mathbf{P}_{k-1}^{-1}\\hat{\\mathbf{x}}_{k-1})) \\end{aligned} \\tag{4.3} $$ 接下来的目标是求解$(2.2)$式中的积分部分，将$(4.2)$式与$(4.3)$式相乘积分并提出常数部分可以得到 $$ \\begin{aligned} LHS=\u0026amp;\\int \\exp(-\\frac{1}{2}(\\mathbf{x}_k^T\\mathbf{P_Q^{-1}}\\mathbf{x}_k-2\\mathbf{x}_k^T\\mathbf{P_Q^{-1}}\\mathbf{F}\\mathbf{x}_{k-1}+\\mathbf{x}_{k-1}^T\\mathbf{F}^T\\mathbf{P_Q^{-1}}\\mathbf{F}\\mathbf{x}_{k-1} \\\\ \u0026amp; \\qquad \\qquad \\qquad +\\mathbf{x}_{k-1}^T\\mathbf{P}_{k-1}^{-1}\\mathbf{x}_{k-1} - 2 \\hat{\\mathbf{x}}_{k-1}^T\\mathbf{P}_{k-1}^{-1}\\mathbf{x}_{k-1} + \\hat{\\mathbf{x}}_{k-1}^T\\mathbf{P}_{k-1}^{-1}\\hat{\\mathbf{x}}_{k-1})) \\mathrm{d}\\mathbf{x}_{k-1} \\\\ =\u0026amp; C \\int \\exp(-\\frac{1}{2}\\begin{pmatrix} \\mathbf{x}_k - \\mathbf{\\mu} \\\\ \\mathbf{x}_{k-1} - \\hat{\\mathbf{x}}_{k-1} \\end{pmatrix}^T \\begin{pmatrix} \\mathbf{P_Q^{-1}} \u0026amp; -\\mathbf{P_Q^{-1}}\\mathbf{F} \\\\ -\\mathbf{F}^T\\mathbf{P_Q}^{-1} \u0026amp; \\mathbf{P}_{k-1}^{-1}+\\mathbf{F}^T\\mathbf{P_Q^{-1}}\\mathbf{F} \\end{pmatrix} \\\\ \u0026amp; \\qquad \\qquad \\qquad \\qquad \\begin{pmatrix} \\mathbf{x}_k - \\mathbf{\\mu} \\\\ \\mathbf{x}_{k-1} - \\hat{\\mathbf{x}}_{k-1} \\end{pmatrix})\\mathrm{d}\\mathbf{x}_{k-1} \\end{aligned} \\tag{4.4} $$ 其中$\\mathbf{\\mu}$表示$\\mathbf{x}_{k}$的均值，是一个待定的系数。观察注意到，上式中积分号内相当于一个高维的高斯分布，当对$\\mathbf{x}_{k-1}$作整个区间的积分时，相当于得到了关于$\\mathbf{x}_{k}$的边缘分布，并且$\\mathbf{x}_{k}$同样服从高斯分布。当知道了这一点后，便可以对上述结果进行简化计算，只需要计算$\\mathbf{x}_k$的均值与方差即可得到$P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})$。由上式可知$\\mathbf{x}_k$与$\\mathbf{x}_{k-1}$的协方差为 $$ \\mathrm{Cov}(\\mathbf{x}_k, \\mathbf{x}_{k-1})=\\begin{pmatrix} \\mathbf{P_Q^{-1}} \u0026amp; -\\mathbf{P_Q^{-1}}\\mathbf{F} \\\\ -\\mathbf{F}^T\\mathbf{P_Q}^{-1} \u0026amp; \\mathbf{P}_{k-1}^{-1}+\\mathbf{F}^T\\mathbf{P_Q^{-1}}\\mathbf{F} \\end{pmatrix}^{-1} $$ 当已知分块矩阵为（$\\mathbf{A}$，$\\mathbf{B}$，$\\mathbf{C}$，$\\mathbf{D}$均为$m\\times m$型） $$ \\mathbf{P}=\\begin{pmatrix} \\mathbf{A} \u0026amp; \\mathbf{B} \\\\ \\mathbf{C} \u0026amp; \\mathbf{D} \\end{pmatrix} $$ $\\mathbf{P}$的逆矩阵可表示为 $$ \\mathbf{P}^{-1}=\\begin{pmatrix} \\mathbf{I} \u0026amp; -\\mathbf{A}^{-1}\\mathbf{B} \\\\ 0 \u0026amp; \\mathbf{I} \\end{pmatrix} \\begin{pmatrix} \\mathbf{A}^{-1} \u0026amp; 0 \\\\ 0 \u0026amp; (\\mathbf{D}-\\mathbf{C}\\mathbf{A}^{-1}\\mathbf{B})^{-1} \\end{pmatrix} \\begin{pmatrix} \\mathbf{I} \u0026amp; 0 \\\\ -\\mathbf{C}\\mathbf{A}^{-1} \u0026amp; 0 \\end{pmatrix} $$ 于是有 $$ \\begin{aligned} \\mathrm{Cov}(\\mathbf{x}_{k}, \\mathbf{x}_{k-1})=\u0026amp;\\begin{pmatrix} \\mathbf{I} \u0026amp; \\mathbf{F} \\\\ \\mathbf{0} \u0026amp; \\mathbf{I} \\end{pmatrix} \\begin{pmatrix} \\mathbf{P_Q} \u0026amp; \\mathbf{0} \\\\ \\mathbf{0} \u0026amp; \\mathbf{P}_{k-1} \\end{pmatrix} \\begin{pmatrix} \\mathbf{I} \u0026amp; \\mathbf{0} \\\\ \\mathbf{F}^T \u0026amp; \\mathbf{I} \\end{pmatrix} \\\\ =\u0026amp; \\begin{pmatrix} \\mathbf{P_Q}+\\mathbf{F}\\mathbf{P}_{k-1}\\mathbf{F}^T \u0026amp; \\mathbf{F}\\mathbf{P}_{k-1} \\\\ \\mathbf{P}_{k-1}\\mathbf{F}^T \u0026amp; \\mathbf{P}_{k-1} \\end{pmatrix} \\end{aligned} $$ 因此$\\mathbf{x}_{k}$的方差为$\\mathbf{P_Q}+\\mathbf{F}\\mathbf{P}_{k-1}\\mathbf{F}^T$。$(4.4)$式中进一步比较系数可得$\\mathbf{\\mu}=\\mathbf{F}\\mathbf{x}_{k-1}$，因此可以得到 $$ P(\\mathbf{x}_k | \\mathbf{z}_{1:k-1})=\\mathcal{N}(\\mathbf{x}_{k}; \\mathbf{F}\\mathbf{x}_{k-1}, \\mathbf{P_Q}+\\mathbf{F}\\mathbf{P}_{k-1}\\mathbf{F}^T) $$\n4.2. 高斯分布的相乘原理 在$(2.3)$式的推导中用到了一个所谓“高斯分布的相乘原理”的性质，事实上这个性质并不是指两个高斯分布相乘可以得到一个新的同维高斯分布，而是指当不考虑常数项时，两个高斯分布相乘后，指数项上依然符合一个高斯分布的形式。记有如下两个高斯分布 $$ \\begin{aligned} \\mathcal{N}(\\mathbf{x}; \\mu_1, \\Sigma_1) \\\\ \\mathcal{N}(\\mathbf{x}; \\mu_2, \\Sigma_2) \\end{aligned} $$ 两者相乘后取指数项，忽略常数项可得 $$ \\begin{aligned} \\ln L =\u0026amp; -\\frac{1}{2}((\\mathbf{x}^T-\\mu_1)^T\\Sigma_1^{-1}(\\mathbf{x}^T-\\mu_1)+(\\mathbf{x}^T-\\mu_2)^T\\Sigma_2^{-1}(\\mathbf{x}^T-\\mu_2)) \\\\ =\u0026amp; -\\frac{1}{2}(\\mathbf{x}-\\mu)^T(\\Sigma_1^{-1}+\\Sigma_2^{-1})(\\mathbf{x}-\\mu) \\end{aligned} $$ 比较系数后，有下式成立 $$ \\begin{aligned} \\mu =\u0026amp; (\\Sigma_1^{-1}+\\Sigma_2^{-1})^{-1}(\\Sigma_1^{-1}\\mu_1 + \\Sigma_2^{-1}\\mu_2) \\\\ =\u0026amp; \\Sigma_1(\\Sigma_1+\\Sigma_2)^{-1}\\Sigma_2(\\Sigma_1^{-1}\\mu_1 + \\Sigma_2^{-1}\\mu_2) \\\\ =\u0026amp; \\Sigma_1(\\Sigma_1+\\Sigma_2)^{-1}\\Sigma_2\\Sigma_1^{-1}\\mu_1 + \\Sigma_1(\\Sigma_1+\\Sigma_2)^{-1}\\mu_2 \\end{aligned} $$ 为了方便，记$\\mathbf{K}=\\Sigma_1(\\Sigma_1+\\Sigma_2)^{-1}$，于是有 $$ \\begin{aligned} \\mu = \\mathbf{K}\\Sigma_2\\Sigma_1^{-1}\\mu_1+\\mathbf{K}\\mu_2 \\end{aligned} $$ 注意到 $$ \\begin{aligned} \\mathbf{K}\\Sigma_2\\Sigma_1^{-1}=\u0026amp;\\Sigma_1(\\Sigma_1+\\Sigma_2)^{-1}\\Sigma_2\\Sigma_1^{-1} \\\\ =\u0026amp; (\\Sigma_1\\Sigma_2^{-1}(\\Sigma_1+\\Sigma_2)\\Sigma_1^{-1})^{-1} \\\\ =\u0026amp; (\\Sigma_1\\Sigma_2^{-1}+\\mathbf{I})^{-1} \\\\ =\u0026amp; \\Sigma_2(\\Sigma_1+\\Sigma_2)^{-1} \\\\ =\u0026amp; \\mathbf{I} - \\mathbf{K} \\end{aligned} $$ 因此 $$ \\begin{aligned} \\mu =\u0026amp; \\mathbf{K}\\Sigma_2\\Sigma_1^{-1}\\mu_1+\\mathbf{K}\\mu_2 \\\\ =\u0026amp; (\\mathbf{I}-\\mathbf{K})\\mu_1+\\mathbf{K}\\mu_2 \\\\ =\u0026amp; \\mu_1 + \\mathbf{K}(\\mu_2-\\mu_1) \\end{aligned} \\tag{4.5} $$ 对于相乘后方差$\\Sigma$而言，有 $$ \\begin{aligned} \\Sigma(\\mathbf{x})=\u0026amp;(\\Sigma_1^{-1}+\\Sigma_2^{-1})^{-1}=\\Sigma_2(\\Sigma_1+\\Sigma_2)^{-1}\\Sigma_1 \\\\ =\u0026amp; (\\mathbf{I}-\\mathbf{K})\\Sigma_1=\\Sigma_1 - \\mathbf{K}\\Sigma_1 \\end{aligned} \\tag{4.6} $$\n为了计算$P(\\mathbf{x}_k|\\mathbf{z}_{1:k})$，需要计算 $$ P(\\mathbf{x}_k|\\mathbf{z}_{1:k})=\\frac{P(\\mathbf{z}_k|\\mathbf{x}_k)P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})}{P(\\mathbf{z}_k|\\mathbf{z}_{1:k-1})} $$ 根据前述的推导结果可知，$P(\\mathbf{z}_k|\\mathbf{x}_k)$与$P(\\mathbf{x}_k|\\mathbf{z}_{1:k-1})$均为高斯正态分布，两者相乘后指数项上仍然符合高斯分布的形式，而$P(\\mathbf{z}_k|\\mathbf{z}_{1:k-1})$作为一个常数项，只起到正则的作用。因此在计算$P(\\mathbf{x}_k|\\mathbf{z}_{1:k})$过程中，只需要计算指数项上的内容即可。于是有（忽略常数项） $$ \\begin{aligned} \\ln P(\\mathbf{x}_k|\\mathbf{z}_{1:k})=\u0026amp; -\\frac{1}{2}((\\mathbf{x}_{k}-\\mathbf{F}\\mathbf{x}_{k-1})^T(\\mathbf{F}\\mathbf{P}_{k-1}\\mathbf{F}^T+\\mathbf{P_Q})^{-1}(\\mathbf{x}_{k}-\\mathbf{F}\\mathbf{x}_{k-1}) \\\\ \u0026amp; \\qquad \\qquad +(\\mathbf{z}_{k}-\\mathbf{H}\\mathbf{x}_k)^T\\mathbf{P_R}^{-1}(\\mathbf{z}_{k}-\\mathbf{H}\\mathbf{x}_k)) \\end{aligned} $$ 为了得到与卡尔曼滤波相同的形式，作一个变量代换$\\mathbf{x}_k \\rightarrow \\mathbf{z}_{k}$，于是有（为了区分，将$\\mathbf{x}_k$所对应的观测值记为$\\hat{\\mathbf{z}}_k$，并且有$\\hat{\\mathbf{z}}_k=\\mathbf{H}\\mathbf{x}_k$） $$ \\begin{aligned} \\ln P(\\hat{\\mathbf{z}}_k|\\mathbf{z}_{1:k})=\u0026amp; -\\frac{1}{2}((\\hat{\\mathbf{z}}_{k}-\\mathbf{H}\\mathbf{F}\\mathbf{x}_{k-1})^T{\\mathbf{H}^T}^{-1}(\\mathbf{F}\\mathbf{P}_{k-1}\\mathbf{F}^T+\\mathbf{P_Q})^{-1}\\mathbf{H}^{-1}(\\hat{\\mathbf{z}}_{k}-\\mathbf{H}\\mathbf{F}\\mathbf{x}_{k-1}) \\\\ \u0026amp; \\qquad \\qquad +(\\hat{\\mathbf{z}}_{k}-\\mathbf{z}_k)^T\\mathbf{P_R}^{-1}(\\hat{\\mathbf{z}}_{k}-\\mathbf{z}_k)) \\end{aligned} $$\n将下式代入到$(4.5)$与$(4.6)$式 $$ \\begin{aligned} \\mu_1 =\u0026amp; \\mathbf{H}\\mathbf{F}\\mathbf{x}_{k-1} \\\\ \\mu_2 =\u0026amp; \\mathbf{z}_k \\\\ \\Sigma_1 =\u0026amp; \\mathbf{H}(\\mathbf{F}\\mathbf{P}_{k-1}\\mathbf{F}^T+\\mathbf{P_Q})\\mathbf{H}^T \\\\ \\Sigma_2 =\u0026amp; \\mathbf{P_R} \\end{aligned} $$ 得到（令$\\mathbf{T}_k=\\mathbf{F}\\mathbf{P}_{k-1}\\mathbf{F}^T+\\mathbf{P_Q}$） $$ \\begin{aligned} \\mathbf{K} =\u0026amp; \\mathbf{H}\\mathbf{T}_k\\mathbf{H}^T(\\mathbf{H}\\mathbf{T}_k\\mathbf{H}^T+\\mathbf{P_R})^{-1} \\\\ \\mu =\u0026amp; \\mathbf{H}\\mathbf{F}\\mathbf{x}_{k-1}+\\mathbf{K}(\\mathbf{z}_k-\\mathbf{H}\\mathbf{F}\\mathbf{x}_{k-1}) \\\\ \\Sigma =\u0026amp; \\mathbf{H}\\mathbf{T}_k\\mathbf{H}^T-\\mathbf{K}\\mathbf{H}\\mathbf{T}_k\\mathbf{H}^T \\end{aligned} $$ 再将$\\mathbf{z}_{k} \\rightarrow \\mathbf{x}_k$变换回来，便可得到 $$ \\begin{aligned} \\mathbf{K} =\u0026amp; \\mathbf{T}_k\\mathbf{H}^T(\\mathbf{H}\\mathbf{T}_k\\mathbf{H}^T+\\mathbf{P_R})^{-1} \\\\ \\mu =\u0026amp; \\mathbf{F}\\mathbf{x}_{k-1}+\\mathbf{K}(\\mathbf{z}_k-\\mathbf{H}\\mathbf{F}\\mathbf{x}_{k-1}) \\\\ \\Sigma =\u0026amp; \\mathbf{T}_k-\\mathbf{K}\\mathbf{H}\\mathbf{T}_k \\end{aligned} $$ 这就完成了$(2.3)$式的推导。\n4.3. 最小均方误差准则 在第一节中指出，基于最小均方误差准则前提下，已知$P(\\mathbf{x}_k|\\mathbf{z}_{1:k})$时，$\\mathbf{x}_k$的最优估计是其期望值。\n记$\\epsilon(\\hat{\\mathbf{x}}_k)$表示$\\mathbf{x}_k$的估计误差（$\\hat{\\mathbf{x}}_k$为估计值，$\\mathbf{x}_k$为真实值），最小均方误差准则指的是最小化如下所示的公式 $$ \\begin{aligned} \\arg \\min _{\\mathbf{x}_k} \\epsilon(\\hat{\\mathbf{x}}_k) =\u0026amp; \\arg \\min _{\\mathbf{x}_k} \\int (\\hat{\\mathbf{x}}_k-\\mathbf{x}_k)^T(\\hat{\\mathbf{x}}_k-\\mathbf{x}_k) P(\\mathbf{x}_k | \\mathbf{z}_{1:k}) \\mathrm{d}\\mathbf{x}_k \\\\ \\end{aligned} $$ 记$\\mathbf{F}(\\hat{\\mathbf{x}}_k)=\\int (\\hat{\\mathbf{x}}_k-\\mathbf{x}_k)^T(\\hat{\\mathbf{x}}_k-\\mathbf{x}_k) P(\\mathbf{x}_k | \\mathbf{z}_{1:k}) \\mathrm{d}\\mathbf{x}_k$，于是有 $$ \\begin{aligned} \\mathbf{F}(\\hat{\\mathbf{x}}_k)=\u0026amp;\\int (\\hat{\\mathbf{x}}_k-\\mathbf{x}_k)^T(\\hat{\\mathbf{x}}_k-\\mathbf{x}_k) P(\\mathbf{x}_k | \\mathbf{z}_{1:k}) \\mathrm{d}\\mathbf{x}_k \\\\ =\u0026amp; \\int \\hat{\\mathbf{x}}_k^T \\hat{\\mathbf{x}}_k P(\\mathbf{x}_k | \\mathbf{z}_{1:k}) - 2\\mathbf{x}_k^T\\hat{\\mathbf{x}}_kP(\\mathbf{x}_k | \\mathbf{z}_{1:k}) + \\mathbf{x}_k^T \\mathbf{x}_k P(\\mathbf{x}_k | \\mathbf{z}_{1:k})\\mathrm{d}\\mathbf{x}_k \\\\ =\u0026amp; \\hat{\\mathbf{x}}_k^T \\hat{\\mathbf{x}}_k\\\\ \u0026amp; - \\int 2\\mathbf{x}_k^T\\hat{\\mathbf{x}}_kP(\\mathbf{x}_k | \\mathbf{z}_{1:k})\\mathrm{d}\\mathbf{x}_k \\\\ \u0026amp; + \\int \\mathbf{x}_k^T \\mathbf{x}_k P(\\mathbf{x}_k | \\mathbf{z}_{1:k})\\mathrm{d}\\mathbf{x}_k \\end{aligned} $$ 注意到第三个积分号为一个常数，对$\\hat{\\mathbf{x}}_k$求导可得 $$ \\frac{\\partial \\mathbf{F}(\\hat{\\mathbf{x}}_k)}{\\partial \\hat{\\mathbf{x}}_k} = 2\\hat{\\mathbf{x}}_k - 2\\int \\mathbf{x}_kP(\\mathbf{x}_k | \\mathbf{z}_{1:k})\\mathrm{d}\\mathbf{x}_k = 0 $$ 解得$\\hat{\\mathbf{x}}_k = \\int \\mathbf{x}_kP(\\mathbf{x}_k | \\mathbf{z}_{1:k})\\mathrm{d}\\mathbf{x}_k$，即为其期望值。\n","permalink":"https://bingsz.github.io/en/posts/frombayestokalman/","summary":"卡尔曼滤波是基于贝叶斯滤波框架提出的一种基于高斯正态分布假设的线性滤波算法（这几个词将在后文进行介绍）。目前网络上的大部分关于卡尔曼滤波算法的讲解都没有从贝叶斯滤波框架出发推导，因此本文从贝叶斯滤波框架来推导卡尔曼滤波 1. 贝叶斯滤波框架 贝叶斯滤波框架基于贝叶斯模型展开，贝叶斯模型主","title":"从贝叶斯滤波框架到卡尔曼滤波"},{"content":" 分布式全相参雷达论文阅读笔记（二）。主要内容有：基于互相关方法的时延对齐方法，基于互累积量方法的时延对齐方法，基于CFAR统计量的融合方法，基于噪声子空间投影的杂波抑制方法与基于张量的融合检测方法。\n1. 互相关时延对齐补偿方法 1.1. 基本原理 对于独立同分布的噪声，其互相关量可近似为0，而对于待对齐的量（如雷达接收信号或强干扰信号），在对齐时互相关量取值较大，不对齐时互相关量取值较小。基于这一基本原理，互相关时延对齐补偿方法通过寻找两个信号的最大互相关所在位置来确定对齐时延。需要注意的是，对于雷达接收信号，互相关时延对齐补偿法通常不能取得较好的效果，这是因为虽然独立同分布噪声的互相关量可近似为0，但并不为0，因此当噪声功率过大时，噪声的互相关量便会淹没信号。而这对于一整段接收信号来说是非常常见的，因为目标回波信号通常只占据整个接收时间段的一小部分。\n更详细地说，记两个雷达站接收到的信号如下所示\n$$ \\begin{equation} \\begin{aligned} s_0(t) = u(t)\\exp(2\\pi f_0 t) + n_0(t) \\\\ s_1(t) = u(t - \\tau)\\exp(2\\pi f_0 (t - \\tau)) + n_1(t) \\end{aligned} \\end{equation} $$\n其中$n_0(t)$，$n_1(t)$为两个雷达站接收到的不同噪声，$u(t)$为雷达信号包络，$f_0$为雷达发射的载频。当对两者作互相关运算时\n$$ \\begin{equation} \\begin{aligned} s_0(t) * s_1(t) =\u0026amp; (u(t)\\exp(2\\pi f_0 t) + n_0(t)) * (u(t - \\tau)\\exp(2\\pi f_0 (t - \\tau)) + n_1(t)) \\\\ =\u0026amp; (u(t)\\exp(2\\pi f_0 t)) * (u(t - \\tau)\\exp(2\\pi f_0 (t - \\tau))) \\\\ \u0026amp;+ u(t)\\exp(2\\pi f_0 t) * n_1(t) \\\\ \u0026amp;+ n_0(t) * u(t - \\tau)\\exp(2\\pi f_0 (t - \\tau)) \\\\ \u0026amp;+ n_0(t)*n_1(t) \\end{aligned} \\end{equation} $$\n其中$*$表示互相关运算。易知有如下关系成立\n$$ \\begin{equation} \\begin{cases} u(t)\\exp(2\\pi f_0 t) * n_1(t) = 0 \\\\ n_0(t) * u(t - \\tau)\\exp(2\\pi f_0 (t - \\tau)) = 0 \\ n_0(t) * n_1(t)=0 \\end{cases} \\end{equation} $$\n将上述关系式代入(2)式中，可以得到\n$$ \\begin{equation} \\begin{aligned} s_0(t) * s_1(t) =\u0026amp; (u(t)\\exp(2\\pi f_0 t)) * (u(t - \\tau)\\exp(2\\pi f_0 (t - \\tau))) \\ \\approx \u0026amp; \\delta(t - \\tau) \\end{aligned} \\end{equation} $$\n其中$\\delta(t)$表示冲激函数。上式意味着，将两段雷达回波接收信号作互相关，随后将最大值所在处作为时延补偿量是可行的。但是实际上，利用互相关量来直接对齐回波信号是非常困难的，因为(2.3)式只是一个近似值，实际上(2.3)式的三个式子并不完全等于0，当噪声互相关的功率充分大时，便会淹没信号。\n例如令接收信号的向量为$\\mathbf{x}$，其中仅在某几个距离门内有信号，而在其余距离门中均被噪声充斥。那么作互相关时，便会有大量的噪声进入到互相关运算中，从而导致真实回波信号被淹没。假设两个雷达接收到的回波信号信噪比为20dB，如图2-1所示\n图1.1：两部雷达接收回波信号\r对这两个雷达回波信号作互相关时，得到如图2-2所示结果，可以发现回波信号的互相关结果已经被淹没在了噪声中。这是因为在现实世界中，只能有限采样信号点数，这导致两个噪声作互相关时，并不严格为0。当这部分功率高于信号作互相关后的功率时，便会将信号部分淹没。\n图1.2：互相关结果\r如果待对齐的信号在整段接收信号中均存在，并且功率充分大（此处的功率充分大指的是作互相关后，不被噪声淹没即可），那么就可以使用互相关方法来进行时延对齐补偿。典型的一个应用场景是压制式干扰信号的对齐。由于压制式干扰信号通常具有较高的功率，并且在整段接收信号上均存在，因此可以使用上述互相关方法来进行对齐。\n那么有没有方法对接收信号作互相关对齐呢？答案是肯定的。既然对整段信号作互相关时，会导致大量的噪声泄漏出来，那么不妨将整段信号进行分段处理。通过将整段雷达接收信号划分为若干段，随后对对应段作互相关处理，可以有效的抑制噪声。但随之便会导致另一个问题，那就是划分为若干段时，接收信号需要恰好在某一段中，这样才能通过互相关方法来进行对齐。这个问题的一个解决方法便是可以使用不同方法来进行分段，从而降低信号落入不同段的概率。\n记雷达站$i$的接收信号为$\\mathbf{x}_i$，如下所示\n$$ \\begin{equation} \\mathbf{x}_i= \\begin{pmatrix} x_{i,1} \\\\ x_{i,2} \\\\ \u0026hellip; \\\\ x_{i,N} \\end{pmatrix} \\end{equation} $$\n将各个雷达接收信号$\\mathbf{x}_i$划分为若干段$\\mathbf{x}_{i,1}, \\mathbf{x}_{i,2}, \u0026hellip;, \\mathbf{x}_{i,M}$，其中$M=\\lfloor \\frac{N}{K} \\rfloor$，$K$为每一段信号的长度。$\\mathbf{x}_{i,j}$如下所示\n$$ \\begin{equation} \\mathbf{x}_{i,j} = \\begin{pmatrix} x_{i,(j-1)K+1} \\\\ x_{i,(j-1)K+2} \\\\ \u0026hellip; \\\\ x_{i,(j-1)K+K} \\end{pmatrix} \\end{equation} $$\n随后将两个分段后的雷达站接收信号$\\mathbf{x}_{i,j}$对应作互相关运算，得到$\\mathbf{y}_{i, k}^{(j)}$如下所示。\n$$ \\begin{equation} \\mathbf{y}_{i, k}^{(j)} = \\mathbf{x}_{i, j} * \\mathbf{x}_{k, j} \\end{equation} $$\n最后将$\\mathbf{y}_{i, k}^{(k)}$合并为一整段$\\mathbf{y}$，并通过分析$\\mathbf{y}_{i, k}$（如下所示）的最大值所在处便可将雷达站$i$与雷达站$k$进行时延对齐。\n$$ \\begin{equation} \\mathbf{y}_{i, k} = \\begin{pmatrix} \\mathbf{y}_{i, k}^{(1)} \\\\ \\mathbf{y}_{i, k}^{(2)} \\\\ \u0026hellip; \\\\ \\mathbf{y}_{i, k}^{(M)} \\end{pmatrix} \\end{equation} $$\n记$\\mathbf{y}_{i, k}$的最大值所在距离门号为$m$，那么所需的时延补偿量$\\Delta$如下所示\n$$ \\begin{equation} \\Delta = m \\mod K - \\frac{K}{2} \\end{equation} $$\n1.2. 代码与仿真分析 互相关时延对齐方法对于压制式的干扰信号具有较好的对齐效果，接下来首先对压制式干扰信号进行对齐仿真分析。仿真代码如下所示\nnumADC = 500; % 采样点数 Delta = 100; % 干扰信号到达两雷达站的时延差 JNR = 10; % 干噪比 j = wgn(1, numADC, JNR); % 生成干扰信号 x1 = wgn(1, numADC, 0) + [zeros(1, 100), j(1:end - 100)]; % 叠加干扰信号 x2 = wgn(1, numADC, 0) + j; figure; % 绘制出两段接收信号 subplot(2, 1, 1); plot(x1, \u0026#39;linewidth\u0026#39;, 2); xlabel(\u0026#39;距离门\u0026#39;, \u0026#39;fontsize\u0026#39;, 12.6); ylabel(\u0026#39;幅度\u0026#39;, \u0026#39;fontsize\u0026#39;, 12.6); subplot(2, 1, 2); plot(x2, \u0026#39;linewidth\u0026#39;, 2); xlabel(\u0026#39;距离门\u0026#39;, \u0026#39;fontsize\u0026#39;, 12.6); ylabel(\u0026#39;幅度\u0026#39;, \u0026#39;fontsize\u0026#39;, 12.6); y = ifft(fft(x1) .* conj(fft(x2))); % 作互相关操作 figure; % 绘制出互相关结果 plot(y, \u0026#39;linewidth\u0026#39;, 2); xlabel(\u0026#39;互相关平移\u0026#39;, \u0026#39;fontsize\u0026#39;, 12.6); ylabel(\u0026#39;幅度\u0026#39;, \u0026#39;fontsize\u0026#39;, 12.6); 相关的仿真参数如下所示\n描述 参数 采样点数 500 干噪比（单位：dB） 0, 10, 20, 30 干扰信号时延差（单位：采样点数） 100 通过改变代码部分的JNR变量可得到不同干噪比下的仿真结果，不同干噪比下的仿真结果如下所示（已作了归一化）\n图1.3：仿真结果\r从上图可以发现，干噪比越大，时延对齐的仿真效果越好，并且这几种情况均得到了正确的时延参数。这是因为干噪比越大，干扰在整个接收信号中的分量便越大，当作互相关运算时，相当于作了一次匹配滤波，从而在干扰信号时延差的地方取到最大值，因此可以得到两个雷达站的干扰信号时延差。\n对于回波信号对齐的代码如下所示，下述代码首先对接收信号进行分段处理，随后对相应段作互相关处理，并把互相关处理保存在变量y中，最后通过(9)式便可计算出所需补偿的时延数。\nN = 500; % 采样点数 K = 20; % 分段长度 SNR = 20; % 信噪比 x1 = zeros(1, N); x2 = zeros(1, N); x1(257) = 1; % 添加回波信号 x2(245) = 1; x1 = awgn(complex(x1), SNR); % 添加噪声 x2 = awgn(complex(x2), SNR); y = zeros(1, N); for i = 1 : N/K ind = (i-1)*K+1 : i*K; % 获得分段 y(ind) = fftshift(ifft(fft(x1(ind)) .* conj(fft(x2(ind))))); % 作互相关 end [~, maxind] = max(abs(y)); delta = mod(maxind, K) - 1 - K/2; % 减一是因为Matlab中从1开始计数 disp(delta); figure; plot(abs(y), \u0026#39;lineWidth\u0026#39;, 2); xlabel(\u0026#39;互相关平移\u0026#39;, \u0026#39;fontsize\u0026#39;, 12.6); ylabel(\u0026#39;幅度\u0026#39;, \u0026#39;fontsize\u0026#39;, 12.6); xlim([0, 500]); 通过改变代码中的SNR变量，便可得到不同信噪比条件下的仿真结果，不同信噪比下的仿真结果如图1.4所示（已作了归一化）\n相关仿真参数如下所示\n描述 参数 采样点数 500 分段长度 20 信噪比（单位：dB） 5, 10, 15, 20 回波信号时延差（单位：采样点数） 8 图1.4：仿真结果（信噪比分别为5dB, 10dB, 15dB, 20dB）\r从图1.4可以发现，当分段长度为20，信噪比为15dB左右时，互相关时延对齐方法才能得到较好的效果。这意味着互相关时延对齐方法只有在高信噪比条件下才能良好地工作。\n从上述对于互相关方法的分析中可以看到，互相关方法需要事先确定分段长度，如果分段长度选取不当，导致目标回波信号在两个雷达站中落入不同分段内，那么就无法获得对应的时延差了。基于这个问题，互累积量方法能够对此进行一定的改善。互累积量方法不需要事先对回波信号进行分段处理，而只需要知道最大时延差即可。这部分内容将在下一小节详细讲解。\n2. 互累积量对齐方法 2.1. 基本原理 互累积量对齐方法更多应用在雷达的回波信号对齐上，相较于互相关方法，互累积量方法不需要考虑分段大小。但是缺点便是在低信噪比时对齐结果不够稳定，并且相较于互相关方法，对信噪比要求更高。\n对于两个向量$\\mathbf{a}$，$\\mathbf{b}$，他们的三阶互累积量如下定义\n$$ \\begin{equation} \\begin{aligned} C_{111}(\\alpha, \\beta) = \\sum_i a_{i}^{*}a_{i+\\alpha}a_{i+\\beta} \\\\ C_{121}(\\alpha, \\beta) = \\sum_i a_{i}^{*}b_{i+\\alpha}a_{i+\\beta} \\end{aligned} \\end{equation} $$\n独立噪声的三阶互累积量为0，而回波信号的三阶互累积量通常取一个较大的值，通过这种差别可以对接收信号进行时延对齐。假设有两个雷达站，并且雷达站$i$的接收信号经过采样后得到的序列为$r_i(n)$，从理想化角度考虑，雷达站2的信号可如下表示\n$$ \\begin{equation} r_2(n) = Ar_1(n - n_0) \\end{equation} $$\n其中$n_0$表示两雷达站的时延差，$A$表示两雷达站回波信号之间的振幅之比。事实上，$n_0$取值通常可以被限定在某个范围内，因为两雷达站之间的时延差可以通过一些粗略的估计手段来估计而得。不妨假设$n_0$的取值范围为$[-D_0, D_0]$。那么雷达站2的回波信号可表示为（不考虑噪声，这是因为不同雷达站之间的噪声不相关，因此可不考虑）\n$$ \\begin{equation} r_{2}(n) = \\sum_{k=-D_{0}}^{D_{0}}\\alpha(k)r_{1}(n-k) \\end{equation} $$\n其中$\\alpha(k)$如下定义\n$$ \\begin{equation} \\alpha(k) = \\begin{cases} 0 \u0026amp; k \\neq n_0 \\\\ A \u0026amp; k = n_0 \\end{cases} \\end{equation} $$\n将(8)式代入$C_{121}(\\alpha,\\beta)$表达式中，可得到\n$$ \\begin{equation} \\begin{aligned} C_{121}(\\alpha, \\beta) =\u0026amp; \\sum_i r_{1}(i)^*r_{2}(i+\\alpha)r_{1}(i+\\beta) \\\\ =\u0026amp; \\sum_{k=-D_{0}}^{D_{0}} \\sum_i \\alpha(k) r_{1}(i)^*r_{1}(i+\\alpha-k)r_{1}(i+\\beta) \\\\ =\u0026amp; \\sum_{k=-D_{0}}^{D_{0}} \\alpha(k) C_{111}(\\alpha-k, \\beta) \\end{aligned} \\end{equation} $$\n如果可以得到$\\alpha(k)$的值，那么便可以得到雷达站2接收到的回波与雷达站1接收到的回波之间的时延差，因为$\\alpha(k)$最大值所在序号便是两者的时延差。记$\\mathbf{V}$如下所示\n$$ \\begin{equation} \\mathbf{V}= \\begin{pmatrix} C_{121}(-D_{0}, -D_{0}) \\\\ C_{121}(-D_{0}, -D_{0}+1) \\\\ \u0026hellip; \\\\ C_{121}(-D_{0}, D_{0}) \\\\ C_{121}(-D_{0}+1, -D_{0}) \\\\ \u0026hellip; \\\\ C_{121}(D_{0}, D_{0}) \\end{pmatrix} \\end{equation} $$\n记$\\mathbf{L}(k)$如下所示\n$$ \\begin{equation} \\mathbf{L}(k)= \\begin{pmatrix} C_{111}(-D_{0}-k, -D_{0}) \\\\ C_{111}(-D_{0}-k, -D_{0}+1) \\\\ \u0026hellip; \\\\ C_{111}(-D_{0}-k, D_{0}) \\\\ C_{111}(-D_{0}+1-k, -D_{0}) \\\\ \u0026hellip; \\\\ C_{111}(D_{0}-k, D_{0}) \\end{pmatrix} \\end{equation} $$\n记$\\mathbf{A}$为由$\\alpha(k)$构成的列向量，记$\\mathbf{L}$为\n$$ \\begin{equation} \\mathbf{L}= \\begin{pmatrix} \\mathbf{L}(-D_{0}) \u0026amp; \\mathbf{L}(-D_{0}+1) \u0026amp; \u0026hellip; \u0026amp; \\mathbf{L}(D_{0}) \\end{pmatrix} \\end{equation} $$\n根据(10)式可知，有下式成立\n$$ \\begin{equation} \\mathbf{V} = \\mathbf{L}\\mathbf{A} \\end{equation} $$\n则$\\mathbf{A}$的计算可由下式给出\n$$ \\begin{equation} \\mathbf{A} = \\mathbf{L}^{-1}\\mathbf{V} \\end{equation} $$\n其中$\\mathbf{L}^{-1}$表示$\\mathbf{L}$的广义逆。$\\mathbf{A}$的最大值所对应的下标，即为雷达站2相对于雷达站1需要补偿的时延数。\n互累积量的另一种理解方式是，通过构造一个特殊的矩阵方程，使得该方程的解便是时延差需要的补偿数，那么通过求解该方程便能得到所需要的时延补偿数。至于为什么互累积量不需要进行分段处理，这是因为事实上在一开始的时候已经引入最大时延差这一先验信息，基于这一先验信息，可以将运算次数大大减小。\n2.2. 代码与仿真分析 首先来比较一下互相关方法与互累积量方法之间的噪声抑制性能差别。以下代码给出了互相关与互累积量的噪声抑制性能之间的比较\nN = 1000; % 采样点数 K = 10; % 互相关方法分段长度 sig = zeros(2, N); % 生成两段测试信号 sig = awgn(complex(sig), 0); % 添加噪声 ret1 = zeros(1, N); % 计算分段互相关 for i = 1 : N/K ind = (i-1)*K+1 : i*K; % 获得分段 ret1(ind) = fftshift(ifft(fft(sig(1, ind)) .* conj(fft(sig(2, ind))))); % 作互相关 end ret2 = conj(sig(1, :)) .* sig(2, :) .* sig(1, :); % 计算互累积量 disp(mean(abs(ret1).^2)); % 显示互相关方法的平均功率 disp(mean(abs(ret2).^2)); % 显示互累积量方法的平均功率 figure; % 作图 subplot(2, 1, 1); plot(abs(ret1)); xlabel(\u0026#39;距离门\u0026#39;); ylabel(\u0026#39;幅度\u0026#39;); subplot(2, 1, 2); plot(abs(ret2)); xlabel(\u0026#39;距离门\u0026#39;); ylabel(\u0026#39;幅度\u0026#39;); 以下是上述程序的运行结果\n图2.1：两种方法比较\r并且程序输出两种处理方法的噪声功率在分段长度为10时，可以相差五倍左右。上述结果意味着互累积量具有比互相关方法更佳的噪声抑制效果。\n接下来进行仿真互累积量的对齐方法，为了仿真方便，本文将互累积量方法计算时延补偿数这一过程封装在了一个名为calcX的函数中\nfunction x = calcX(sig1, sig2, Dmax) ... end 其中sig1，sig2分别表示第一个雷达站的接收信号与第二个雷达站的接收信号，Dmax表示两个雷达站时延差的最大值，这表示两个雷达站时延差的取值范围是$[-\\mathrm{Dmax}, \\mathrm{Dmax}]$。在该函数中，首先计算$\\mathbf{V}$矩阵，$\\mathbf{V}$矩阵的计算代码如下所示\n% 计算T121矩阵 T121 = zeros(2 * Dmax + 1, 2 * Dmax + 1); for i = 1 : 2*Dmax+1 for j = 1 : 2*Dmax+1 ti = i - Dmax; % 开始计算C121(i-Dmax, j-Dmax) tj = j - Dmax; tsig1 = circshift(sig1, tj); % 对信号取循环时延操作 tsig2 = circshift(sig2, ti); % 计算时延后的临时信号的互累积量，即C121(ti, tj) T121(i, j) = sum(conj(sig1) .* tsig2 .* tsig1); end end % 对矩阵作一个拉伸操作即可得到最终结果 T121 = reshape(T121, (2*Dmax+1)^2, 1); 上述代码中T121变量即对应着前文所述的$\\mathbf{V}$矩阵，对于$\\mathbf{L}$矩阵的计算方法同理可得\nT111 = zeros((2*Dmax+1)^2, 2*Dmax+1); for i = 1 : 2*Dmax+1 tmp = zeros(2*Dmax+1, 2*Dmax+1); for j = 1 : 2*Dmax+1 for k = 1 : 2*Dmax+1 ti = i - Dmax + j - Dmax; tj = k - Dmax; tsig1 = circshift(sig1, tj); tsig2 = circshift(sig1, ti); tmp(i, j) = sum(conj(sig1) .* tsig2 .* tsig1); end end T111(:, i) = reshape(tmp, (2*Dmax+1)^2, 1); end 上述代码中T111变量即对应着$\\mathbf{L}$矩阵。当计算得到$\\mathbf{V}$与$\\mathbf{L}$矩阵后，通过广义逆，便可将最终的结果求解出来，如下所示\nx = pinv(T111) * T121; 借助上述calcX函数，可以轻易地对互累积量方法进行仿真。假设雷达站1与雷达站2时延相差5个采样点，令最大时延数$D_0$为10个采样点，当信噪比为20dB时，互累积量方法得到的变量x如下所示（注意，为求得时延差，需要将最大值所对应序号减去$D_0$）\n图2.2：互累积量方法结果\r从上图可以看到，互累积量方法已经能够正确得到相应的时延结果。但是随之而来的一个问题是，互累积量方法在不同信噪比条件下的工作性能是如何的。经过测试可以得到如下所示结果\n图2.3：互累积量方法不同信噪比下正确率\r从上图观察可得，为了使时延校正正确率达到70%，雷达回波信号的信噪比需要达到16dB。下图为互相关方法在不同信噪比条件下的正确率（分段长度为20），从下图可以看到，当正确率为70%时，要求回波信噪比大于12.3dB。这意味着虽然互累积量方法不需要确定分段大小，但是互累积量所需要的信噪比相较于互相关方法更高。\n图2.4：互相关方法不同信噪比下正确率\r总结来说，对于互相关方法，如果能够通过多种方式使得目标回波落入同一分段内，那么可以使用互相关方法来进行时延对齐；而倘若不能保证目标回波落入同一分段内，但是接收信号信噪比较大，那么互累积量方法便是更好的选择，因为互累积量只需要知道最大的时延差便可。\n上述两种方法均是单一的基于接收信号进行对齐的，事实上可以通过事先发射正交波形来获得时延差。这种方法被称为基于MIMO模式的相参参数估计方法，这种方法对目标回波信噪比没有要求，只需要发射的正交波形能够被探测到即可。因此该方法能够在多种条件下进行对齐补偿。\n3. CFAR统计量融合方法 3.1. 基本原理 CFAR的全称是Constant False-Alarm Rate，即恒虚警率。CFAR的基本思想是通过设立一系列的参考单元，来估计背景噪声功率，随后通过估计而得的背景噪声功率来决定门限值。这种方法并不通过预先设定的门限值来进行比较，因此具有自适应的特点。同时由于是通过估计而得的背景噪声功率来决定门限值，因此也具有恒虚警的性质。有关CFAR的具体内容可参考网上的一系列资料。\n对于一个单雷达而言，若记被检测单元的幅值为$r_0$，参考单元幅值的均值为$\\bar{r}$，那么判决域可表示为\n$$ \\begin{equation} r_0 \\underset{H_0}{\\overset{H_1}{\\gtrless}} K \\bar{r} \\end{equation} $$\n其中$K$为一个常数，用于调整虚警率。作一个变形，上式可表示为似然比检验的形式，如下所示\n$$ \\begin{equation} \\frac{r_0}{\\bar{r}} \\underset{H_0}{\\overset{H_1}{\\gtrless}} K \\end{equation} $$\n对于组网雷达而言，每个雷达可向融合中心传输统计量$\\frac{r_0}{\\bar{r}}$，随后融合中心将这些接收到的统计量简单相加，便可得到融合后的结果。这种方法方便快捷，但缺点是没有考虑到各个雷达站之间的差异性，如信噪比差异等等。因此这种方法被称为次优的CFAR统计量融合检测算法。融合中心的统计量如下所示\n$$ \\begin{equation} z = \\sum_i \\frac{r_i}{\\bar{r}} \\end{equation} $$\n由于该统计量难以求解得到概率密度函数，因此可通过蒙特卡洛模拟的方式来确定门限值。\n接下来讨论考虑了各雷达站之间差异的融合方法，这种方法从奈曼皮尔逊准则的似然比检验出发进行推导。当目标RCS满足SwerlingI或II型时，接收回波中，有无目标时的幅度概率密度函数如下所示\n$$ \\begin{equation} \\begin{cases} f(x | H_0) = \\frac{1}{\\sigma_n}\\exp(-\\frac{x}{\\sigma_n}) \\\\ f(x | H_1) = \\frac{1}{\\sigma_n (\\mu + 1)}\\exp(-\\frac{x}{\\sigma_n (\\mu + 1)}) \\end{cases} \\end{equation} $$\n其中$\\sigma_n$为噪声功率，$\\mu$为信噪比。而统计量$t_i = \\frac{r_i}{\\bar{r}}$的分布函数推导如下所示\n$$ \\begin{equation} \\begin{aligned} 1 - F(T | H_0) =\u0026amp; P(r_i \u0026gt; \\bar{r}T | H_0) \\\\ =\u0026amp; \\displaystyle\\int_{0}^{+\\infty}f(\\bar{r} | H_0)\\exp(-\\frac{\\bar{r}T}{\\sigma_n}) \\mathrm{d}\\bar{r} \\\\ =\u0026amp; 1 - (1 + \\frac{T}{n})^{-n} \\end{aligned} \\end{equation} $$\n其中$f(\\bar{r} | H_0)$为$\\bar{r}$所满足的概率密度分布，即$n$变量指数分布叠加所形成的概率密度函数；$n$为参考单元个数。\n同理可得$F(T|H_1)$如下所示\n$$ \\begin{equation} F(T | H_1) = 1 - (1 + \\frac{T}{n(1+\\mu)})^{-n} \\end{equation} $$\n对(24)式与(25)式分别求导可得到概率密度函数为\n$$ \\begin{equation} \\begin{cases} f(t | H_0) = (\\frac{n}{n+t})^{n+1} \\\\ f(t | H_1) = \\frac{n^{n+1}(1+\\mu)^{n}}{(n(1+\\mu) + t)^{n+1}} \\end{cases} \\end{equation} $$\n于是可进一步得到统计中心似然比检验的统计量为\n$$ \\begin{equation} \\begin{aligned} z =\u0026amp; \\ln \\prod_i \\frac{f(t_i | H_1)}{f(t_i | H_0)} \\\\ =\u0026amp; \\sum_i (\\ln (f(t_i | H_1)) - \\ln (f(t_i | H_0))) \\\\ =\u0026amp; \\sum_i (n_i \\ln (1 + \\mu_i) + (n_i + 1)\\ln(\\frac{n_i + t_i}{n_i(1+\\mu_i)+t_i})) \\end{aligned} \\end{equation} $$\n上述的统计量需要知道每个雷达站的参考单元个数与信噪比，由于实际情况下一般很难知道雷达站所接收信号的信噪比，因此一般使用(22)式的统计量来进行融合。\n3.2. 代码与仿真分析 本节主要来进行CFAR统计量融合的仿真。\n仿真参数如下所示\n描述 参数 采样点数 1000 雷达站个数 5, 10, 15, 20 载频 1GHz 脉冲重复周期 1ms 参考单元个数 50 保护单元个数 40 首先定义一些基本常数，如下所示\nc = 3e9; % 光速 N = 5; % 雷达站个数 f0 = 1e9; % 载频1GHz T = 1e-3; % 脉冲重复周期 lambda = c / f0; % 载频波长 随后进行接收矩阵的生成并计算CFAR统计量，如下所示\n% 构造接收矩阵 x = zeros(1000, N); x(600, :) = 1; x = awgn(x, k/10); % 第二个参数为信噪比 % 计算各雷达站的CA-CFAR统计量 x = x.^2; % 平方律检波 refNum = 50; % 参考单元个数 protectNum = 20; % 一边的保护单元个数 t = zeros(size(x, 1) - refNum - 2*protectNum, size(x, 2)); for i = 1 : size(t, 1) tmp = sum(x(i:(i+refNum/2-1))) + sum(x((i+refNum/2+protectNum*2+1) : (i+refNum+protectNum*2))); tmp = tmp / refNum; t(i, :) = x(i + refNum/2 + protectNum, :) / tmp; end % 非相干CA-CFAR统计量融合 y = sum(t, 2); 当然，在进行检测时，通常需要知道一定虚警概率下的门限阈值，从表达式上来说，阈值并不是一个简单计算的量。因此此处使用蒙特卡洛模拟来进行阈值的计算。在上述程序中，通过蒙特卡洛模拟计算，如果将y的阈值定为17，那么10dB信噪比下的虚警概率便是1%左右。在该门限下，对检测概率作蒙特卡洛模拟计算，可得到如下结果\n图3.1：五雷达站下的检测概率\r改变雷达站个数，并重复上述步骤，可得到如下结果\n图3.2：不同雷达站个数下的检测概率\r图3.1与3.2结果说明了增加雷达站个数来提高组网雷达的性能是可行的。事实上，从另一个角度来说，增加组网雷达站的个数，本质上是使得有无目标情况下的两个概率密度函数具有更高的区分度。如下所示图3-3，通过蒙特卡罗模拟了信噪比10dB下的，二十个雷达站的有无目标时的概率密度函数。而3.4则是展示了单雷达站下的有无目标的概率密度函数对比。\n图3.3：有无目标时的概率密度函数对比\r图3.4：有无目标时的概率密度函数对比\r从图3.3与3.4观察可得，增加雷达站个数本质上是让不同的概率密度函数之间有了更好的区分度。如果从这一思路出发，显然可以通过其它的优化函数方法来获得更佳的融合统计量，因此笔者认为接下来可以从最优化函数的角度出发，来得到最优的统计量，以使得到最佳的概率密度区分度。这个便是深度学习方法在组网雷达融合检测中的一个切入点。\n4. 基于噪声子空间投影的干扰去除方法 4.1. 基本原理 基于噪声子空间投影来去除干扰的方法基于一个基本假设，即多雷达站所接收到的干扰具有强相关性，而目标回波不具有相关性（或具有弱相关性）。与第一章所基于的假设不同的是，本章假设各个雷达站所接收到的雷达回波不具有相关性。如果目标回波具有相关性，那么在去除干扰的同时，也会将目标回波同时去除。\n基于噪声子空间投影的干扰去除方法的基本原理是，由于各个雷达站所接收到的干扰信号具有相关性并且具有大能量特征，因此对各个雷达站所接收到的信号作特征值分解时，干扰信号将会构成一个具有大特征值的干扰子空间，而噪声信号由于能量较小，仅会构成特征值较小的噪声子空间。当将雷达回波投影至噪声子空间时，便会将干扰去除。同时由于目标回波能量在整段雷达回波信号中占据较小能量，且不具有相关性，因此在投影至噪声子空间过程中，并不会去除目标回波信号。\n记雷达站$i$所接收到的回波信号为$r_i(t)$，如下所示\n$$ \\begin{equation} r_i(t) = s_i(t)+c_i(t)+n_i(t) \\end{equation} $$\n其中$s_i(t)$为目标回波信号，$c_i(t)$为干扰信号，$n_i(t)$为噪声。对上述接收信号进行采样，得到雷达站$i$的接收向量，如下所示\n$$ \\begin{equation} \\mathbf{r}_i= \\begin{pmatrix} r_i(T_s) \\\\ r_i(2T_s) \\\\ \u0026hellip; \\\\ r_i(nT_s) \\end{pmatrix} \\end{equation} $$\n其中$n$为雷达站接收信号采样点数，$T_s$为采样间隔。多个雷达站所接收到的信号构成一个矩阵，如下所示\n$$ \\begin{equation} \\mathbf{r}= \\begin{pmatrix} \\mathbf{r}_1 \u0026amp; \\mathbf{r}_2 \u0026amp; \u0026hellip; \u0026amp; \\mathbf{r}_N \\end{pmatrix} \\end{equation} $$\n其中$N$为雷达站个数。通过接收回波矩阵可得到各雷达站接收信号的自相关与互相关为\n$$ \\begin{equation} \\mathbf{R}_{r}=\\mathbf{r}^{H}\\mathbf{r} \\end{equation} $$\n由于不同雷达站之间的噪声、噪声与信号、噪声与干扰之间没有相关性，因此在计算上述自相关矩阵时，可以直接将这几项忽略，只需要考虑信号自相关与干扰自相关与互相关即可。此时自相关矩阵可写为\n$$ \\begin{equation} \\mathbf{R}_{r} = \\mathbf{R}_{s} + \\mathbf{R}_{j} + \\mathbf{R}_{n} \\end{equation} $$\n其中$\\mathbf{R}_{s}$为信号的自相关矩阵，$\\mathbf{R}_{j}$为干扰的自相关矩阵，$\\mathbf{R}_{n}$为噪声的自相关矩阵。\n记雷达站$i$的目标回波信号为$\\alpha_i s_i(t)$，其中$s_i(t)$为发射机发射信号在空间中经过双程延时后的信号，$\\alpha_i$为由于目标RCS起伏特性导致的复幅度。上式仅考虑了雷达信号自发自收的情况，事实上对于雷达站多发多收的情况下的分析是一致的。此时信号回波的自相关矩阵为\n$$ \\begin{equation} \\mathbf{R}_{s}= \\begin{pmatrix} \\alpha_1^2 C_1 \u0026amp; 0 \u0026amp; \u0026hellip; \u0026amp; 0 \\\\ 0 \u0026amp; \\alpha_2^2 C_2 \u0026amp; \u0026hellip; \u0026amp; 0 \\\\ \u0026hellip; \\\\ 0 \u0026amp; 0 \u0026amp; \u0026hellip; \u0026amp; \\alpha_N^2 C_N \\end{pmatrix} \\end{equation} $$\n其中$C_i=\\int_{-\\infty}^{+\\infty}s_i(t)^2\\mathrm{d}t$（假设各雷达信号已完成对齐）。可以发现信号回波的自相关矩阵是满秩的，这意味着信号回波将分布在整个接收回波空间中。\n由于各雷达站接收到的干扰信号通常由一个干扰机发出，因此干扰信号之间存在强相关性。假设雷达站$i$接收到的干扰信号为$\\beta_i j(t)$（假设干扰与目标回波信号同时对齐，这意味着干扰机需要与真实目标相差较小距离），其中$\\beta_i$表示由于路程导致的信号幅度差异，$j(t)$表示干扰机发射的干扰信号。此时干扰信号的自相关矩阵可表示为\n$$ \\begin{equation} \\mathbf{R}_{j}= \\begin{pmatrix} \\beta_1^2 D_{11} \u0026amp; \\beta_1 \\beta_2 D_{12} \u0026amp; \u0026hellip; \u0026amp; \\beta_1 \\beta_N D_{1N} \\\\ \\beta_2 \\beta_1 D_{12} \u0026amp; \\beta_2^2 D_{22} \u0026amp; \u0026hellip; \u0026amp; \\beta_2 \\beta_N D_{2N} \\\\ \u0026hellip; \\\\ \\beta_N \\beta_1 D_{1N} \u0026amp; \\beta_N \\beta_2 D_{2N} \u0026amp; \u0026hellip; \u0026amp; \\beta_N^2 D_{NN} \\end{pmatrix} \\end{equation} $$\n其中$D_{ij}=\\int_{-\\infty}^{+\\infty}j_i(t)j_j^*(t)\\mathrm{d}t$。由于每个雷达站接收到同一干扰机的干扰信号，因此上式中的所有$D_{ij}$均相等仅相差某一幅角，不妨记为$D$。观察干扰信号的自相关矩阵可以发现每一列均为如下所示向量的某个倍数，因此干扰信号的自相关矩阵的秩为1。\n$$ \\begin{equation} \\begin{pmatrix} \\beta_1 D \\\\ \\beta_2 D \\\\ \u0026hellip; \\\\ \\beta_N D \\end{pmatrix} \\end{equation} $$\n借助干扰信号与目标回波信号在空间分布上的差异，即可去除干扰信号。噪声自相关矩阵与信号自相关矩阵同理分析，可得到为一个对角阵，同样满足满秩条件。\n对接收信号的自相关矩阵作特征值分解，可得到如下结果\n$$ \\begin{equation} \\mathbf{R}_r = \\sum_{i=1}^{N}\\lambda_i \\mathbf{v}_i\\mathbf{v}_i^T \\end{equation} $$\n其中由于干扰信号占据较大能量，因此具有大的特征值，而噪声与目标回波信号的能量相对较小，因此在分析时可忽略不计。记$\\lambda_1, \\lambda_2, \u0026hellip;, \\lambda_N$降序排列，由于干扰信号对应大的特征值，因此可去除前几个特征值与特征向量，而保留后面的特征值与特征向量，得到如下矩阵\n$$ \\begin{equation} \\mathbf{P} = \\sum_{i=q}^{N}\\mathbf{v}_i\\mathbf{v}_i^T \\end{equation} $$\n记$\\mathbf{z}$为$\\mathbf{r}$经过矩阵$\\mathbf{P}$投影后的结果，如下所示\n$$ \\begin{equation} \\mathbf{z} = \\mathbf{r}\\mathbf{P} \\end{equation} $$\n此时投影后的向量$\\mathbf{z}$的自相关矩阵如下所示\n$$ \\begin{equation} \\begin{aligned} \\mathbf{R}_z =\u0026amp; \\mathbf{P}^H\\mathbf{R}_r\\mathbf{P} \\\\ =\u0026amp; \\mathbf{P}^H(\\sum_{i=1}^{N}\\lambda_i \\mathbf{v}_i\\mathbf{v}_i^T) \\mathbf{P} \\\\ =\u0026amp; \\sum_{i=q}^{N}\\lambda_i \\mathbf{P}^H\\mathbf{v}_i\\mathbf{v}_i^T\\mathbf{P} \\\\ =\u0026amp; \\mathbf{P}^H\\mathbf{R}_s\\mathbf{P} + \\mathbf{P}^H\\mathbf{R}_n\\mathbf{P} \\end{aligned} \\end{equation} $$\n可以看到此时投影后的向量$\\mathbf{z}$的自相关矩阵中已经没有了干扰信号的自相关分量，这意味着下式成立\n$$ \\begin{equation} \\mathbf{P}^H\\mathbf{j}^H\\mathbf{j}\\mathbf{P}=0 \\end{equation} $$\n即下式成立\n$$ \\begin{equation} \\mathbf{j}\\mathbf{P}=0 \\end{equation} $$\n可以看到此时干扰分量已经成功被去除。事实上根据前文的推导可知，当干扰机数量小于组网雷达数量时，便可成功将干扰去除，这是因为此时的干扰信号构成的空间仍然不是满秩的，通过空间分布之间的差异，便可成功去除。\n还可证明经过上述干扰抑制操作后，信噪比是不变的。从形式上看，将回波信号投影到噪声子空间后，由于回波信号是满秩的，因此回波信号强度只减小为了之前的常数倍；而噪声信号同样是满秩的，经过投影后，减小到了同样常数倍。因此两者相除后，信噪比是不变的。\n4.2 代码与仿真分析 在使用噪声子空间投影法去除干扰信号之前，需要先将干扰信号进行对齐，随后才可使用该方法去除干扰信号。对齐方法在第二章已经详细叙述过了，此处就不再演示，因此本节的仿真程序默认回波信号的干扰已经经过了对齐。Matlab代码如下所示\nJ = wgn(1000, 1, 10, \u0026#39;complex\u0026#39;); % 干扰信号 s = zeros(1000, 2); % 目标回波信号 s(500, 1) = 1 * exp(1i * 1); s(500, 2) = 1 * exp(1i * 2); x = awgn(complex(s), 20); % 加入噪声 x = x + [J .* exp(1i * (1 : length(J))\u0026#39;), J .* exp(1i * (1 : length(J))\u0026#39;)]; figure; plot(abs(x(:, 1))); % 绘制出接收信号 R = x\u0026#39; * x; [E, V] = eig(R); [B, I] = sort(diag(abs(V)), \u0026#39;descend\u0026#39;); P = E(:, I(2:end)); % 去除大特征值后的投影矩阵 P = P * P\u0026#39;; y = (P * x\u0026#39;)\u0026#39;; % 进行投影 figure; plot(abs(y(:, 1))); % 绘制出去除干扰后的信号 首先生成干扰信号与目标回波信号，随后给目标回波信号加入独立噪声与相关干扰，最后计算投影矩阵来将具有相关性的干扰信号去除。仿真的接收信号如下所示\n图4.1：雷达接收信号\r可以看到此时干扰信号已经完全将回波信号淹没了，接下来利用投影矩阵对齐进行投影可以得到如下结果\n图4.2：投影后的信号\r可以发现已经成功去除了干扰信号。该方法的原理是，借助两雷达站接收到的干扰信号的相关性来去除，换言之，如果接收回波信号具有相关性，那么回波信号将会随干扰信号一同被去除。这个方法在运用时需要注意两个要点，一个是干扰信号之间需要存在相关性才能去除，另一个是回波信号之间不能存在相关性，否则会随干扰一同被去除。\n5. 基于张量的融合方法 多雷达站信号级融合可通过互相关方法进行融合，其基本思想为，首先对接收信号作滑窗处理，随后对各个雷达站对应序号的滑窗作互相关处理，并将互相关结果作为最终结果输出。当进行目标检测时，只需要从互相关结果分析便可。\n事实上互相关方法可以看作接收信号被一个张量投影后的结果（这在下文会具体描述），基于张量融合方法的基本思想是，如果能够在某一优化目标函数下，最优化该投影张量，那么最终便能够得到相较于互相关方法更好的结果。这一优化目标函数有许多种取法，在本节中，目标函数选取为投影结果的信息熵，这是因为当目标存在时，投影结果的幅度应当是层次可分明的，而不存在目标时，投影结果应当是平坦全是噪声的。基于这种思路，该方法的步骤如下所示\n选取一个合理的最优化函数，如信号投影结果的信息熵 借助Matlab生成一系列训练数据 借助Tensorflow或者Pytorch等库，来最优化得到投影张量$\\mathbf{A}$ 在Matlab中使用投影张量来进行验证与仿真 5.1. 基本原理 假设雷达站$i$的采样后的回波矢量如下所示\n$$ \\begin{equation} \\mathbf{r}_i= \\begin{pmatrix} r_i(1) \\ r_i(2) \\ \u0026hellip; \\ r_i(m) \\end{pmatrix} \\end{equation} $$\n其中$m$为雷达站$i$总采样点数。对其进行滑窗处理，假设每一段长度为$n$，则第$k$段滑窗为$\\mathbf{s}_i^{(k)}$，如下所示\n$$ \\begin{equation} \\mathbf{s}_{i}^{(k)}= \\begin{pmatrix} r_{i}((k-1)n+1) \\\\ r_{i}((k-1)n+2) \\\\ \u0026hellip; \\\\ r_{i}((k-1)n+n) \\end{pmatrix} \\end{equation} $$\n雷达站$i$与雷达站$j$的第$k$个滑窗作互相关可表示为$y_k$，如下所示\n$$ \\begin{equation} y_k = \\mathbf{s}_{i}^{(k)} \\cdot \\mathbf{s}_{j}^{(k)} \\end{equation} $$\n当滑窗内不存在目标回波时，$y_k$取值较小；当滑窗内存在目标回波时，$y_k$取值较大，因此可通过互相关结果的幅度大小来判断是否存在雷达回波信号。事实上，如果使用滑窗来作互相关的话，会有诸多问题，如滑窗大小选取的问题、信号落入不同滑窗的问题等。\n本章从另一个角度来阐述这一过程并使用一种新的方法来进行多雷达站信号融合检测，上述过程可以使用矩阵语言来描述。记$\\mathbf{A}$为一个三维矩阵，大小为$N \\times M \\times M$。其中$N$为张量融合结果矢量的长度，$M$为接收信号的采样点数。同时记$\\mathbf{A}(i, :, :)$表示矩阵$\\mathbf{A}$第一个维度下的第$i$个分量，为一个$M \\times M$大小的二维矩阵。上述记号与Matlab中的记号是一致的。\n互相关融合方法对雷达站$i$与雷达站$j$作互相关时，可表示如下\n$$ \\begin{equation} \\mathbf{y} = \\mathbf{r}_i^H \\mathbf{A} \\mathbf{r}_j \\end{equation} $$\n其中$\\mathbf{y}$表示融合结果矢量。上述一维矩阵与三维矩阵之间的乘法如下所示\n$$ \\begin{equation} \\begin{aligned} \\mathbf{r}_i^H \\mathbf{A}= \\begin{pmatrix} \\sum_{k=1}^{m}r_{i}^*(k)a_{1, k, 1} \u0026amp; \\sum_{k=1}^{m}r_{i}^*(k)a_{1, k, 2} \u0026amp; \u0026hellip; \u0026amp; \\sum_{k=1}^{m}r_{i}^*(k)a_{1, k, m} \\\\ \\sum_{k=1}^{m}r_{i}^*(k)a_{2, k, 1} \u0026amp; \\sum_{k=1}^{m}r_{i}^*(k)a_{2, k, 2} \u0026amp; \u0026hellip; \u0026amp; \\sum_{k=1}^{m}r_{i}^*(k)a_{2, k, m} \\\\ \u0026hellip; \\\\ \\sum_{k=1}^{m}r_{i}^*(k)a_{N, k, 1} \u0026amp; \\sum_{k=1}^{m}r_{i}^*(k)a_{N, k, 2} \u0026amp; \u0026hellip; \u0026amp; \\sum_{k=1}^{m}r_{i}^*(k)a_{N, k, m} \\end{pmatrix} \\in C^{N \\times 1 \\times m} \\\\ \u0026amp; \\end{aligned} \\end{equation} $$\n同理对于$\\mathbf{r}_i^H \\mathbf{A} \\mathbf{r}_j$可表示为\n$$ \\begin{equation} \\begin{aligned} \\mathbf{r}_i^H \\mathbf{A} \\mathbf{r}_j= \\begin{pmatrix} \\sum_{p=1}^{m}\\sum_{k=1}^{m}r_{i}^*(k)r_{j}(p)a_{1, k, p} \u0026amp; \u0026hellip; \u0026amp; \\sum_{p=1}^{m}\\sum_{k=1}^{m}r_{i}^*(k)r_{j}(p)a_{N, k, p} \\end{pmatrix} \\in C^{N \\times 1 \\times 1} \\\\ \u0026amp; \\end{aligned} \\end{equation} $$\n取$\\mathbf{A}(i, :, :)$如下所示\n$$ \\begin{equation} \\mathbf{A}(i, :, :) = \\mathrm{diag}(\\overbrace{0, \u0026hellip;, 0}^{(i-1)n}, \\underbrace{1, \u0026hellip;, 1}_{n}, 0, \u0026hellip;, 0) \\end{equation} $$\n则(3.41)式退化为基于滑窗的互相关融合方法。如果$\\mathbf{A}$的取值合理，那么最终的互相关融合结果$\\mathbf{y}$，在存在目标与不存在目标两种情况下，应当是可分离的。换言之，存在一个超平面，使得可以分割存在目标与不存在目标时对应的互相关融合结果矢量$\\mathbf{y}$。\n这意味着，存在一个矩阵$\\mathbf{P}$与一个偏置$b$，使得下式成立\n$$ \\begin{equation} \\mathrm{sgn}(\\mathbf{P}\\mathbf{y}+b) = \\left\\{ \\begin{array}{ll} 1 \u0026amp; \\text{target exists} \\\\ 0 \u0026amp; \\text{target not exists} \\end{array} \\right. \\end{equation} $$\n其中$\\mathrm{sgn}$如下所示\n$$ \\begin{equation} \\mathrm{sgn}(x)= \\left\\{ \\begin{array}{ll} 1 \u0026amp; x \u0026gt; 0 \\\\ 0.5 \u0026amp; x = 0 \\\\ 0 \u0026amp; x \u0026lt; 0 \\end{array} \\right. \\end{equation} $$\n在使用梯度下降法或其它优化方法来寻找最优矩阵$\\mathbf{P}$，偏置$b$与矩阵$\\mathbf{A}$时，由于上述函数的导数性质不够良好，因此通常不使用上述定义的$\\mathrm{sgn}$函数，而是使用下述定义的$\\mathrm{sgn}$函数\n$$ \\begin{equation} \\mathrm{sgn}(x) = \\frac{1}{1 + e^{-x}} \\end{equation} $$\n于是可通过计算机生成大量的训练数据，并通过梯度下降等方法来计算得到最优的矩阵$\\mathbf{P}$，偏置$b$与矩阵$\\mathbf{A}$。\n但是上述方法通常存在难以收敛到最优点这一问题，因此本章不采用上述方法来进行矩阵$\\mathbf{A}$的求解。当雷达回波中存在目标回波时，应当存在一种映射，使得映射后的结果具有较低的信息熵。这是因为当取一个合适的映射矩阵$\\mathbf{A}$时，可以使得雷达回波的有目标回波部分相叠加，从而具有较高的幅度；而噪声部分相消，从而只有低的幅度，此时映射结果具有较低的信息熵。\n此时，矩阵$\\mathbf{A}$的求解可化为求解一个基于张量运算的优化问题，如下所示\n$$ \\begin{equation} \\min_{\\mathbf{A}} \\sum_{i, j}I(\\mathbf{r}_i^H \\mathbf{A} \\mathbf{r}_j) \\end{equation} $$\n其中$I(\\cdot)$表示信息熵，定义如下\n$$ \\begin{equation} I(\\mathbf{x}) = -\\sum_{i}\\frac{|x(i)|^2}{G}\\ln\\frac{|x(i)|^2}{G} \\end{equation} $$\n其中$G = \\sum_{i}|x(i)|^2$。当映射结果中具有目标时，(52)式应当取值较小；当映射结果中全是噪声时，(52)式应当取值较大。首先借助Matlab来生成一系列具有目标与不具有目标的雷达回波数据，随后利用梯度下降法等最优化方法来求解得到投影张量$\\mathbf{A}$即可。\n5.2. 代码与仿真分析 本方法采用Python+Matlab混合编程实现，这是因为Python具有良好的机器学习生态，在处理最优化问题上具有较好的结果。首先通过Matlab来生成对应的训练数据，生成的训练数据默认是经过了时延对齐的数据。代码如下所示\nN = 400; % 采样点数 M = 2000; % 每次生成的数据量 x1 = zeros(11*4000, N); x2 = zeros(11*4000, N); % 生成不同信噪比下有无目标的回波数据 for i = 10 : 20 [t1, t2] = genData(i, 1, N, M); x1((i-10)*M+1 : (i-9)*M, :) = t1; x2((i-10)*M+1 : (i-9)*M, :) = t2; end for i = 10 : 20 [t1, t2] = genData(i, 0, N, M); x1((i-10)*M+1+11*M : (i-9)*M+11*M, :) = t1; x2((i-10)*M+1+11*M : (i-9)*M+11*M, :) = t2; end % 保存至.mat文件 x1_real = real(x1); x1_imag = imag(x1); x2_real = real(x2); x2_imag = imag(x2); save(\u0026#39;radarData.mat\u0026#39;, \u0026#39;x1_real\u0026#39;, \u0026#39;x1_imag\u0026#39;, \u0026#39;x2_real\u0026#39;, \u0026#39;x2_imag\u0026#39;); % 生成两个雷达站的回波信号 % snr: 信噪比 % label: 1表示有目标，0表示无目标 % N: 采样点数 % M: 生成回波数据量 function [x1, x2] = genData(snr, label, N, M) x1 = zeros(M, N); x2 = zeros(M, N); for i = 1 : size(x1, 1) off1 = round(rand(1) * 10 - 5); off2_1 = rand(1) * 2*pi; off2_2 = rand(1) * 2*pi; x1(i, round(size(x1, 2)/2) + off1) = label * exp(off2_1 * 1i); x2(i, round(size(x2, 2)/2) + off1) = label * exp(off2_2 * 1i); end x1 = awgn(complex(x1), snr); x2 = awgn(complex(x2), snr); % 归一化 for i = 1 : size(x1, 1) x1(i, :) = x1(i, :) / max(abs(x1(i, :))); x2(i, :) = x2(i, :) / max(abs(x2(i, :))); end end 运行上述代码将生成一个名为radarData.mat的文件，该文件中储存了不同信噪比下的有无目标时的两雷达站接收信号。随后利用Python的Pytorch来进行最优化求解，借助GPU，这一运算将得到很大的速度提升，代码如下所示。\nimport torch import torch.nn as nn import torch.optim as optim from torch.autograd import Variable from numpy import * from scipy.io import loadmat, savemat def matmul_complex(t1,t2): return torch.view_as_complex(torch.stack((t1.real @ t2.real - t1.imag @ t2.imag,t1.real @ t2.imag + t1.imag @ t2.real),dim=2)) device = torch.device(\u0026#34;cuda:0\u0026#34;) ########### Load Data ############### tmp = loadmat(\u0026#39;radarData.mat\u0026#39;) x1_real = tmp[\u0026#39;x1_real\u0026#39;] x1_imag = tmp[\u0026#39;x1_imag\u0026#39;] x2_real = tmp[\u0026#39;x2_real\u0026#39;] x2_imag = tmp[\u0026#39;x2_imag\u0026#39;] x1 = torch.complex(torch.Tensor(x1_real), torch.Tensor(x1_imag)).to(device).T x2 = torch.complex(torch.Tensor(x2_real), torch.Tensor(x2_imag)).to(device).T ##################################### N = 32 m = 400 lr = 1e-3 epochs = 100 totalNum = x1_real.shape[0] batchSize = 11000 A_re = torch.normal(mean = 0, std=0.01, size = (N, m, m)).to(device) A_im = torch.normal(mean = 0, std=0.01, size = (N, m, m)).to(device) A_var = Variable(torch.complex(A_re, A_im), requires_grad = True) try: while 1: totalLoss = 0 for i in range(2): r1 = x1[:, i*batchSize : (i+1)*batchSize].reshape([m, batchSize]) r2 = x2[:, i*batchSize : (i+1)*batchSize].reshape([m, batchSize]) A_var.retain_grad() tmp = torch.sum(torch.matmul(r1.T, A_var).mT * r2, axis=1) out = torch.abs(tmp) / torch.sqrt(torch.sum((torch.abs(tmp)**2), axis=0)) loss = -torch.sum(out * torch.log(out)) totalLoss += loss loss.backward() A_var = A_var - lr * A_var.grad print(totalLoss) except KeyboardInterrupt: pass A = A_var.detach().cpu().numpy() savemat(\u0026#39;radarVar.mat\u0026#39;, {\u0026#39;A\u0026#39;: A, \u0026#39;P\u0026#39;: P, \u0026#39;b\u0026#39;: b}) import pdb pdb.set_trace() 上述代码首先读取radarData.mat这一文件来获得训练数据，随后利用Pytorch来求解最优的投影张量$\\mathbf{A}$，并在最后将投影张量保存在radarVar.mat中，供Matlab来读取进行后续的仿真验证。Matlab中的验证仿真代码如下所示\nload radarVar.mat; x1 = zeros(400, 1); x2 = zeros(400, 1); x1(200) = 1; x2(200) = 1; x1 = awgn(complex(x1), 10); x2 = awgn(complex(x2), 10); ret = zeros(1, 32); for i = 1 : 32 ret(i) = x1\u0026#39; * reshape(A(i, :, :), 400, 400) * x2; end ret = reshape(ret, 32, 1); 上述代码生成的两雷达站回波信号如下所示\n图5.1：两雷达站接收信号\r经过投影融合后，得到如下所示结果\n图5.2：融合检测结果\r经过计算可以得到，融合后的信噪比大约为24.3dB，相比于原先的信噪比提高了约15dB。进一步地，可编写程序来计算不同原始信噪比情况下的融合信噪比变化，如下图所示。\n图5.3：融合信噪比变化\r从上图可以看出，原始信噪比越高时，融合效果越好，并且基于张量的融合方法优于基于互相关方法的融合方法。这从另一方面证明了本节方法的优越性。\n","permalink":"https://bingsz.github.io/en/posts/radarsummary2/","summary":"\u003cp\u003e  分布式全相参雷达论文阅读笔记（二）。主要内容有：基于互相关方法的时延对齐方法，基于互累积量方法的时延对齐方法，基于CFAR统计量的融合方法，基于噪声子空间投影的杂波抑制方法与基于张量的融合检测方法。\u003c/p\u003e","title":"分布式全相参雷达论文阅读笔记（二）"},{"content":" 分布式全相参雷达论文阅读笔记（一）。主要内容有：基于模值的信号级融合检测，收发相参的同步方法，利用频率步进信号提高接收相参性能，相参参数估计误差影响分析和协同探测区域划分方法。\n2. 信号级相参 2.1. 信号级融合检测 目前有大量的文献关于信号级融合检测，而信号级融合检测可简要概括为，在各协同探测雷达信号之间寻找一个统计量或者一种检测方法，使得多雷达信号融合后可产生更好的检测性能。\n若记雷达站$i$所接收到的信号矢量为$\\mathbf{r_i}=[r_{i,0}, r_{i,1}, \u0026hellip;, r_{i,n-1}]^T$，发射信号为$\\mathbf{s}=[s_0, s_1, \u0026hellip;, s_{\\tau-1}]^T$，经过一定延时，到达接收端$i$的发射信号为$\\mathbf{s_i}$，噪声为$\\mathbf{n}$。则雷达站$i$所接收到的信号可写为信号与噪声的叠加\n$$ \\mathbf{r_i}=\\mathbf{s_i}+\\mathbf{n} $$\n通常假设每一通道的噪声均独立地服从零均值高斯分布，即$n \\sim \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp(-\\frac{n^2}{2\\sigma^2})$，而现代雷达通常使用$\\mathrm{IQ}$中频正交采样，因此雷达噪声可看作一个实部与虚部均服从某一高斯分布的复数。该噪声可写为$n_z=n_I+jn_Q$，其中$n_I$与$n_Q$均服从高斯分布。一个噪声的强度可用其模长来衡量，有多种方法推导$n_z$的模长所服从的概率分布，此处介绍一种方法。\n将$n_z$改写为极坐标形式，即$n_z=r\\exp(j\\theta)$。于是有\n$$ \\begin{cases} n_I = r\\cos(\\theta) \\\\ n_Q = r\\sin(\\theta) \\end{cases} $$\n从而$n_I$与$n_Q$的联合概率密度函数可写为\n$$ f(n_I, n_Q)=\\frac{1}{2\\pi \\sigma^2}\\exp(-\\frac{n_I^2+n_Q^2}{2\\sigma^2})=\\frac{1}{2\\pi\\sigma^2}\\exp(-\\frac{r^2}{2\\sigma^2}) $$\n将上式作一个换元可得到（注意需要乘一个雅可比矩阵）\n$$ f(r, \\theta)=\\frac{r}{2\\pi\\sigma^2}\\exp(-\\frac{r^2}{2\\sigma^2}) $$\n因此边缘分布函数为\n$$ \\begin{align*} \u0026amp;f(r) = \\frac{r}{\\sigma^2}\\exp(-\\frac{r^2}{2\\sigma^2}) \\ \u0026amp;f(\\theta) = \\frac{1}{2\\pi} \\end{align*} $$\n从上述推导可发现，$n_z$的模长服从瑞利分布，相位服从均匀分布，推导结果是符合直觉的。当信号幅度为一个恒定值$A$时，信号与噪声的叠加服从莱斯分布。莱斯分布具有复杂的表达式，并且许多计算将变得非常复杂。为了方便计算，假设目标服从$\\mathrm{Swerling}\\ 1$型起伏模型，因此目标回波幅度服从瑞利分布，记该分布为$\\frac{r}{A^2}\\exp(-\\frac{r^2}{2A^2})$。但是瑞利分布在某些情况下并不能化简，因此通常将信号进行平方律检波，检波后的信号幅度服从指数分布，有相关的理论与工程研究表明，两者所得到的结果是相似的。在这种情况下进一步推导可以得到，仅存在噪声与同时存在目标与噪声时的概率分布函数分别为\n$$ \\begin{align*} f_n(r) = \\frac{1}{\\sigma}\\exp(-\\frac{r}{\\sigma}) \\ f_s(r) = \\frac{1}{\\sigma+A}\\exp(-\\frac{r}{\\sigma+A}) \\end{align*} $$\n因此当给出观测信号矢量$\\mathbf{r_i}$时，其对应的概率在两种假设$H_0$（无目标存在）与$H_1$（有目标存在）下分别为\n$$ \\begin{cases} H_0: f(\\mathbf{r_i}|H_0) = \\prod_j \\frac{1}{\\sigma}\\exp(-\\frac{r_{i,j}}{\\sigma}) \\\\ H_1: f(\\mathbf{r_i}|H_1) = \\prod_j \\frac{1}{\\sigma+A}\\exp(-\\frac{r_{i,j}}{\\sigma+A}) \\end{cases} \\tag{2.1.1} $$\n取对应的似然比检验量$L(\\mathbf{r_i})$为（忽略常数项）\n$$ \\begin{align*} \\ln L(\\mathbf{r_i})=\u0026amp;\\sum_{j}(\\frac{r_{i,j}}{\\sigma}-\\frac{r_{i,j}}{A+\\sigma}) \\\\ =\u0026amp;\\sum_{j}\\frac{Ar_{i,j}}{\\sigma(A+\\sigma)} \\end{align*} $$\n记$v_{i,j}=\\frac{Ar_{i,j}}{\\sigma(A+\\sigma)}$，并将其代入至(2.1.1)式中可得\n$$ \\begin{cases} H_0: f(v_{i, j}|H_0) = \\frac{A+\\sigma}{A}\\exp(-\\frac{A+\\sigma}{A}v_{i,j}) \\\\ H_1: f(v_{i, j}|H_1) = \\frac{\\sigma}{A}\\exp(-\\frac{\\sigma}{A}v_{i,j}) \\end{cases} \\tag{2.1.2} $$\n当给定虚警概率时，便可通过(2.1.2)式的$H_0$假设下的概率密度函数来计算求解出门限值，从而完成目标融合检测的任务。\n2.2. 接收相参及收发相参 记雷达站$i$所发射的波形为（假设幅度经过归一化）\n$$ s_i(t) = u(t)\\exp(j2\\pi f_0 t + j\\theta_i) $$\n其中$u(t)$为该信号的包络，$f_0$为信号的载频，$\\theta_i$为雷达站$i$的初始相位。若雷达站$i$发射波形被雷达站$j$所接收，则路程上总的延时为$\\tau_{ij}=\\tau_i+\\tau_j$，其中$\\tau_i$表示从雷达站$i$到目标的单程时间，$\\tau_j$表示从雷达站$j$到目标的单程时间。雷达站$j$所接收到的波形可表示为\n$$ r_{ij}(t) = u(t-\\tau_{ij})\\exp(j2\\pi f_0 (t-\\tau_{ij}) + j\\theta_i) $$\n若所有雷达站同时发射信号，则雷达站$j$的第$i$个通道所接收到的信号可表示为\n$$ r_{j}(t) = \\sum_{i}(n(t)+u(t-\\tau_{ij})\\exp(j2\\pi f_0 (t-\\tau_{ij}) + j\\theta_i)) \\tag{2.2.1} $$\n接收相参指的是对所有雷达站接收到的信号经过时移与相移后再做一次相参合成，即最终信号为\n$$ r(t) = \\sum_{j}\\sum_{i}(n(t) + u(t-\\tau_{ij}-\\hat{\\tau}_0)\\exp(j2\\pi f_0 (t-\\tau_{ij}) + j\\theta_i+j\\hat{\\theta}_i)) $$\n若不考虑信号对齐问题，记$n(t)$功率为$\\sigma^2$，经过接收相参后的噪声功率为$N^2\\sigma^2$，其中$N$为雷达站个数。若记$s_i(t)$的功率为$1$，则接收相参后的信号功率为$N^4$。此时的信噪比为$\\mathrm{SNR}=\\frac{N^2}{\\sigma^2}$，相比之前的$\\frac{1}{\\sigma^2}$，提高了$N^2$倍。\n若信号同时也实现了发射相参，那么(2.2.1)式可改写为\n$$ r_{j}(t) = n(t)+\\sum_{i}u(t-\\tau_{ij})\\exp(j2\\pi f_0 (t-\\tau_{ij}) + j\\theta_i) \\tag{2.2.2} $$\n重复之前的步骤可计算得到此时的信噪比$\\mathrm{SNR}=\\frac{N^3}{\\sigma^2}$，相比提高了$N^3$倍。\n2.2.1. 发射相参参数估计 为了实现前文所说的收发相参，不仅需要发射端进行精确地时延补偿和相位补偿，同时在接收端也需要进行时延与相位补偿。其中时延补偿$\\tau$与相位补偿$\\phi$便被称为相参参数。\n相参参数估计的准确与否很大程度上影响了收发相参的相参性能，若估计不当，在最坏的情况下还会降低信噪比。相参参数的估计方法主要有两种方法：峰值提取法与互相关方法。事实上还有许多超分辨率方法，但此处不予讨论。\n1. 峰值提取法 峰值提取法的基本思想是通过提取正交波形各个通道的时延差与相位差来对发射信号进行相参调整。记发射信号为（幅度经过归一化）\n$$ s_i(t)=u_i(t - \\Delta t_i)\\exp(j2\\pi f_0 (t - \\Delta t_i) + j\\theta_i) $$\n其中$u_i(t)$为信号复包络，记$r_{ij}(t)$为雷达站$j$接收到雷达站$i$发射的信号，$r_{ij}$可表示为\n$$ r_{ij}(t) = u(t-\\tau_{ij} - \\Delta t_i)\\exp(j2\\pi f_0 (t-\\tau_{ij} - \\Delta t_i) + j\\theta_i) $$\n其中$\\tau_{ij}=\\tau_i+\\tau_j$，$\\tau_i$表示雷达站$i$至目标的单程时延，$\\tau_j$表示雷达站$j$至目标的单程时延。雷达站$j$接收到的信号可表示为（假设共$M$个雷达站，且均发射接收信号）\n$$ r_j(t) = \\sum_{i=0}^{M-1}r_{ij}(t) = \\sum_{i=0}^{M-1}u(t-\\tau_{ij} - \\Delta t_i)\\exp(j2\\pi f_0 (t-\\tau_{ij} - \\Delta t_i) + j\\theta_i) $$\n通过匹配滤波可将各路正交信号分离开来，于是雷达站$j$接收到的第$i$路信号为\n$$ r_j^{(i)}(t)=\\sqrt{D_i}\\mathrm{sinc}(\\pi B (t-\\tau_{ij} - \\Delta t_i))\\exp(j\\theta_i) $$\n其中$D_i$为时宽带宽积。为了将发射信号在目标处同时同相叠加，需要雷达站$i$作一个时延补偿，记为$\\hat{\\tau}_i$。当信号同时到达目标处时，有$\\tau_i+\\hat{\\tau}_i + \\Delta t_i=\\tau_j+\\hat{\\tau}_j + \\Delta t_j$。移项后可得\n$$ \\hat{\\tau}_i - \\hat{\\tau}_j = (\\tau_j - \\tau_i) + (\\Delta t_j - \\Delta t_i) $$\n若记雷达站$0$为基准雷达站，其余雷达站均根据该雷达站进行时延相位调整，则有$0$号雷达站接收到的雷达站$i$的正交波形的峰值位于$\\tau_{i}+\\tau_0+\\Delta t_i$处，而$0$号雷达站接收到的自身回波峰值位于$\\tau_0+\\tau_0+\\Delta t_0$处，两者峰值的时延差$\\Delta t_{p,i0}^{(0)}$即为\n$$ \\Delta t_{p,i0}^{(0)} = \\hat{\\tau}_i - \\hat{\\tau}_j = \\tau_i - \\tau_0 + (\\Delta t_i - \\Delta t_0) \\tag{2.2.3} $$\n$\\Delta t_{p,i0}^{(0)}$的上标$(0)$表示$0$号雷达站所接收到的回波，下标$p$表示峰值，$i0$表示雷达站$i$的正交波形与雷达站$0$的正交波形。(2.2.3)式表明，为了使信号在目标处实现发射相参，只需要根据正交波形的延时差进行校正即可。\n对于相位的推导过程是同理的，为了使发射信号在目标处实现发射相参，只需要根据正交波形峰值处的相位差来校正即可。\n2. 互相关法 互相关法的前期处理与峰值提取法相同，不同之处在于，峰值提取法是通过提取各通道正交波形的峰值处的时间差与相位差来获得相参参数的，而互相关法是直接对这两路信号作一个互相关，互相关结果的峰值所对应的时间便是需要补偿的时间差，所对应相位即是所需要补偿的相位差。\n互相关法的本质是将峰值提取转换为了互相关操作，因此互相关法要求正交波形之间的正交性良好，否则不能得到一个较好的结果。记$r_j^{(i)}(t)$为匹配滤波后的结果，则将雷达站$0$接收到的信号通道中，其本身所对应的正交波形与雷达站$i$所对应的波形作互相关可得\n$$ A(t) = r_{i}^{(0)}(t) * r_{i}^{*(i)}(-t) $$\n$A(t)$的峰值所对应的时间便是雷达站$i$与雷达站$0$所需要补偿的时延差，峰值所对应的相位便是雷达站$i$与雷达站$0$所需要补偿的相位差。\n3. MUSIC超分辨率方法 4. 相位测距方法 相位测距方法的基本原理是，距离的细小变化都会引起相位的较大变化，因此可以通过相位来反推出更加精细的距离信息。但相位的取值仅在$[0, 2\\pi]$，因此相位测距方法的关键在于解模糊。\n(TODO)\n2.2.2. 接收相参参数估计 1. 接收相参参数的有偏估计 当对发射信号作了发射相参后，信号将在目标处同相叠加，理论上来讲，发射相参性能仅与正交波形的测量的精确程度与发射校正精度有关，但接收相参却不同于发射相参。通过相参校正后，接收相参参数是一个有偏估计，即估计本身便带有一定的误差。\n假设叠加后目标处的信号为$s_t(t)$，可写为\n$$ \\begin{align*} s_t(t) =\u0026amp; \\sum_{i=0}^{M-1}u(t-\\tau_{i} - \\Delta t_i - \\Delta t_{p,i0}^{(0)})\\exp(j2\\pi f_0 (t-\\tau_{i} - \\Delta t_i - \\Delta t_{p,i0}^{(0)}) + j\\theta_i + j\\hat{\\theta}_i) \\\\ =\u0026amp; Mu(t-\\tau_{0} - \\Delta t_0)\\exp(j2\\pi f_0 (t-\\tau_{0} - \\Delta t_0) + j\\theta_0) \\end{align*} $$\n其中$\\hat{\\theta}_i$为发射补偿的相位。记雷达站$i$接收到的信号为$r_i(t)$，则有\n$$ \\begin{align*} r_i(t) = Mu(t-\\tau_{0i} - \\Delta t_0 + \\Delta t_i)\\exp(j2\\pi f_0 (t-\\tau_{0i} - \\Delta t_0 + \\Delta t_i) + j\\theta_0 - j\\theta_1) \\end{align*} $$\n若使用先前所使用的发射相参参数进行调整，可以发现，雷达站$i$的接收信号为\n$$ \\begin{align*} r_i(t) = Mu(t-2\\tau_{0} - 2\\Delta \\hat{t}_t)\\exp(j2\\pi f_0 (t-2\\tau_{0} - 2\\Delta \\hat{t}_t) + j2\\Delta \\hat{\\theta}_i) \\tag{2.2.4} \\end{align*} $$\n其中$\\Delta \\hat{t}_i = \\Delta t_0 - \\Delta t_i$，$\\Delta \\hat{\\theta}_i = \\theta_0 - \\theta_i$。\n(2.2.4)式意味着，接受相参的相参结果的好与差同各雷达站之间的信号同步误差有关，且接收相参误差为各雷达站信号同步误差的两倍。因此，从上述讨论中可以看出，使用先前发射相参的参数进行接收相参参数估计是一个有偏估计。\n2. 使用频率步进信号来提高接收相参性能 北理工团队提出一种使用频率步进信号来合成高分辨率信号的方法。该方法首先发射正交波形得到相参参数的估计值，随后发射频率步进信号进行发射与接收相参。接收端接收到信号后，首先将频率步进信号作接收相参，随后再对慢时间维上的频率步进信号间作一个相参积累。这样便可得到较高质量的接收相参结果。\n为了方便对比，首先来对单一的线性调频信号作仿真，记发射信号为$s(t)$\n$$ s(t) = u(t)\\exp(j2\\pi f_0 t + j\\pi \\mu t^2) $$\n其中$u(t) = \\mathrm{rect}(\\frac{t}{T})$，$\\mu=\\frac{B}{T}$，$T$为脉冲宽度，$B$为信号带宽。当两个接收信号有一个微小的时间差$\\Delta t$时，由于线性调频信号脉冲压缩后具有窄的波束宽度，微小的时间差会导致结果无法对齐而失去接收相参的效果，仿真结果如下所示\n图2.2.1：线性调频信号的接收误差\r其中，蓝色与红色线分别表示各雷达站接收信号，黄色线表示最终合成信号。若使用频率步进信号，并且最终合成一个等效带宽的信号的话，结果将会得到很大地改善，这是因为每个子信号的带宽较小，从而具有较宽的波束宽度，因此对接收相参误差不敏感。\n假设有10个子信号，每个信号的带宽为$\\frac{B}{10}$，则每个子信号的接收相参效果如下所示\n图2.2.2：线性调频信号的接收误差\r可以看到，频率步进信号的子信号对时延误差并不敏感，因此可将采样后的子信号峰值看作均位于同一个采样点。然后将每个子信号作一个相参积累，合成得到最终的信号，最终结果如下所示。\n图2.2.2：线性调频信号的接收误差\r从图中可以看到，使用步进频率合成等效宽带信号最终接收相参后的信号幅度大于直接使用线性调频信号得到的结果，这意味着使用步进频率信号将具有更好的鲁棒性，具有更好的噪声容忍性。通过计算可得，直接使用线性调频信号得到的信噪比增益约为$\\mathrm{1dB}$，而使用步进频率得到的信噪比增益可达到$\\mathrm{2dB}$。这证明了步进频率信号在接收相参上的优越性。\n2.2.3. 相参参数估计误差影响 本节主要讨论相参参数估计误差对最终相参结果的影响，从形式上看，相参参数的估计误差将导致发射与接收相参时不能完美对准波形，从而导致性能损耗。\n1. 发射相参效率讨论 若记发射信号为\n$$ s_0(t)=u(t)\\exp(j2\\pi f_0 t + j\\phi\u0026rsquo;_i) $$\n其中$u(t)$为其包络，$f_0$为其载频大小。则在空间中某处的信号为（假设幅度已经过归一化）\n$$ s_1(t) = u(t-\\tau_1)\\exp(j2\\pi f_0 (t-\\tau_1) + j\\phi\u0026rsquo;_i) $$\n其中$\\tau_1=\\frac{R_1}{c}$，$R_1$表示第一个雷达站至目标的距离。若有多个雷达发射站发射信号，并在目标处叠加，则合成后的信号为\n$$ s_A(t) = \\sum_{i=1}^{N}u(t-\\tau_i)\\exp(j2\\pi f_0 (t-\\tau_i) + j\\phi\u0026rsquo;_i) \\tag{2.2.5} $$\n目前已经有大量的研究关于分布式全相参雷达的相参补偿，以使发射信号在目标处产生同相叠加，记雷达$i$的时移和相位补偿分别为$t_i$与$\\phi_i$，则有\n$$ s_A(t) = \\sum_{i=1}^{N}u(t-\\tau_i-t_i)\\exp(j2\\pi f_0 (t-\\tau_i-t_i) + j\\phi\u0026rsquo;_i + j\\phi_i) $$\n对于慢时间维上的包络$u(t)$而言，可以近似有\n$$ \\tau_1+t_1\\approx\\tau_2+t_2\\approx\u0026hellip;\\approx\\tau_N+t_N $$\n将其代入(2.2.5)式可得\n$$ s_A(t) = u(t-\\tau_1-t_1)\\sum_{i=1}^{N}\\exp(j2\\pi f_0 (t-\\tau_i-t_i) + j\\phi\u0026rsquo;_i+j\\phi_i) $$\n记$\\tau'_i=\\tau_i+t_i$，发射信号在目标处的能量为\n$$ \\begin{align*} E_s =\u0026amp; \\int_{-\\infty}^{+\\infty}s_A(t)s_A^*(t)\\mathrm{d}t \\\\ =\u0026amp; \\int_{\\tau_1+t_1}^{\\tau_1+t_1+T_r}\\sum_{i=1}^{N}\\exp(j\\phi_i-j2\\pi f_0\\tau_i\u0026rsquo;)\\sum_{i=1}^{N}\\exp(-j\\phi_i+j2\\pi f_0\\tau_i\u0026rsquo;) \\mathrm{d}t \\\\ =\u0026amp; T_r\\sum_{i=1}^{N}\\sum_{k=1}^{N}\\exp(j(\\phi\u0026rsquo;_i+\\phi_i-(\\phi\u0026rsquo;_k + \\phi_k))-j2\\pi f_0 (\\tau_i\u0026rsquo;-\\tau_k\u0026rsquo;)) \\\\ =\u0026amp; T_r\\sum_{i=1}^{N}\\sum_{k=1}^{N}\\exp(j\\Delta \\phi_{ik}\u0026rsquo;-j2\\pi f_0 \\Delta \\tau_{ik}\u0026rsquo;)\\tag{2.2.6} \\end{align*} $$\n其中$\\Delta \\phi_{ik}'=\\phi'_i+\\phi_i-(\\phi'_k + \\phi_k)$，$\\Delta \\tau_{ik}' = \\tau_i'-\\tau_k'$。接下来作相关仿真，若不考虑相位同步误差，即$\\Delta \\phi_{ik}'=0$，则(2.2.6)式可写为\n$$ E_s = T_r\\sum_{i=1}^{N}\\sum_{k=1}^{N}\\exp(-j2\\pi f_0 \\Delta \\tau_{ik}') $$\n定义相关发射相参效率为$\\eta$\n$$ \\eta = \\frac{\\sum_{i=1}^{N}\\sum_{k=1}^{N}\\exp(-j2\\pi f_0 \\Delta \\tau_{ik}')}{N^2} $$\n设置仿真条件为$N=2$，则可得到不同时间同步误差下的相参效率如下所示\n图2.2.3：发射相参性能随时间同步误差变化\r其中横坐标为归一化的距离误差，当取1时表示时间同步误差带来的距离误差为一个波长长度。当分布式多雷达站时，发射相参性能与时间同步误差的关系仍然可通过上图得到。从上图可以看到，当距离误差约0.2波长时，发射相参效率降低$\\mathrm{3dB}$。这意味着，如果要得到较好的发射相参性能，需要控制发射相参的距离误差在波长级才能完成。\n当不考虑时延误差时，(2.2.6)式可写为\n$$ E_s = T_r\\sum_{i=1}^{N}\\sum_{k=1}^{N}\\exp(j\\Delta \\phi'_{ik}) $$\n同理可得到发射相参效率为\n$$ \\eta = \\frac{\\sum_{i=1}^{N}\\sum_{k=1}^{N}\\exp(j\\Delta \\phi'_{ik})}{N^2} $$\n观察可以发现上式与时间同步误差的发射相参性能评估公式在结构上是一致的，因此仿真当$N=2$时的结果如下\n图2.2.4：发射相参性能随相位同步误差变化\r从上图可知，当相位误差为$0.1\\times 2\\pi$之内时，发射相参效率损失小于$\\mathrm{1dB}$；当相位误差小于$0.2\\times 2\\pi$时，发射相参效率损失小于$\\mathrm{3dB}$。\n2. 接收相参效率讨论 接收相参与发射相参的讨论本质上是一致的，不同之处在于，接收相参需要考虑接收机噪声问题。平稳高斯白噪声的加减、时移、相移并不改变噪声的统计性质，因此在进行接收相参时，只需要考虑噪声的功率变化即可。\n当$N$个接收站作接收相参时，目标信号功率提高$N^2$倍，与此同时，噪声功率提高$N$倍，因此信噪比提高$N$倍。当没有完美接收相参时，噪声功率仍然为$N$倍，但信号功率则会降低。因此此时衡量接收相参效率的公式与衡量发射相参效率时的公式是类似的。不同之处在于，衡量接收相参时，还需要考虑到各个雷达站自身所带有的相位误差或者时间同步误差。\n由(2.2.4)式可得，接收相参的参数误差为原本各雷达站自身误差的两倍。模仿(2.2.6)式的推导，可以得到接收相参后信号的能量为\n$$ \\begin{align*} E_s = T_r\\sum_{i=1}^{N}\\sum_{k=1}^{N}\\exp(j2\\Delta \\phi_{ik}'-j4\\pi f_0 \\Delta \\tau_{ik}')\\tag{2.2.7} \\end{align*} $$\n注意，上式基于发射完美相参的基础上，上式中的$\\Delta \\phi_{ik}'$与$\\Delta \\tau_{ik}'$与(2.2.6)式中的不同，指代的是各个雷达站之间的时间与相位同步误差。\n2.2.4. 另一种衡量发射相参性能的方法：相参景深 有许多文献针对发射相参性能进行了讨论，其中有一个有意思概念是相参景深概念。这个概念的名字来源于摄影领域，是指在摄影机镜头或其他成像器前沿能够取得清晰图像的成像所测定的被摄物体前后距离范围。分布式雷达的发射相参过程事实上可以看作摄像机的聚焦过程，对空间中某个点进行发射相参后，在该点周围的一定范围内都将有较好的发射相参效率。接下来从公式角度推导。\n重新考虑(2.2.6)式，将其稍微改写一下，可以得到（为了方便，不妨假设$\\tau_1\u0026rsquo;=0$）\n$$ \\begin{align*} E_s =\u0026amp; \\int_{0}^{T_r}\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\exp(-j2\\pi\\mu t(\\tau_i'-\\tau_j')-j2\\pi f_0 (\\tau_i'-\\tau_k')+j\\pi \\mu (\\tau_i'^2-\\tau_j'^2)+j(\\phi_i-\\phi_j))\\mathrm{d}t \\\\ =\u0026amp; T_r\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\exp(-jk\\frac{T_r}{2}-j2\\pi f_0\\Delta\\tau_{ij}')\\mathrm{Sa}(k\\frac{T_r}{2})\\exp(j\\pi \\mu (\\tau_i'^2-\\tau_j'^2)+j(\\phi_i-\\phi_j)) \\\\ =\u0026amp; T_r(N+2\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\cos(-\\frac{kT_r}{2}-j2\\pi f_0\\Delta{\\tau_{ij}'}+\\pi\\mu(\\tau_i'^2-\\tau_j'^2)+\\Delta\\phi_{ij})\\mathrm{Sa}(k\\frac{T_r}{2})) \\\\ =\u0026amp; T_r(N+2\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\cos(-2\\pi(f_0+\\frac{B}{2})\\Delta{\\tau_{ij}'}+\\pi\\mu(\\tau_i'^2-\\tau_j'^2)+\\Delta\\phi_{ij})\\mathrm{Sa}(k\\frac{T_r}{2})) \\end{align*} $$\n其中$k=2\\pi\\mu\\Delta{\\tau_{ij}'}$，$\\Delta\\tau'{ij}=(\\tau_i'-\\tau_j')$，$\\Delta\\phi{ij}=\\phi_i-\\phi_j$，$B=\\mu T_r$。由于前文已经假设$\\tau_1'=0$，因此上式中的二阶量可以忽略，即$\\pi\\mu(\\tau_i'^2-\\tau_j'^2)\\approx0$，于是上式可化为\n$$ E_s = T_r(N+2\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\cos(-2\\pi(f_0+\\frac{B}{2})\\Delta{\\tau_{ij}'}+\\Delta\\phi_{ij})\\mathrm{Sa}(\\pi B \\Delta \\tau_{ij}')) $$\n于是发射相参效率有\n$$ \\eta = \\frac{N+2\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\cos(-2\\pi(f_0+\\frac{B}{2})\\Delta{\\tau_{ij}'}+\\Delta\\phi_{ij})\\mathrm{Sa}(\\pi B \\Delta \\tau_{ij}')}{N^2} $$\n本节不考虑除了路程导致的各发射信号相位不同步问题，因此$\\Delta \\phi_{ij}=0$，于是有\n$$ \\eta = \\frac{N+2\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\cos(2\\pi(f_0+\\frac{B}{2})\\Delta\\tau_{ij}')\\mathrm{Sa}(\\pi B \\Delta \\tau_{ij}')}{N^2} \\tag{2.2.8} $$\n记$\\Delta\\tau_{ij}^{(0)}$表示雷达站$i$与$j$至目标$0$的时延差。现假设该分布式相参雷达系统对空间中某一标定点$P_0(x_0, y_0)$已实现精准时间、相位校正，即对于该点$\\Delta\\tau_{ij}^{(0)}=0$。对于空间中另一点$P_1(x_1,y_1)$存在一个由于路程差导致的时延差$\\Delta\\tau_{ij}^{(1)}$，假设雷达站$i$至目标$j$的距离为$R_{ij}$，因此有\n$$ R_{i1}-R_{j1}=c\\Delta\\tau_{ij}^{(1)} + (R_{i0}-R_{j0}) $$\n这意味着，当只考虑两个雷达站时，空间中具有相同延时的地方构成一个双曲面。根据(2)式，假设$B$与$f_0$呈一定的整倍数关系，并且$f_0 \\gg B$，则空间中具有相同发射相参增益的位置应当满足$\\Delta\\tau_{ij}'\\approx\\frac{k}{f_0}$，其中$k$为一个整数。上述意味着，发射相参增益的变化具有空间周期性，当不考虑天线方向图调制时，满足下式的位置处具有最大增益\n$$ R_{i1}-R_{j1}=k\\lambda + (R_{i0}-R_{j0}) \\tag{2.2.9} $$\n其中$k$为一个整数。\n当信号为一个窄带信号时，可将带宽$B$看作远小于$f_0$，同时为了方便，仅考虑(2.2.8)式中的求和项，可得\n$$ \\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\cos(2\\pi f_0 \\Delta\\tau_{ij}') \\tag{2.2.10} $$\n各个雷达站至目标的距离可写为如下公式\n$$ R_{ij} = \\sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2} $$\n当目标的横坐标$x$远大于$y$时，各个雷达站至目标的距离差可作如下近似\n$$ \\begin{align*} R_{ij} - R_{kj} =\u0026amp; \\sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2} - \\sqrt{(x_k-x_j)^2+(y_k-y_j)^2+(z_k-z_j)^2} \\\\ \\approx \u0026amp; C + \\frac{(y_i-y_j)^2}{2(x_i-x_j)}-\\frac{(y_k-y_j)^2}{2(x_k-x_j)} + \\frac{(z_i-z_j)^2}{2(x_i-x_j)}-\\frac{(z_k-z_j)^2}{2(x_k-x_j)} \\end{align*} $$\n其中$C$为一个常数。观察上式可以发现，当目标处于充分远的位置时，横坐标上的变动对距离差几乎没有影响。对上式取微分可得\n$$ \\Delta(R_{ij}-R_{kj})=(\\frac{y_k-y_j}{x_k-x_j}-\\frac{y_i-y_j}{x_i-x_j})\\Delta y_j + (\\frac{z_k-z_j}{x_k-x_j}-\\frac{z_i-z_j}{x_i-x_j})\\Delta z_j $$\n这意味着发射相参增益的空间周期随纵坐标的改变而改变，发射相参增益的变化周期随纵坐标的增大而增大。若不考虑$\\Delta z_j$，$\\Delta\\tau_{ik}'$可写为\n$$ \\Delta\\tau_{ik}'=\\frac{\\Delta(R_{ij}-R_{kj})}{c}=\\frac{\\Delta y_j}{c}(\\frac{y_k-y_j}{x_k-x_j}-\\frac{y_i-y_j}{x_i-x_j}) $$\n当$x_j=\\mathrm{100000m}, x_k=\\mathrm{0}, x_i=\\mathrm{250m}, y_k=y_i=0,y_j=\\mathrm{4000m}$时，$\\Delta y_j$需达到$\\mathrm{1500m}$才会使得$\\Delta\\tau_{ij}'$变化半个周期。当对相参效率进行估计时，可作一个非紧致估计，即取$\\Delta\\tau_{ik}'$为最坏的估计情况，并将此最坏的估计情况作为发射相参空间的估计。\n当信号为一个宽带信号时，与上述分析同理，可以看成上述公式被一个$\\mathrm{Sa}$函数调制，将$\\mathrm{Sa}$函数的主瓣所对应的各个峰值称为主要极大值，简称主极大。\n当目标纵坐标远大于横坐标时，与上述分析同理。当目标纵坐标与横坐标相近，但均远大于高度时，可看作上述所分析的发射相参增益空间分布关于标定点$P_0$作一个旋转，因此也是同理的。\n当目标处于较近的位置时，即横坐标、纵坐标与高度的数量级相近时，情况会变得更加复杂。此时可直接对上式距离差$R_{ij}-R_{kj}$作一个微分，可得到\n$$ \\begin{align*} \\Delta(R_{ij}-R_{kj}) = \u0026amp;\\frac{(x_i-x_j)\\Delta x+(y_i-y_j)\\Delta y + (z_i-z_j)\\Delta z}{R_{ij}} \\\\ \u0026amp;-\\frac{(x_k-x_j)\\Delta x+(y_k-y_j)\\Delta y + (z_k-z_j)\\Delta z}{R_{kj}} \\tag{2.2.11} \\end{align*} $$\n通常而言，若分布式雷达系统是线阵分布，则相参景深在线阵分布的轴向上不敏感；若分布式雷达系统是面阵分布，则相参景深在面阵法向上不敏感；若分布式雷达系统在空间中分布，则相参景深在空间中呈现一个点。\n接下来对相参景深进行仿真，首先仿真窄带情况，四个雷达站的位置如下所示\n表2.2.1：仿真雷达站方位\r雷达站编号 x(km) y(km) z(km) 0 0 0 0 1 40 0 0 2 20 20$\\sqrt 3$ 0 3 40 10$\\sqrt 3$ 0.3 假设标定点$P_0$位于$[50.05\\mathrm{km}, 0, 4\\mathrm{km}]^T$处，各雷达站载频为$f_0=\\mathrm{1GHz}$，带宽为$B=\\mathrm{1MHz}$\n图2.2.5：近场窄带发射相参景深\r观察发现，当分布式雷达站基线长度为数十千米数量级时，标定点方位可看作处于近场，此时的发射相参景深为一系列空间中周期分布的点。当雷达站发射信号为宽带信号时，如$B=\\mathrm{500MHz}$，空间中的发射相参景深作用可看作窄带情况下叠加了一个$\\mathrm{Sa}$函数调制，如下所示\n图2.2.6：近场宽带发射相参景深\r可以看到，宽带、近场情况下，空间中的发射相参景深可看作一个非常细小的点，这从另一方面证明了发射相参精度需要有很高要求。事实上，分布式相参雷达的提出是为了扩展原本雷达的探测范围的，因此分布式相参雷达通常工作于远场环境，接下来仿真远场时的发射相参景深。假设标定点位于$P_0=[500.05\\mathrm{km}, 0, 4\\mathrm{km}]^T$处，并且各雷达站发射窄带信号，空间中的发射相参景深如下所示\n图2.2.7：远场窄带发射相参景深\r可以看到，远场情况下，发射相参景深在线阵轴向方向上的变化不敏感，而在垂直于轴向方向上的变化较为敏感。当发射信号为一个宽带信号时，同理可以将空间上的发射相参景深看作被一个$\\mathrm{Sa}$函数调制而成，宽带信号的仿真结果如下所示\n图2.2.8：远场窄带发射相参景深\r2.3. 雷达站时间及相位同步 从上一节的分析中可以发现，如果要提高系统的接收相参性能，需要提高各雷达站之间的相参同步精度，而目前有许多种时延与相位参数同步方式，从传输媒介来分类可分为无线同步与有线同步。根据《地基分布式相参雷达技术研究综述》一文，无线同步通常是指通过各雷达站之间互相发射波形来进行时间相位同步或者通过卫星进行实时授时来达到相位与时间同步，有线同步方法通常是指基于射频的同步技术或者基于光纤的同步技术。从同步方式来分类可以有主从式同步方法与分布式同步方法，主从式同步方法指的是通过一个主雷达站向其它从雷达站发射相关信号进行同步，而分布式同步方法指的就是去除了主雷达站，各个雷达站之间相互进行相参参数同步。\n2.3.1. 分布式同步方法 根据《天基分布式雷达相位估计与同步方法》一文，分布式同步方法中的循环往返相位同步方法可参考下图，本节仅考虑相位与频率的同步方法。\n图2.3.1：循环往返相位同步方法\r假设雷达站$0$向雷达站$1$的发射波形为\n$$ s_{0, 1}(t) = u(t)\\exp(j2\\pi f_0 t + j \\phi_0) $$\n雷达站$1$接收到的信号为\n$$ r_{0, 1}(t) = u(t-\\tau_{0,1})\\exp(j2\\pi f_0 (t - \\tau_{0,1}) + j \\phi_0 + j\\phi^{s}_{0,1}) $$\n为了更严谨地表述，上式中$\\phi^{s}_{0,1}$表示由路径带来的相位误差。雷达站$1$接收到信号之后根据捕获到的频率与相位来对自身进行调整，随后由雷达站$1$发射信号给雷达站$2$，如此反复，直到雷达站$K$发射信号至雷达站$0$。同时为了得到更高的相位与频率同步性能，按照图2.3.1的同步流程逆时针同步一遍，即从雷达站$0$发射信号至雷达站$K$，雷达站$K$发射信号至雷达站$K-1$，\u0026hellip;\u0026hellip;，雷达站$1$发射信号至雷达站$0$。\n(PS: 这部分内容论文中写得较为简略，我还没理解这部分的全部原理)\n3. 协同探测区域 由于分布式全相参雷达同样属于协同探测领域，而为了使多个雷达站之间工作的条理性，有必要划分一个协同探测区域。当协同探测区域在空间中扫描时，各雷达站对准该协同探测区域来获得信噪比增益。关于协同探测区域的划分方法有许多，主要是基于天线的半功率宽度来划分协同探测区域，即两雷达站的半功率波束宽度在空间中所交成的空间记为一个协同探测区域。由于半功率波束在空间中是一个圆锥形状，当雷达站较多时，各雷达站的半功率波束交集可近似看作一个球，因此空间中的协同探测区域划分通常是通过划分为一个个球来实现的。\n当划分完空间协同探测区域后，就需要考虑各雷达站在协同探测区域中的探测问题了。由于半功率波束宽度通常宽于距离分辨率，因此一个协同探测区域通常占据了雷达站多个距离单元。考虑如何对协同探测区域进一步划分多个协同探测单元是有必要的。划分方法主要有两种，一种是基于方形栅格划分法，另一种是基于空间分辨单元划分法。\n3.1. 基于方形栅格划分 基于方形栅格划分方法可以看作是根据原本划分好的协同探测单元来反推出各雷达站中的距离门号。因此一个协同探测单元可能包含多个距离门。划分方法如下所示（图来自郭凯德《组网雷达协同探测技术研究》）\n图3.1：方形栅格划分方法\r将一个协同探测单元划分为一个个的方形单元，因此对于各个雷达站的考虑仅需要在此方形单元的基础上考虑便可，优点便是考虑方便，而缺点便是会丢失一定的精度，因为一个方形单元中可能包含多个距离采样点。\n3.2. 基于空间分辨单元划分 方形栅格划分方法是在空间中划分出区域，随后通过区域反推出各雷达站的距离门号。当然也有另外的一种划分方法，可以考虑雷达站的各个距离门在空间中所交成的空间，随后利用这些交成的空间对协同探测区域进行划分，划分方法如下所示（图来自郭凯德《组网雷达协同探测技术研究》）\n图3.2：空间分辨单元划分方法\r这种方法与前述方法不同之处在于很好地保留了各雷达站的精度，但相对的，当雷达站个数上升时，协同探测单元的个数将指数级上升。因此在较多雷达站协同探测时，通常不采用这种方法。\n4. 资源分配问题 5. 信号相干问题 当各雷达站满足大基线、稀疏布阵、高分辨率等特点时，就需要考虑雷达站接收回波信号的相干问题，这意味着接收相参时将不能使用简单的同相叠加方法来获得较好地相参增益。\n使用FEKO对其内置的一个直升机模型进行各散射角的一维距离像仿真可得到，不同角度的一维距离像如下所示\n图5.1：不同角度的直升机一维距离像\r可以看到，此时回波信号已经失去了相干性，接收相参与发射相参将会变得较为复杂。事实上刘宏伟在《网络化雷达协同探测》文章中给出了各雷达站回波信号间去相关的条件，如下所示\n$$ \\frac{f_ed_t}{c} \\ge \\frac{1}{2} $$\n其中$f_e=\\sqrt{\\Delta f^2 + f_0(f_0+\\Delta f)\\sin(\\frac{\\Delta \\Psi}{2})}\\cos(\\frac{\\Delta \\alpha}{2})$，$c$为光速，$d_t$为目标尺寸，$f_0$为载频，$\\Delta f$为两接收通道之间的工作频率差，$\\Delta \\Phi$表示接收通道观测时间间隔内目标转动的角度间隔，$\\Delta \\alpha$表示两接收通道观测目标的角度差。\n当不考虑各雷达站之间的频率差异与目标转动问题时，上式便可写为\n$$ f_e = f_0\\sin(\\frac{\\Delta \\alpha}{2}) $$\n这意味着，当分布式雷达站之间的距离相差较远时，公式中$\\Delta \\alpha$较大，雷达回波已经去相干了，因此在这种情况下的接收相参问题将会变得比较复杂。\n6. 个人理解 6.1. 复杂目标的发射相参性能评估问题 目前有大量的文献讨论了分布式相参雷达的发射相参性能评估问题，文献中指出，如果需要得到较好的发射相参性能，需要将发射相参误差控制在波长级别。但在这些文献中都把一个复杂目标近似成了一个点目标，我认为这是不合理的。虽然理论与工程的大量实践证明可以将复杂目标近似为一个点目标，然后分别对点目标进行考虑，但这些都基于一个假设：电磁响应在各个点目标处几乎是一致的。发射相参问题由于需要波长级别的精度，因此各个点目标处的发射相参性能是不同的，所以不能对这些点目标进行一概讨论。 吴剑旗院士的《一种大基线分布雷达近场相参探测技术》中指出可以通过精细划分距离单元来提高收发全相参的性能。对于单个采样点来考虑的话是正确的，但是当面临一个复杂扩展目标时，这种评估就有失分寸了。假设空间中存在一个标定点$P_0$，并且分布式相参雷达对于这个标定点而言是能够实现完美发射相参的。对于一个复杂扩展目标而言，假设可以近似为$P_1$，$P_2$，\u0026hellip;\u0026hellip;，$P_N$一系列散射点，可能在其中一部分散射点$P_{i1}$，$P_{i2}$，\u0026hellip;\u0026hellip;，$P_{ia}$处达到较好的发射相参性能，而在其中一部分散射点处$P_{j1}$，$P_{j2}$，\u0026hellip;\u0026hellip;，$P_{jb}$处不能达到较好的发射相参性能，于是只能在接收机的某个采样点处达到较好的性能，但从该目标的总体能量来说，并不能达到较好的结果。 王元昊的《分布式相参雷达相参效率及相参景深研究》中引入了“相参景深”概念来评估发射相参性能问题，文中给出了空间中某点发射相参性能评估的公式如下（恰是(2.2.8)式）\n$$ \\eta = \\frac{N+2\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\cos(2\\pi(f_0+\\frac{B}{2})\\Delta\\tau_{ij}\u0026rsquo;)\\mathrm{Sa}(\\pi B \\Delta \\tau_{ij}\u0026rsquo;)}{N^2} $$\n在一个目标的尺寸中，发射相参性能可能产生了剧烈的变化，此时显然不能直接使用点目标公式来进行讨论分析，如果仿照上式，便可得到对于一个复杂目标的发射相参性能评估公式应当如下所示\n$$ \\begin{align*} \\eta =\u0026amp; \\frac{\\sum_{m=1}^{M}\\sigma_{m}N + 2\\sum_{m=1}^{M}\\sigma_{m}\\sum_{i=1}^{N-1}\\sum_{k=i+1}^{N}\\cos(2\\pi(f_0+\\frac{B}{2})\\Delta{\\tau_{ik}\u0026rsquo;}^{(m)})\\mathrm{Sa}(\\pi B \\Delta {\\tau_{ik}\u0026rsquo;}^{(m)})}{\\sum_{m=1}^{M}\\sigma_{m}N^2} \\\\ =\u0026amp; \\frac{\\sum_{m=1}^{M}\\sigma_{m}N + 2\\sum_{m=1}^{M}\\sigma_{m}\\sum_{i=1}^{N-1}\\sum_{k=i+1}^{N}E(\\Delta t_{ik})}{\\sum_{m=1}^{M}\\sigma_{m}N^2}\\tag{6.1} \\end{align*} $$\n6.2. 复杂目标的发射相参标定点选取问题 传统方法中通常是选取回波幅度最大的点作为发射相参标定点进行标定。对飞机进行建模，并且使用上述公式进行仿真验证，通过穷举法得到最佳的发射相参增益标定点。两者比较可以发现，回波幅度最大的点并不一定是最优的发射相参增益标定点，两者偶尔可差两倍之多。但通过目标来计算最佳发射相参标定点是不现实且效率低下的。并且目标处于运动状态，而标定点选取通常在波长级别，两者并不能很好地耦合。\n6.3. 研究方向的一些猜测 6.3.1. 使用一种新型的空间扫描方式 通过前几节的分析可知复杂目标的发射相参点选取是一个比较困难的问题，同时由于现实世界中的目标通常是一个运动的复杂目标，因此实时地根据正交回波来调整发射相参标定点是一件不现实的事情。再者，由于分布式全相参雷达提出的初衷便是增加探测距离，而使用正交波形来估计相参参数的话，又回到了原点，仍然无法超越现有的MIMO雷达探测距离。\n因此，我认为，可以从调整各雷达站之间相对于标定点的时延与相位同步差值来实现分布式相参雷达在协同探测区域中的空间扫描。换言之，用调整时延与相位来扫描协同探测区域，来替代现有的通过正交波形来获得相关相参参数。\n接下来进行详细地讨论，假定各雷达站方位如表6.3.1所示，并且假定各雷达站对于空间中某点$P_0$已实现完美发射相参（事实上$P_0$是不可知的，因为我们并没有进行正交波形的发射相参调整，但空间中确实存在这样的一个点$P_0$），如下所示（假设$P_0$位于$[500.05\\mathrm{km}, 0, 4 \\mathrm{km}]^T$）\n表6.3.1：仿真雷达站方位\r雷达站编号 x(km) y(km) z(km) 0 0 0 0 1 40 0 0 2 20 20$\\sqrt 3$ 0 3 40 10$\\sqrt 3$ 0.3 图6.3.1：标定点附近的相参景深\r可以看到的是，在空间中$[500.05\\mathrm{km}, 0, 4 \\mathrm{km}]^T$附近的点具有较高的发射相参性能，接下来我们调整各个雷达站之间的相位差值，例如将3号雷达站的相位提前$\\frac{\\pi}{3}$，可以得到如下结果。可以明显看到，在同一高度下，空间中的发射相参景深明显的移动了。\n图6.3.2：调整后相位后的相参景深\r若将1号雷达站与2号雷达站的相位分别提前$\\pi$与$\\frac{\\pi}{2}$，可以发现此时的相参效率较高点并不处于$\\mathrm{4km}$高度，而是变成了$\\mathrm{4.174km}$。上述仿真结果意味着通过调节相位来对空间进行扫描是可行的。\n观察上述结果可以发现，当调节相位时，相参景深通常在横坐标上平移，而当调节各雷达站的发射时延时，发射景深将在纵坐标上作平移，如下所示（当2号雷达站延时$\\mathrm{2.823ns}$，3号雷达站延时$\\mathrm{1.308ns}$时）\n图6.3.3：调整后时延后的相参景深\r从上述讨论可以发现，通过调节各雷达站之间的相位与时间差值来实现在空间中的扫描是可行的，这意味着并不需要发射正交波形来获得先验相参参数信息，而只需要获得一个大概的相参参数，随后通过调整时间与相位差值来对空间扫描即可。不过上述空间扫描方法需要注意的一个点在于，发射波形应当同时到达目标处，这意味着时延估计精度仅需要达到“大约同时到达目标处”即可，大大降低了时延估计精度要求。\n","permalink":"https://bingsz.github.io/en/posts/radarsummary1/","summary":"\u003cp\u003e  分布式全相参雷达论文阅读笔记（一）。主要内容有：基于模值的信号级融合检测，收发相参的同步方法，利用频率步进信号提高接收相参性能，相参参数估计误差影响分析和协同探测区域划分方法。\u003c/p\u003e","title":"分布式全相参雷达论文阅读笔记（一）"},{"content":" 相参景深这一概念在《分布式相参雷达相参效率及相参景深研究》中提出，这一概念是从发射相参增益在空间中的分布入手的。当各个雷达站对于空间中某点实现了完美发射相参（即时延和相位上同时完美对齐）后，该点周围的空间均可以获得一个较高的发射相参增益。大多数文献在衡量发射相参增益时，都是从时域入手的，而这一概念从空域入手研究的。\n假设雷达站$i$发射的信号为$s_i(t)$，信号表达式如下所示\n$$ s_i(t) = u_i(t)\\exp(j2\\pi f_0 t+j\\phi_i) $$\n其中$f_0$为信号载频，$u_i(t)$为雷达站$i$发射的波形包络。各个雷达站的发射在空间中某点$P$叠加后，可表示为\n$$ s(t) = \\sum_{i=1}^{N}s_i(t) = \\sum_{i=1}^{N}u_i(t - \\tau_{iP})\\exp(j2\\pi f_0 (t - \\tau_{iP})+j\\phi_i) $$\n其中$\\tau_{iP}$表示雷达站$i$至点$P$的单程时延，$N$为雷达站个数。事实上上式作了一个近似，将电磁波传播路径中的大气折射等因素忽略了。这导致在后续的分析中，空间中某点的相位关系仅与路程有关。通常来说这种近似是合理的，因为目标通常距离较远，而各雷达站之间的距离相对较近。但是当要考虑绝对相位（此处的绝对相位是同各个雷达站之间的相对相位这一概念相对而言的）时，上述近似便缺乏严谨性了，这一点是需要我们注意的，但此处并不涉及到这一问题，因此不需要考虑上述近似的合理性。\n为了实现空间中的发射相参，需要对每个雷达站作一个时延与相位补偿，假设对于雷达站$i$的补偿量为$\\Delta \\tau_i$与$\\Delta \\phi_i$，则每个雷达的发射波形可如下所示\n$$ s_i'(t) = u_i(t - \\Delta \\tau_i)\\exp(j2\\pi f_0 (t - \\Delta \\tau_i) + j\\phi_i + j\\Delta \\phi_i) $$\n令$\\tau_i' = \\Delta \\tau_i + \\tau_i$，$\\phi_i' = \\Delta \\phi_i + \\phi_i$，则发射波形在空间中某点叠加后可表示为\n$$ s'(t) = \\sum_{i=1}^{N}u_i(t - \\tau_i')\\exp(j2\\pi f_0 (t - \\tau_i') + j\\phi_i') \\tag{1} $$\n理想情况下，当对于该点实现完美发射相参时，应当有下式成立\n$$ \\tau_1'=\\tau_2'=\u0026hellip;=\\tau_N' $$\n事实上，并不能实现完美相参，因此上式中的等号应当更换为约等于。通常来说各个雷达站发射信号在该点的时延差距在纳秒级别，因此对于包络来说，可近似认为各个包络在时域上已实现对齐。若假设各个雷达站发射波形的包络相等，则有下式成立\n$$ u_1(t-\\tau_1') = u_2(t - \\tau_2') = \u0026hellip; = u_N(t - \\tau_N') = u(t - \\tau_1') $$\n各个雷达站发射波形的包络统一用$u(t)$表示。为了后续分析的方便，不妨假设$u(t)$恒为1，即雷达发射波形无限长，则此时(1)式可写为\n$$ s'(t) = \\sum_{i=1}^{N}\\exp(j2\\pi f_0 (t - \\tau_i') + j\\phi_i') $$\n当各雷达站发射信号为线性调频信号时，将其表示如下\n$$ s_i(t) = u_i(t)\\exp(j2\\pi f_0 t+j\\phi_i)\\exp(\\pi \\mu t^2) $$\n其中$\\mu$为调频率。对其进行同样分析，可得到空间中某点叠加后的信号为\n$$ s'(t) = \\sum_{i=1}^{N}\\exp(j2\\pi f_0 (t - \\tau_i') + j\\phi_i')\\exp(\\pi \\mu (t - \\tau_i')^2) \\tag{2} $$\n本文用下式来衡量信号能量大小\n$$ E_s = \\int_{-\\infty}^{+\\infty}s(t)s^*(t)\\mathrm{d}t $$\n则将(2)式代入上式后，可得\n$$ \\begin{align*} E_s =\u0026amp; \\int_{0}^{T_r}\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\exp(-j2\\pi\\mu t({\\tau'}_i-{\\tau'}_j)-j2\\pi f_0 ({\\tau'}_i-{\\tau'}_j)+j\\pi \\mu ({\\tau'}_i^2-{\\tau'}_j^2)+j(\\phi_i-\\phi_j))\\mathrm{d}t \\\\ =\u0026amp; T_r\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\exp(-jk\\frac{T_r}{2}-j2\\pi f_0\\Delta{\\tau'}_{ij})\\mathrm{Sa}(k\\frac{T_r}{2})\\exp(j\\pi \\mu ({\\tau'}_i^2-{\\tau'}_j^2)+j(\\phi_i-\\phi_j)) \\\\ =\u0026amp; T_r(N+2\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\cos(-\\frac{kT_r}{2}-j2\\pi f_0\\Delta{\\tau'}_{ij}+\\pi\\mu({\\tau'}_i^2-{\\tau'}_j^2)+\\Delta\\phi_{ij})\\mathrm{Sa}(k\\frac{T_r}{2})) \\\\ =\u0026amp; T_r(N+2\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\cos(-2\\pi(f_0+\\frac{B}{2})\\Delta{\\tau'}_{ij}+\\pi\\mu({\\tau'}_i^2-{\\tau'}_j^2)+\\Delta\\phi_{ij})\\mathrm{Sa}(k\\frac{T_r}{2})) \\end{align*} $$\n其中$k=2\\pi \\mu \\Delta \\tau'_{ij}$，$\\Delta \\tau'_{ij}=(\\tau_i'-\\tau_j')$，$\\Delta\\phi_{ij}=\\phi_i-\\phi_j$，$B=\\mu T_r$。为了方便，假设$\\tau_1'=0$，因此上式中的二阶量可以忽略，即$\\pi\\mu(\\tau_i'^2-\\tau_j'^2)\\approx0$，于是上式可化为\n$$ E_s = T_r(N+2\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\cos(-2\\pi(f_0+\\frac{B}{2})\\Delta\\tau'_{ij}+\\Delta\\phi_{ij})\\mathrm{Sa}(\\pi B \\Delta \\tau'_{ij})) $$\n定义发射相参效率为实际信号能量与理论信号能量之比，则发射相参效率可表示为\n$$ \\eta = \\frac{N+2\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\cos(-2\\pi(f_0+\\frac{B}{2})\\Delta\\tau'_{ij}+\\Delta\\phi_{ij})\\mathrm{Sa}(\\pi B \\Delta \\tau'_{ij})}{N^2} $$\n记发射相参增益为叠加后的能量与单个雷达站发射信号的能量之比，则发射相参增益如下所示\n$$ A = N+2\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\cos(-2\\pi(f_0+\\frac{B}{2})\\Delta\\tau'_{ij}+\\Delta\\phi_{ij})\\mathrm{Sa}(\\pi B \\Delta \\tau'_{ij}) $$\n当各雷达站发射的信号为一个窄带信号时，可将$\\mathrm{Sa}(\\pi B \\Delta \\tau'_{ij})$这一项忽略，此时空间中的发射相参增益分布如下所示\n图1：窄带信号的空间发射相参增益分布\r当雷达站发射信号为一个宽带信号时，辛克函数对于空间中发射相参增益的调制作用便不可忽略，此时的空间发射相参增益分布如下所示\n图2：宽带信号的空间发射相参增益分布\r当采用一种合适的雷达空间分布构型时，可将空间中的发射相参增益聚集为一个点，如下所示\n图3：聚焦的空间相参增益\r通过上述过程可发现，发射相参可类比为摄像机聚焦，发射相参聚焦在某一个点后，仅在该点附近具有良好的发射相参增益，而在其它地方会由于相参参数对齐问题而造成增益较低，因此将其形象地称为“相参景深”。这个概念的名字来源于摄影领域，是指在摄影机镜头或其他成像器前沿能够取得清晰图像的成像所测定的被摄物体前后距离范围。分布式雷达的发射相参过程事实上可以看作摄像机的聚焦过程，对空间中某个点进行发射相参后，在该点周围的一定范围内都将有较好的发射相参效率，而在其它地方的相参增益均较低。\n大多数文献在讨论空间发射相参时，通常从时域角度的时延与相位对齐误差来讨论，而这一概念从空域角度的发射相参增益范围来讨论，笔者认为这是一个不错的角度。\n","permalink":"https://bingsz.github.io/en/posts/coherentdepth/","summary":"\u003cp\u003e  相参景深这一概念在《分布式相参雷达相参效率及相参景深研究》中提出，这一概念是从发射相参增益在空间中的分布入手的。当各个雷达站对于空间中某点实现了完美发射相参（即时延和相位上同时完美对齐）后，该点周围的空间均可以获得一个较高的发射相参增益。大多数文献在衡量发射相参增益时，都是从时域入手的，而这一概念从空域入手研究的。\u003c/p\u003e","title":"分布式全相参雷达的相参景深"},{"content":" Matlab的Radar Toolbox与Phased工具箱具有很强的功能，但是这方面的资料比较少，所以稍作整理之后便写了这篇文章。这篇文章主要介绍如何使用Matlab来作雷达的信号级仿真\n官方手册上给出了许多种仿真方法，但有些仿真方法只能实现模型级仿真，并不能实现信号级仿真。这里介绍的方法是主要使用Phased工具箱来进行信号级仿真。\n这个例子是来自官方手册的《Simulating Test Signals for a Radar Receiver》一节中，本文将主要围绕这个例子展开。为了不计算繁杂的雷达方程，在Matlab的雷达工具箱中，通常是通过指定一个目标的距离、雷达截面积以及检测概率与虚警概率来确定所需雷达环路增益（关于雷达的环路增益定义可参见Radar toolbox的Get started中的Simulate a Scanning Radar），不过在此处由于我们并不主要使用雷达工具箱中的工具，因此此处不使用雷达环路增益这个概念。\n1. 雷达相关参数计算 1.1. 计算信噪比 为了计算所需的信噪比，当进行非相干检测时，可以使用下述代码来计算所需的信噪比\nnum_pulse_int = 10; pfa = 1e-6; pd = 0.9; snr_min = detectability(pd, pfa, num_pulse_int, \u0026#39;Swerling0\u0026#39;); 当然，在官方手册中也给出了可以通过使用Albersheim经验公式来求得近似的最小信噪比\nnum_pulse_int = 10; pfa = 1e-6; pd = 0.9; snr_min = albersheim(pd, pfa, num_pulse_int); 当进行相干检测时，可以通过如下方法来计算得到所需的信噪比\nnum_pulse_int = 10; pfa = 1e-6; pd = 0.9; snr_min = detectability(pd, pfa, 1, \u0026#39;Swerling0\u0026#39;) - 10 * log10(num_pulse_int); 1.2. 发射机峰值功率 接下来便需要计算发射机的峰值功率，计算峰值功率时，可以假设检测在某距离下的一个物体的检测与虚警概率，然后通过雷达方程来计算所需的峰值功率。雷达方程可以手动写，也可以使用radareqpow函数来计算。\nc = 3e8; fc = 1e9; lambda = c / fc; max_range = 5e3; pulse_width = 1e-6; tx_gain = 20; tgt_rcs = 1; peak_power = radareqpow(lambda, max_range, snr_min, pulse_width, \u0026#39;Gain\u0026#39;, tx_gain, \u0026#39;RCS\u0026#39;, tgt_rcs); 或者\npeak_power = ((4*pi)^3*noisepow(1/pulse_width)*max_range^4*... db2pow(snr_min))/(db2pow(2*tx_gain)*tgt_rcs*lambda^2); 2. 相关设备定义 然后我们来定义一些相关的设备与参数。\n2.1. 定义波形 定义波形\nprf = prop_speed/(2*max_range); waveform = phased.RectangularWaveform(... \u0026#39;PulseWidth\u0026#39;,1/pulse_bw,... \u0026#39;PRF\u0026#39;,prf,... \u0026#39;SampleRate\u0026#39;,fs); 上述代码生成了一段矩形调幅脉冲信号。当然，Phased工具箱中也提供了包括线性调频信号等的脉冲波形。不过事实上，waveform这个变量并不一定需要通过Phased工具箱来获得，waveform在代码中的作用是提供脉冲波形与匹配滤波参数。因此换言之，我们也可以通过自己编写脉冲波形，并计算匹配滤波参数来自定义脉冲波形。\n2.2. 定义接收机与发射机 noise_bw = pulse_bw; receiver = phased.ReceiverPreamp(... \u0026#39;Gain\u0026#39;,20,... \u0026#39;NoiseFigure\u0026#39;,0,... \u0026#39;SampleRate\u0026#39;,fs,... \u0026#39;EnableInputPort\u0026#39;,true); transmitter = phased.Transmitter(... \u0026#39;Gain\u0026#39;,tx_gain,... \u0026#39;PeakPower\u0026#39;,peak_power,... \u0026#39;InUseOutputPort\u0026#39;,true); 上述代码定义了一个发射机与接收机，相关参数设置可以参考官方手册。\n2.3. 定义天线与发射平台 antenna = phased.IsotropicAntennaElement(... \u0026#39;FrequencyRange\u0026#39;,[5e9 15e9]); sensormotion = phased.Platform(... \u0026#39;InitialPosition\u0026#39;,[0; 0; 0],... \u0026#39;Velocity\u0026#39;,[0; 0; 0]); radiator = phased.Radiator(... \u0026#39;Sensor\u0026#39;,antenna,... \u0026#39;OperatingFrequency\u0026#39;,fc); collector = phased.Collector(... \u0026#39;Sensor\u0026#39;,antenna,... \u0026#39;OperatingFrequency\u0026#39;,fc); 上述代码定义了一个全方向性天线，如果要定义一个有方向性天线，可以使用诸如phased.GaussianAntennaElement来定义天线。phased.Platform定义了一个雷达运动平台，通过设置初始位置与运动速度可以求解得到各个时刻的位置与指向。phased.Radiator与phased.Collector定义了一个散射平台与接收平台，用于将电磁波散射到空间，并将空间中的电磁波接收回来。\n2.4. 定义目标 tgtpos = [[2024.66;0;0],[3518.63;0;0],[3845.04;0;0]]; tgtvel = [[0;0;0],[0;0;0],[0;0;0]]; tgtmotion = phased.Platform(\u0026#39;InitialPosition\u0026#39;,tgtpos,\u0026#39;Velocity\u0026#39;,tgtvel); tgtrcs = [1.6 2.2 1.05]; target = phased.RadarTarget(\u0026#39;MeanRCS\u0026#39;,tgtrcs,\u0026#39;OperatingFrequency\u0026#39;,fc); 上述代码定义了目标的运动平台与雷达目标散射特性。其中tgtrcs为雷达截面积，但是上述代码只能定义一个点目标，当需要仿真扩展目标或具有一定体积的目标时，便不能使用这种方法。\n2.5. 定义传输信道 channel = phased.FreeSpace(... \u0026#39;SampleRate\u0026#39;,fs,... \u0026#39;TwoWayPropagation\u0026#39;,true,... \u0026#39;OperatingFrequency\u0026#39;,fc); 上述代码定义了一个传输信道，TwoWayPropagation定义了一个双程信道，指的是计算过程中算及雷达的发射与接收路径，当TwoWayPropagation设定为False时，将只计算一个路程。因此当计算多基地雷达时，需要将此参数设定为False。\n3. 开始仿真 fast_time_grid = unigrid(0,1/fs,1/prf,\u0026#39;[)\u0026#39;); rxpulses = zeros(numel(fast_time_grid),num_pulse_int); for m = 1:num_pulse_int [sensorpos,sensorvel] = sensormotion(1/prf); [tgtpos,tgtvel] = tgtmotion(1/prf); [tgtrng,tgtang] = rangeangle(tgtpos,sensorpos); pulse = waveform(); [txsig,txstatus] = transmitter(pulse); txsig = radiator(txsig,tgtang); txsig = channel(txsig,sensorpos,tgtpos,sensorvel,tgtvel); tgtsig = target(txsig); rxsig = collector(tgtsig,tgtang); rxpulses(:,m) = receiver(rxsig,~(txstatus\u0026gt;0)); end 上述代码就开始了仿真，sensormotion便是前文中所定义的雷达运动平台，其中的参数表示脉冲重复时间，用于表示所经过的时间。tgtmotion与sensormotion同理。rangeangle用于计算雷达天线与目标的夹角。waveform()便生成了一段发射波形，这个发射波形也可以通过自定义来实现。transmitter，radiator，channel，target，collector，receiver定义了一整套发射接收链路。首先通过发射机将信号传递至天线，随后使用天线将其发射出去，然后在空中传输，照射到目标上并反射回来，被天线所接收，最后使用接收机来接收。\n上述所得到的rxpulses便是接收得到的回波信号，后续的信号级仿真均可以通过对该矩阵进行操作来进行。\n4. 完整代码 上述只是给出了一个雷达仿真的大致代码，官方手册中的完整代码如下所示，可以对其中的参数进行修改来得到仿真目的。\n%% Simulating Test Signals for a Radar Receiver % This example shows how to simulate received signal of a monostatic pulse % radar to estimate the target range. A monostatic radar has the % transmitter collocated with the receiver. The transmitter generates a % pulse which hits the target and produces an echo received by the % receiver. By measuring the location of the echoes in time, we can % estimate the range of a target. % % This example focuses on a pulse % \u0026lt;https://www.mathworks.com/discovery/radar-system-design.html radar % system design\u0026gt; which can achieve a set of design specifications. It % outlines the steps to translate design specifications, such as the % probability of detection and the range resolution, into radar system % parameters, such as the transmit power and the pulse width. It also % models the environment and targets to synthesize the received signal. % Finally, signal processing techniques are applied to the received signal % to detect the ranges of the targets. % Copyright 2007-2021 The MathWorks, Inc. %% Design Specifications % % The design goal of this pulse radar system is to detect non-fluctuating % targets with at least one square meter radar cross section (RCS) at a % distance up to 5000 meters from the radar with a range resolution of 50 % meters. The desired performance index is a probability of detection (Pd) % of 0.9 and probability of false alarm (Pfa) below 1e-6. Since coherent % detection requires phase information and, therefore is more % computationally expensive, we adopt a noncoherent detection scheme. In % addition, this example assumes a free space environment. pd = 0.9; % Probability of detection pfa = 1e-6; % Probability of false alarm max_range = 5000; % Maximum unambiguous range range_res = 50; % Required range resolution tgt_rcs = 1; % Required target radar cross section %% Monostatic Radar System Design % We need to define several characteristics of the radar system such as the % waveform, the receiver, the transmitter, and the antenna used to radiate % and collect the signal. % % *Waveform* % % We choose a rectangular waveform in this example. The desired range % resolution determines the bandwidth of the waveform, which, in the case % of a rectangular waveform, determines the pulse width. % % Another important parameter of a pulse waveform is the pulse repetition % frequency (PRF). The PRF is determined by the maximum unambiguous range. prop_speed = physconst(\u0026#39;LightSpeed\u0026#39;); % Propagation speed pulse_bw = prop_speed/(2*range_res); % Pulse bandwidth pulse_width = 1/pulse_bw; % Pulse width prf = prop_speed/(2*max_range); % Pulse repetition frequency fs = 2*pulse_bw; % Sampling rate waveform = phased.RectangularWaveform(... \u0026#39;PulseWidth\u0026#39;,1/pulse_bw,... \u0026#39;PRF\u0026#39;,prf,... \u0026#39;SampleRate\u0026#39;,fs); %% % Note that we set the sampling rate as twice the bandwidth. % % *Receiver Noise Characteristics* % % We assume that the only noise present at the receiver is the thermal % noise, so there is no clutter involved in this simulation. The power of % the thermal noise is related to the receiver bandwidth. The receiver\u0026#39;s % noise bandwidth is set to be the same as the bandwidth of the waveform. % This is often the case in real systems. We also assume that the receiver % has a 20 dB gain and a 0 dB noise figure. noise_bw = pulse_bw; receiver = phased.ReceiverPreamp(... \u0026#39;Gain\u0026#39;,20,... \u0026#39;NoiseFigure\u0026#39;,0,... \u0026#39;SampleRate\u0026#39;,fs,... \u0026#39;EnableInputPort\u0026#39;,true); %% % Note that because we are modeling a monostatic radar, the % receiver cannot be turned on until the transmitter is off. Therefore, we % set the EnableInputPort property to true so that a synchronization signal % can be passed from the transmitter to the receiver. % % *Transmitter* % % The most critical parameter of a transmitter is the peak transmit power. % The required peak power is related to many factors including the maximum % unambiguous range, the required SNR at the receiver, and the pulse width % of the waveform. Among these factors, the required SNR at the receiver is % determined by the design goal of Pd and Pfa, as well as the detection % scheme implemented at the receiver. % % The relation between Pd, Pfa and SNR can be best represented by a % receiver operating characteristics (ROC) curve. We can generate the curve % where Pd is a function of Pfa for varying SNRs using the following % command: snr_db = [-inf, 0, 3, 10, 13]; rocsnr(snr_db,\u0026#39;SignalType\u0026#39;,\u0026#39;NonfluctuatingNoncoherent\u0026#39;); %% % The ROC curves show that to satisfy the design goals of Pfa = 1e-6 and Pd % = 0.9, the received signal\u0026#39;s SNR must exceed 13 dB. This is a fairly high % requirement and is not very practical. To make the radar system more % feasible, we can use a pulse integration technique to reduce the required % SNR. If we choose to integrate 10 pulses, the curve can be generated as num_pulse_int = 10; rocsnr([0 3 5],\u0026#39;SignalType\u0026#39;,\u0026#39;NonfluctuatingNoncoherent\u0026#39;,... \u0026#39;NumPulses\u0026#39;,num_pulse_int); %% % We can see that the required power has dropped to around 5 dB. Further % reduction of SNR can be achieved by integrating more pulses, but the % number of pulses available for integration is normally limited due to the % motion of the target or the heterogeneity of the environment. % % The approach above reads out the SNR value from the curve, but it is % often desirable to calculate only the required value. For the noncoherent % detection scheme, the calculation of the required SNR is, in theory, % quite complex. Fortunately, there are good approximations available, such % as Albersheim\u0026#39;s equation. Using Albersheim\u0026#39;s equation, the required SNR % can be derived as snr_min = albersheim(pd, pfa, num_pulse_int) %% % Once we obtain the required SNR at the receiver, the peak power at the % transmitter can be calculated using the radar equation. Here we assume % that the transmitter has a gain of 20 dB. % % To calculate the peak power using the radar equation, we also need to % know the wavelength of the propagating signal, which is related to the % operating frequency of the system. Here we set the operating frequency to % 10 GHz. tx_gain = 20; fc = 10e9; lambda = prop_speed/fc; peak_power = ((4*pi)^3*noisepow(1/pulse_width)*max_range^4*... db2pow(snr_min))/(db2pow(2*tx_gain)*tgt_rcs*lambda^2) %% % Note that the resulting power is about 5 kW, which is very reasonable. In % comparison, if we had not used the pulse integration technique, the % resulting peak power would have been 33 kW, which is huge. %% % With all this information, we can configure the transmitter. transmitter = phased.Transmitter(... \u0026#39;Gain\u0026#39;,tx_gain,... \u0026#39;PeakPower\u0026#39;,peak_power,... \u0026#39;InUseOutputPort\u0026#39;,true); %% % Again, since this example models a monostatic radar system, the % InUseOutputPort is set to true to output the status of the transmitter. % This status signal can then be used to enable the receiver. % % *Radiator and Collector* % % In a radar system, the signal propagates in the form of an % electromagnetic wave. Therefore, the signal needs to be radiated and % collected by the antenna used in the radar system. This is where the % radiator and the collector come into the picture. % % In a monostatic radar system, the radiator and the collector share the % same antenna, so we will first define the antenna. To simplify the % design, we choose an isotropic antenna. Note that the antenna needs to be % able to work at the operating frequency of the system (10 GHz), so we set % the antenna\u0026#39;s frequency range to 5-15 GHz. % % We assume that the antenna is stationary. antenna = phased.IsotropicAntennaElement(... \u0026#39;FrequencyRange\u0026#39;,[5e9 15e9]); sensormotion = phased.Platform(... \u0026#39;InitialPosition\u0026#39;,[0; 0; 0],... \u0026#39;Velocity\u0026#39;,[0; 0; 0]); %% % With the antenna and the operating frequency, we define both the radiator % and the collector. radiator = phased.Radiator(... \u0026#39;Sensor\u0026#39;,antenna,... \u0026#39;OperatingFrequency\u0026#39;,fc); collector = phased.Collector(... \u0026#39;Sensor\u0026#39;,antenna,... \u0026#39;OperatingFrequency\u0026#39;,fc); %% % This completes the configuration of the radar system. In the following % sections, we will define other entities, such as the target and the % environment that are needed for the simulation. We will then simulate the % signal return and perform range detection on the simulated signal. %% System Simulation % *Targets* % % To test our radar\u0026#39;s ability to detect targets, we must define the targets % first. Let us assume that there are 3 stationary, non-fluctuating targets % in space. Their positions and radar cross sections are given below. tgtpos = [[2024.66;0;0],[3518.63;0;0],[3845.04;0;0]]; tgtvel = [[0;0;0],[0;0;0],[0;0;0]]; tgtmotion = phased.Platform(\u0026#39;InitialPosition\u0026#39;,tgtpos,\u0026#39;Velocity\u0026#39;,tgtvel); tgtrcs = [1.6 2.2 1.05]; target = phased.RadarTarget(\u0026#39;MeanRCS\u0026#39;,tgtrcs,\u0026#39;OperatingFrequency\u0026#39;,fc); %% % *Propagation Environment* % % To simulate the signal, we also need to define the propagation channel % between the radar system and each target. channel = phased.FreeSpace(... \u0026#39;SampleRate\u0026#39;,fs,... \u0026#39;TwoWayPropagation\u0026#39;,true,... \u0026#39;OperatingFrequency\u0026#39;,fc); %% % Because this example uses a monostatic radar system, the channels are set % to simulate two way propagation delays. % % *Signal Synthesis* % % We are now ready to simulate the entire system. % % The synthesized signal is a data matrix with the fast time (time within % each pulse) along each column and the slow time (time between pulses) % along each row. To visualize the signal, it is helpful to define both % the fast time grid and slow time grid. fast_time_grid = unigrid(0,1/fs,1/prf,\u0026#39;[)\u0026#39;); slow_time_grid = (0:num_pulse_int-1)/prf; %% % The following loop simulates 10 pulses of the receive signal. % % We set the seed for the noise generation in the receiver so that we can % reproduce the same results. receiver.SeedSource = \u0026#39;Property\u0026#39;; receiver.Seed = 2007; % Pre-allocate array for improved processing speed rxpulses = zeros(numel(fast_time_grid),num_pulse_int); for m = 1:num_pulse_int % Update sensor and target positions [sensorpos,sensorvel] = sensormotion(1/prf); [tgtpos,tgtvel] = tgtmotion(1/prf); % Calculate the target angles as seen by the sensor [tgtrng,tgtang] = rangeangle(tgtpos,sensorpos); % Simulate propagation of pulse in direction of targets pulse = waveform(); [txsig,txstatus] = transmitter(pulse); txsig = radiator(txsig,tgtang); txsig = channel(txsig,sensorpos,tgtpos,sensorvel,tgtvel); % Reflect pulse off of targets tgtsig = target(txsig); % Receive target returns at sensor rxsig = collector(tgtsig,tgtang); rxpulses(:,m) = receiver(rxsig,~(txstatus\u0026gt;0)); end %% Range Detection % *Detection Threshold* % % The detector compares the signal power to a given threshold. In radar % applications, the threshold is often chosen so that the Pfa is below a % certain level. In this case, we assume the noise is white Gaussian and % the detection is noncoherent. Since we are also using 10 pulses to do % the pulse integration, the signal power threshold is given by npower = noisepow(noise_bw,receiver.NoiseFigure,... receiver.ReferenceTemperature); threshold = npower * db2pow(npwgnthresh(pfa,num_pulse_int,\u0026#39;noncoherent\u0026#39;)); %% % We plot the first two received pulses with the threshold num_pulse_plot = 2; % helperRadarPulsePlot(rxpulses,threshold,... % fast_time_grid,slow_time_grid,num_pulse_plot); %% % The threshold in these figures is for display purpose only. Note that % the second and third target returns are much weaker than the first return % because they are farther away from the radar. Therefore, the received % signal power is range dependent and the threshold is unfair to targets % located at different ranges. % % *Matched Filter* % % The matched filter offers a processing gain which improves the detection % threshold. It convolves the received signal with a local, time-reversed, % and conjugated copy of transmitted waveform. Therefore, we must specify % the transmitted waveform when creating our matched filter. The received % pulses are first passed through a matched filter to improve the SNR % before doing pulse integration, threshold detection, etc. matchingcoeff = getMatchedFilter(waveform); matchedfilter = phased.MatchedFilter(... \u0026#39;Coefficients\u0026#39;,matchingcoeff,... \u0026#39;GainOutputPort\u0026#39;,true); [rxpulses, mfgain] = matchedfilter(rxpulses); %% % The matched filter introduces an intrinsic filter delay so that the % locations of the peak (the maximum SNR output sample) are no longer % aligned with the true target locations. To compensate for this delay, in % this example, we will move the output of the matched filter forward and % pad the zeros at the end. Note that in real systems, because the data % is collected continuously, there is really no end of it. matchingdelay = size(matchingcoeff,1)-1; rxpulses = buffer(rxpulses(matchingdelay+1:end),size(rxpulses,1)); %% % The threshold is then increased by the matched filter processing gain. threshold = threshold * db2pow(mfgain); %% % The following plot shows the same two pulses after they pass through the % matched filter. % helperRadarPulsePlot(rxpulses,threshold,... % fast_time_grid,slow_time_grid,num_pulse_plot); %% % After the matched filter stage, the SNR is improved. However, because % the received signal power is dependent on the range, the return of a % close target is still much stronger than the return of a target farther % away. Therefore, as the above figure shows, the noise from a close range % bin also has a significant chance of surpassing the threshold and % shadowing a target farther away. To ensure the threshold is fair to all % the targets within the detectable range, we can use a time varying gain % to compensate for the range dependent loss in the received echo. % % To compensate for the range dependent loss, we first calculate the range % gates corresponding to each signal sample and then calculate the free % space path loss corresponding to each range gate. Once that information % is obtained, we apply a time varying gain to the received pulse so that % the returns are as if from the same reference range (the maximum % detectable range). range_gates = prop_speed*fast_time_grid/2; tvg = phased.TimeVaryingGain(... \u0026#39;RangeLoss\u0026#39;,2*fspl(range_gates,lambda),... \u0026#39;ReferenceLoss\u0026#39;,2*fspl(max_range,lambda)); rxpulses = tvg(rxpulses); %% % Now let\u0026#39;s plot the same two pulses after the range normalization % helperRadarPulsePlot(rxpulses,threshold,... % fast_time_grid,slow_time_grid,num_pulse_plot); %% % The time varying gain operation results in a ramp in the noise floor. % However, the target return is now range independent. A constant % threshold can now be used for detection across the entire detectable % range. %% % Notice that at this stage, the threshold is above the maximum power level % contained in each pulse. Therefore, nothing can be detected at this % stage yet. We need to perform pulse integration to ensure the power of % returned echoes from the targets can surpass the threshold while leaving % the noise floor below the bar. This is expected since it is the pulse % integration which allows us to use the lower power pulse train. % % *Noncoherent Integration* % % We can further improve the SNR by noncoherently integrating (video % integration) the received pulses. rxpulses = pulsint(rxpulses,\u0026#39;noncoherent\u0026#39;); helperRadarPulsePlot(rxpulses,threshold,... fast_time_grid,slow_time_grid,1); %% % After the video integration stage, the data is ready for the final % detection stage. It can be seen from the figure that all three echoes % from the targets are above the threshold, and therefore can be detected. % % *Range Detection* % % Finally, the threshold detection is performed on the integrated pulses. % The detection scheme identifies the peaks and then translates their % positions into the ranges of the targets. [~,range_detect] = findpeaks(rxpulses,\u0026#39;MinPeakHeight\u0026#39;,sqrt(threshold)); %% % The true ranges and the detected ranges of the targets are shown below: true_range = round(tgtrng) range_estimates = round(range_gates(range_detect)) %% % Note that these range estimates are only accurate up to the range % resolution (50 m) that can be achieved by the radar system. %% Summary % In this example, we designed a radar system based on a set of given % performance goals. From these performance goals, many design parameters % of the radar system were calculated. The example also showed how to use % the designed radar to perform a range detection task. In this example, % the radar used a rectangular waveform. Interested readers can refer to % \u0026lt;docid:phased_ug.example-ex12077916\u0026gt; for an example using a chirp % waveform. ","permalink":"https://bingsz.github.io/en/posts/matlabsimulateradar/","summary":"\u003cp\u003e  Matlab的Radar Toolbox与Phased工具箱具有很强的功能，但是这方面的资料比较少，所以稍作整理之后便写了这篇文章。这篇文章主要介绍如何使用Matlab来作雷达的信号级仿真\u003c/p\u003e","title":"使用Matlab来作雷达的信号级仿真"},{"content":" 最近在学矩阵论方面的内容，感觉其中的子空间最佳逼近方法比较有意思，所以作一个记录。简单来说，子空间的最佳逼近方法给出了一种通过子空间来拟合原空间中元素的一种方法，并且这种方法在某种距离度量下是最优的。但是因为笔者学的是工科，因此此处的许多地方都不具有数学上的严谨性，仅作为一种逼近方法来介绍。\n理论准备 在介绍最佳逼近的构造方法之前，要先介绍一些矩阵论方面的基础知识。为了研究的简单，下文均只研究有限维空间中的情况。首先定义线性空间概念，如果在数域$\\mathrm{P}$上有一个非空集合$\\mathrm{V}$，并且在$\\mathrm{V}$上定义了加法（$+$）与从$\\mathrm{P}$与$\\mathrm{V}$到$\\mathrm{V}$的数量乘法（$\\cdot$），若满足如下条件，则称$\\mathrm{V}$为$\\mathrm{P}$上的一个线性空间\n(1) $\\mathrm{V}$中的加法运算构成一个阿贝尔群 (2) $\\exists 1 \\in \\mathrm{V}$，$1 \\cdot \\alpha = \\alpha$（$\\alpha \\in \\mathrm{V}$） (3) $k \\cdot (m \\cdot \\alpha) = (km) \\cdot \\alpha$（$k, m \\in \\mathrm{P}, \\alpha \\in \\mathrm{V} $） (4) $(k+m)\\cdot \\alpha = k \\cdot \\alpha + m \\cdot \\alpha$（$k, m \\in \\mathrm{P}, \\alpha \\in \\mathrm{V} $） (5) $k \\cdot (\\alpha + \\beta) = k \\cdot \\alpha + k \\cdot \\beta$（$k \\in \\mathrm{P}, \\alpha, \\beta \\in \\mathrm{V}$） 在此基础上，很自然地，我们可以定义线性子空间的概念，当$\\mathrm{V_1}$构成一个线性空间，并且$\\mathrm{V_1} \\subset \\mathrm{V}$时，称$\\mathrm{V_1}$为$\\mathrm{V}$的线性子空间。\n同时，我们要引入内积空间概念。我们将满足如下条件的$\\mathrm{V} \\rightarrow \\mathrm{P}$的运算记为内积，表示为$(\\alpha, \\beta)$，其中$\\alpha, \\beta \\in \\mathrm{V}$\n(1) $(\\alpha, \\beta) = \\overline{(\\beta, \\alpha)}$ (2) $(\\alpha + \\beta, \\gamma) = (\\alpha, \\gamma) + (\\beta, \\gamma)$ (3) $(k \\alpha, \\beta) = k(\\alpha, \\beta)$ (4) $(\\alpha, \\alpha) \\geq 0$，且当且仅当$\\alpha = 0$时，$(\\alpha, \\alpha) = 0$ 其中，$\\alpha, \\beta, \\gamma \\in \\mathrm{V}, k \\in \\mathrm{P}$。定义了内积的线性空间$\\mathrm{V}$称之为内积空间。定义在这种定义下的$\\mathrm{V}$中的两个元素$\\alpha, \\beta$的距离定义为$d(\\alpha, \\beta) = \\sqrt{(\\alpha - \\beta, \\alpha - \\beta)}$，其中减号的定义为$\\alpha-\\beta = \\alpha + (-\\beta)$。\n接下来我们对最佳逼近作一个定义，记$\\mathrm{V_1}$为$\\mathrm{V}$的一个线性子空间，$\\alpha \\in \\mathrm{V}, \\alpha_1 \\in \\mathrm{V_1}$，当满足如下等式时，我们称$\\alpha_1$为$\\alpha$在$\\mathrm{V_1}$上的一个最佳逼近\n$$ d(\\alpha, \\alpha_1) = \\inf_{\\beta \\in \\mathrm{V_1}} d(\\alpha, \\beta) $$\n事实上，更严谨地，接下来我们应当证明这样的最佳逼近是存在的，但这部分内容并不是本文的重点，因此本文省略一些严谨性方面的证明。接下来我们介绍一下最佳逼近的构造方法。\n记$\\alpha \\in \\mathrm{V}, \\alpha_1 \\in \\mathrm{V_1}$，其中$\\mathrm{V_1}$为$\\mathrm{V}$的线性子空间。令$\\beta = \\alpha - \\alpha_1$，可证明，当$\\alpha_1$为最佳逼近时，$\\beta$满足对$\\forall \\alpha\u0026rsquo; \\in \\mathrm{V_1}, (\\beta, \\alpha\u0026rsquo;) = 0$（换言之$\\beta \\perp \\mathrm{V_1}$）。因此若记$\\mathrm{V_1}$的基为$(\\gamma_1, \\gamma_2, \u0026hellip;, \\gamma_n)$，我们有\n$$ (\\beta, \\gamma_i) = (\\alpha, \\gamma_i) - (\\alpha_1, \\gamma_i) = 0(i = 1, 2, \u0026hellip;, n) $$\n若记$\\alpha_1 = \\sum_{k=1}^{n}x_k \\gamma_k$，那么我们有\n$$ \\sum_{k=1}^{n}x_k (\\gamma_k, \\gamma_i) = (\\alpha, \\gamma_i) $$\n定义$(\\gamma_1, \\gamma_2, \u0026hellip;, \\gamma_n)$的度量矩阵（Gram矩阵）为\n$$ G(\\gamma_1, \\gamma_2, \u0026hellip;, \\gamma_n) = \\begin{pmatrix} (\\gamma_1, \\gamma_1) \u0026amp; (\\gamma_1, \\gamma_2) \u0026amp; \u0026hellip; \u0026amp; (\\gamma_1, \\gamma_n) \\\\ (\\gamma_2, \\gamma_1) \u0026amp; (\\gamma_2, \\gamma_2) \u0026amp; \u0026hellip; \u0026amp; (\\gamma_2, \\gamma_n) \\\\ \u0026amp; \u0026amp; \u0026hellip; \\\\ (\\gamma_n, \\gamma_1) \u0026amp; (\\gamma_n, \\gamma_2) \u0026amp; \u0026hellip; \u0026amp; (\\gamma_n, \\gamma_n) \\end{pmatrix} $$\n那么我们有\n$$ G(\\gamma_1, \\gamma_2, \u0026hellip;, \\gamma_n) \\mathrm{x} = \\mathrm{b} $$\n其中$\\mathrm{x} = (x_1, x_2, \u0026hellip;, x_n)^T, \\mathrm{b} = ((\\alpha, \\gamma_1), (\\alpha, \\gamma_2), \u0026hellip;, (\\alpha, \\gamma_n))^T$。可以证明，由于$\\gamma_1, \\gamma_2, \u0026hellip;, \\gamma_n$线性无关，因此$G(\\gamma_1, \\gamma_2, \u0026hellip;, \\gamma_n)$可逆。于是便可求得最佳逼近\nMatlab仿真 此处用最小二乘法来作例子，假设共有$N$次观测，第$n$次观测的数据为$x_n$，并且记$x_n = (x_{n,1}, x_{n,2}, \u0026hellip;, x_{n,m})^T$，并且假设$y_n=\\lambda_1 x_{n, 1} + \\lambda_2 x_{n, 2} + \u0026hellip; + \\lambda_m x_{n, m}$，其中$\\lambda_i$为待定系数。那么最小二乘问题可表示为如下公式\n$$ \\min \\sum_{i=1}^{N}d(y_i, \\sum_{k=1}^{m}\\lambda_k x_{i, k}) $$\n记$b = (y_1, y_2, \u0026hellip;, y_N)^T, a_i = (x_{1, i}, x_{2, i}, \u0026hellip;, x_{N, i})^T$，那么上式可化为如下式子\n$$ \\min d(b, \\sum_{k=1}^{m}\\lambda_k a_k) $$\n可以发现，上式就是由$(a_1, a_2, \u0026hellip;, a_m)$张成的子空间对$b$的最佳逼近问题。若记$A = (a_1, a_2, \u0026hellip;, a_m)$，那么$\\lambda$的最佳逼近可由如下公式表示（注意度量矩阵$G(a_1, a_2, \u0026hellip;, a_m) = A^TA$）\n$$ A^TA\\lambda = A^Tb $$\n$$ \\lambda = (A^TA)^{-1}A^Tb $$\n于是可编写如下Matlab程序\n%% 最佳逼近的仿真程序 % 假设每次观测分别为[1, 1], [1, 2], [2, 1] % 假设输出结果为[2.9, 5.1, 3.9]\u0026#39; x = [1, 1; 1, 2; 2, 1]; y = [2.9; 5.1; 3.9]; lambda = calcApprox(x, y); disp(lambda); % calcApprox: 计算观测向量为x，输出结果为y时的最佳逼近，其中x的每个行向量为一次观测数据 function lambda = calcApprox(x, y) lambda = (x\u0026#39; * x) \\ x\u0026#39; * y; end 最终输出结果为\n$$ \\lambda = \\begin{pmatrix} 0.8909 \\\\ 2.0909 \\end{pmatrix} $$\n","permalink":"https://bingsz.github.io/en/posts/bestapproximation/","summary":"\u003cp\u003e  最近在学矩阵论方面的内容，感觉其中的子空间最佳逼近方法比较有意思，所以作一个记录。简单来说，子空间的最佳逼近方法给出了一种通过子空间来拟合原空间中元素的一种方法，并且这种方法在某种距离度量下是最优的。但是因为笔者学的是工科，因此此处的许多地方都不具有数学上的严谨性，仅作为一种逼近方法来介绍。\u003c/p\u003e","title":"矩阵论：子空间的最佳逼近"},{"content":" 最近学到了合成孔径雷达的成像算法，但在看陈老师的书时发现看得一头雾水，并且在书中省略了很多细节。经过资料查找与整理，在这里给出个人见解。\n0. 基础知识 合成孔径雷达是指将雷达装载在一个运动平台上，当运动平台运动起来时，雷达可以等效为分布在一条长直线上的线阵，相对应地，等效天线孔径也因此可以变得很大。根据天线理论，波束宽度$\\theta_{rw} = \\frac{\\lambda}{D}$，其中下标$rw$表示实孔径天线宽度，因此当天线孔径$D$增大时，波束宽度可以相对应地减小，从而提高方向维的分辨率$\\rho_a = R\\theta_{rw}$。但是提高天线孔径需要大量的成本，这在许多时候是无法满足的，因此合成孔径雷达便被提出。SAR有聚焦和非聚焦方法，聚焦方法是指对接收到的信号作一定的相位补偿后，再进行相加，因此通常来说非聚焦方法下工作性能并没有聚焦方法下好，因此本文主要来介绍聚焦方法下的SAR。为了简单起见，以下讨论均是基于正侧视SAR成像。\n0.1. 合成孔径长度$L_s$ 首先我们来讨论一下合成孔径的长度究竟是多少。如下图所示（摘自陈伯孝《现代雷达系统分析与设计》），假设目标位于聚焦点处，当雷达工作于非聚焦方法时，由于并没有对接收回波信号的相位作补偿，因此合成孔径不能无限长，当长到一定程度时，便会“削弱”回波信号。通常将这个长度定义为当接收到的回波信号与$A$点处的回波信号相位相差$\\frac{\\pi}{2}$时，所覆盖的长度。这是因为当接收回波信号与$A$点处回波信号相位差达到$\\frac{\\pi}{2}$时，便不能够对合成孔径信号的能量作更多地积累。这个概念我觉得可以类比于相控阵雷达中的远场与近场的概念，相控阵雷达中，将使得到各子天线回波信号的相位差小于$\\frac{\\pi}{8}$的区域定义为远场区，相当于作了一个近似。\n图0-1-1：飞机运动图\r在聚焦方法下，由于雷达对各接收回波作了相位补偿，因此此时的天线孔径被实孔径下的天线波束宽度所限制，如下图所示（摘自陈伯孝《现代雷达系统分析与设计》）。假设天线波束宽度为$\\theta_{rw}$，那么在投影部位的长度则为$\\theta_{rw}R_s$，其中$R_s$为地面投影中心线至航迹的距离。因为当目标$P$处于波束投影区域内对信号均有贡献，因此此时的天线孔径正是$L_s = \\theta_{rw}R_s$。\n图0-1-2：飞机运动图\r0.2. 合成孔径的方位分辨率 为了讨论合成孔径雷达的方位极限分辨率（注：这个极限的意思是，合成孔径雷达所能达到的最大分辨率，但当采用脉冲信号时，通常无法达到这个分辨率），在这我们假设一个连续波信号$s(t)=e^{j2\\pi f_c t}$。根据图0-1-2，假设雷达与目标之间的距离为$R(t_m)$，那么有（假设目标位于原点）\n$$ R(t_m) = \\sqrt{R_s^2+v^2t_m^2} \\approx R_s+\\frac{v^2t_m^2}{2R_s} \\tag{0.2.1} $$\n其中$v$表示飞机速度，于是接收到的回波信号可表示为\n$$ r(t) = \\exp(j2\\pi f_c (t - \\frac{2R(t)}{c}))$$\n于是可以得到，当将回波信号混频至基频时，回波信号的频率为\n$$ f_r = \\frac{1}{2\\pi}\\frac{\\mathrm{d}}{\\mathrm{d}t_m}(-4\\pi f_c \\frac{R(t)}{c}) \\approx -\\frac{2f_cv^2t}{cR_s} $$\n因此，此时接收到的信号为一个调频连续波信号，调频率$\\mu = -\\frac{2f_cv^2}{cR_s}$。而由于实孔径天线波束宽度的原因，该目标不可能被一直照射，因此接收到的目标回波信号事实上可以近似为一个矩形调幅调制的线性调频连续波信号，带宽$B=\\mu T_s$，此处的$T_s$为目标被照射的时长，因此$T_s=\\frac{L_s}{v}=\\frac{\\lambda R_s}{D v}$。于是可以的得到\n$$ B = |\\mu T_s| = \\frac{2v}{D} $$\n当一个线性调频连续波信号被脉冲压缩时，时宽带宽积近似等于$1$，因此可以得到，在脉冲压缩后，一个点目标的回波宽度为$\\tau \\approx \\frac{D}{2v}$。于是在这一宽度内的其它目标无法被分辨，因此可以得到方位分辨率为\n$$ \\rho_a = \\tau v = \\frac{D}{2} $$\n1. RD算法（距离多普勒成像算法） 为了更好的说明这个成像算法，我们仍旧借用图0-1-2来说明，如下所示。飞机在运动过程不断发出雷达信号（不妨假设为一个矩形调幅脉冲信号），然后在一个脉冲期间内接收到这一信号（即不考虑距离模糊），由于这一过程时间短暂，因此称其为快时间维，记为$t$。而在每个脉冲重复周期之间，由于间隔时间相对于前一个时间较长，因此称其为慢时间维$t_m$，慢时间维通常可以与飞机飞行速度相比拟。可以将这一过程类比为将一个时间轴按$t_m$进行划分，然后在每个$t_m$中，使用$t_k$来描述。进行这么分割的一个好处在于可以方便作近似。\n图1-1：飞机运动图\r假设发射信号为$s(t) = a(t)\\exp(j(2\\pi f_c t + \\pi \\mu t^2))$，其中$a(t)$为对脉冲发射信号的某种幅度调制，例如$a(t)$可以是一个矩形窗。若假设目标距离雷达的距离为$R(t_m)$，那么回波信号为\n$$ \\begin{align*} r(t, t_m) = a(t - \\frac{2R(t_m)}{c})\\exp(j2\\pi f_c (t - \\frac{2R(t_m)}{c}))\\exp(j\\pi \\mu (t - \\frac{2R(t_m)}{c})^2) \\end{align*} $$\n将回波信号混频至基频，可以得到\n$$ \\begin{align*} r(t, t_m) = a(t - \\frac{2R(t_m)}{c})\\exp(-j4\\pi \\frac{R(t_m)}{\\lambda})\\exp(j\\pi \\mu (t - \\frac{2R(t_m)}{c})^2) \\tag{1.1} \\end{align*} $$\n此处若假设$R(t_m)$在成像过程中是恒定的，并且记为$R_s$，那么可对上式作快时间维上的匹配滤波，得到（忽略常数项上的变化）\n$$ \\begin{align*} r_1(t, t_m) = a(t - \\frac{2R(t_m)}{c})\\exp(-j4\\pi \\frac{R(t_m)}{\\lambda})\\text{Sa}(\\pi \\Delta f_1 (t - \\frac{2R_s}{c})) \\tag{1.2} \\end{align*} $$\n其中，$\\Delta f_1$为发射的线性调频连续波信号的带宽，注意，在此处不能假设第一个指数项服从粗体处的假设，因为物体距离的变化会非常明显的反应在相位变化上。此时，我们只能知道物体在距离维上的值，而不能知道物体的方位。因此，为了解算物体的方位，我们需要充分利用上式中的第一个指数项。根据$(0.2.1)$处的近似，$(1.2)$式可写为\n$$ \\begin{align*} r_1(t, t_m) =\u0026amp; a(t - \\frac{2R(t_m)}{c})\\exp(-j4\\pi \\frac{R_s+\\frac{v^2t_m^2}{2R_s}}{\\lambda})\\text{Sa}(\\pi \\Delta f_1 (t - \\frac{2R_s}{c})) \\\\ =\u0026amp; a(t - \\frac{2R(t_m)}{c})\\exp(-j\\pi \\frac{2v^2 t_m^2}{\\lambda R_s})\\text{Sa}(\\pi \\Delta f_1 (t - \\frac{2R_s}{c}))\\exp(-j4\\pi \\frac{R_s}{\\lambda}) \\\\ \u0026amp; \\tag{1.3} \\end{align*} $$\n考虑上式中的第一个指数项，若假设$R(t_m)$在成像过程中是恒定的，那么有\n$$ \\begin{align*} r_1(t, t_m) = a(t - \\frac{2R(t_m)}{c})\\exp(-j\\pi \\frac{2v^2 t_m^2}{\\lambda R_s})\\text{Sa}(\\pi \\Delta f_1 (t - \\frac{2R_s}{c}))\\exp(-j4\\pi \\frac{R_s}{\\lambda}) \\end{align*} $$\n可以发现，回波信号在慢时间维上也是一个线性调频连续波信号，其中调频率$\\gamma = \\frac{2v^2}{\\lambda R_s}$，对$(1.3)$式作慢时间维上的匹配滤波，可得到如下结果\n$$ \\begin{align*} r_1(t, t_m) =\u0026amp; a(t - \\frac{2R(t_m)}{c})\\text{Sa}(\\pi \\Delta f_2 t_m)\\text{Sa}(\\pi \\Delta f_1 (t - \\frac{2R_s}{c}))\\exp(-j4\\pi \\frac{R_s}{\\lambda}) \\end{align*} $$\n其中$\\Delta f_2$为慢时间维上的线性调频连续波信号的带宽，其值为$\\Delta f_2 = \\gamma\\frac{L_s}{v}$。可以发现，点目标在经过处理后，在SAR图像上呈现为一个不同维上的$\\text{Sa}$函数乘积，如果从这个角度来分析分辨率，可以发现在距离维上的$\\text{Sa}$函数主瓣大小为$\\frac{1}{\\Delta f_1}$，从而可以得到距离维上的分辨率为$\\frac{c}{2 \\Delta f_1}$，与传统方法得到的结果一致；在方位维上的$\\text{Sa}$函数主瓣大小为$\\frac{1}{\\Delta f_2} = \\frac{D}{2v}$，于是可以得到方位维上的分辨率为$v\\frac{1}{\\Delta f_2} = \\frac{D}{2v} = \\frac{D}{2}$。与前文结果一致。\n2. 距离徙动矫正算法 在前文介绍RD算法的时候可以发现，算法中有一个重要的假设，即假设目标的$R(t_m)$在目标处于孔径内成像时是恒定的（第一章中划粗线部分）。但事实上，在实际成像时，通常并不能使用该假设，或者说，上述假设在多数情况下，并不能达到可忽略的地步。这就是距离徙动问题，当雷达扫过目标时，由于与目标距离变化的原因而导致脉冲压缩结果弯曲。\n许多人并不理解为什么要将慢时间维变换到频域中去处理，同时在陈伯孝的《现代雷达系统分析与设计》中也没有相关的说明，我一开始也不理解，有的人说是因为在频域中可以有更少的计算量，我认为这是错误的。下面我用公式告诉大家为什么要将慢时间维变换到频率域中。\n将$(0.2.1)$式代入目标回波的表达式，得到\n$$ r(t, t_m) = a(t - \\frac{2R(t_m)}{c})\\exp(-j\\pi \\frac{2v^2 t_m^2}{\\lambda R_s})\\exp(j\\pi \\mu (t - \\frac{2R(t_m)}{c})^2)\\exp(-j4\\pi \\frac{R_s}{\\lambda}) $$\n根据驻定相位原理，在$t_m=\\frac{f}{\\gamma}$处展开（$\\gamma = \\frac{2v^2}{\\lambda R_s}$），可得到当对$t_m$作傅里叶变换时，上式变为（忽略常数项）\n$$ \\begin{align*} r(t, f) =\u0026amp; a(t - \\frac{2R(f)}{c})\\exp(-j\\frac{f^2}{\\gamma})\\exp(j\\pi \\mu_1 (t - \\frac{2R(f)}{c})^2)\\exp(-j4\\pi \\frac{R_s}{\\lambda}) \\\\ \\approx \u0026amp; a(t - \\frac{2R(f)}{c})\\exp(-j\\frac{f^2}{\\gamma})\\exp(j\\pi \\mu_1 (t - \\frac{2R_s}{c} - \\frac{2}{c}\\frac{\\lambda^2 R_s f^2}{8v^2})^2)\\exp(-j4\\pi \\frac{R_s}{\\lambda}) \\\\ \u0026amp; \\tag{2.1} \\end{align*} $$\n其中$\\mu_1$是由于将慢时间维变换到了频域中而导致的调频斜率发生变化，此处不考虑这个值，推导过程可参考陈伯孝的《现代雷达系统分析与设计》。第二个指数项的平方项中的变化是因为根据$(0.2.1)$式的近似，并且将$t_m=\\frac{f}{\\gamma}$代入得到。事实上，$(2.1)$式的推导隐含了一个近似，推导中假设第二个指数项的平方项对于傅里叶变换的贡献较小而近似可忽略\n仔细观察上式，可以发现一个很有趣的点，快时间维上的脉冲压缩后因距离徙动而导致的快时间维平移仅跟频率有关（观察第二个指数项），而与目标在成像范围内的位置无关。这是一个很重要的点，因为这意味着可以对所有点目标进行统一的距离徙动矫正，而不需要考虑目标位置。为了更好的说明这一点，下面我用数据来说明这一点。考虑下图所示的仅在快时间维上进行脉冲压缩但不变换到频率域的结果（图片摘自SAR成像(七)：RD成像算法）。\n图2-1：快时间维上的脉冲压缩结果\r上图是一个三个点目标的SAR雷达回波仿真图。从上图可以发现由于点目标在成像范围内的位置不同，而导致每个点目标在作距离徙动矫正时，需要根据点目标的位置来进行（换言之，我们不能在慢时间维上进行同一个操作来“掰直”这三根线）。但是如果我们将慢时间维变换到频率域会发生什么情况呢？见证奇迹的时刻\n图2-2：快时间维上的脉冲压缩结果\r观察上图可以发现，这三根线被拉到了中心位置处，这意味着我们在进行距离徙动矫正时，对所有点目标乘以一个相同的距离徙动矫正系数而不需要考虑点目标的位置问题。这就回答了之前的提问。\n为了实现快时间维上的平移补偿，可以将快时间维变换到频率域，然后作一个相位补偿，也可以使用插值来完成。根据$(2.1)$式，在快时间维上的距离徙动补偿时间为\n$$ \\Delta t = \\frac{2}{c}\\frac{\\lambda^2 R_s f^2}{8v^2} $$\n因此总结一下距离徙动的补偿方法，如下图所示\n图2-3：距离徙动矫正\r3. Matlab仿真验证 我们通过Matlab来仿真接收到的回波信号。假设飞机沿$x$轴飞行，飞行速度为$v = 100\\text{m/s}$，从$-100\\text{m}$位置处运动到$100\\text{m}$位置处，高度为$1000m$。脉冲重复频率为$f_d = 500\\text{Hz}$，脉宽为$\\tau = 2\\mu \\text{s}$，调频率$\\mu=10^{14}$，采样频率$f_s=400\\text{MHz}$。三个点目标分别位于$(-50\\text{m}, 0, 0), (0, 150\\text{m}, 0), (20\\text{m}, 100\\text{m}, 0)$，合成孔径长度$L_s = 100\\text{m}$。于是可编写代码来模拟生成回波信号\n首先定义系列初始值，如下所示\ntarget = [-50, 0, 0; 0, 150, 0; 20, 100, 0]; % 点目标位置 Ls = 100; % 合成孔径长度 h = 800; % 飞机飞行高度 v = 100; % 飞机飞行速度 tau = 2e-6; % 脉宽为2us mu = 1e14; % 调频率为10^13 fc = 1e9; % 中心频率为1GHz fs = 4e8; % 采样频率为40MHz fd = 500; % 脉冲重复频率为500Hz c = 3e8; % 光速 lambda = c / fc; r = zeros(1000, 1000); % 初始化接收矩阵，共1000个回波脉冲，在横坐标上采集1000个点 随后模拟目标回波信号（假设已混频至基频）\nt = 0 : (1/fs) : ((size(r, 2)-1) / fs); t = t + 1600 / fs; % 选择一个合适的时间窗 for i = 1 : size(target, 1) % 初始化每个点目标的回波脉冲 Rs = sqrt(h^2 + target(i, 2)^2); % 计算点目标至航迹的最近距离，与文中相对应 for j = 1 : size(r, 1) tm = linspace(-1, 1, size(r, 1)); % 飞机扫过的时间为-1到1s tm = tm(j); % 计算目标本次回波在慢时间维上对应的时间 R = sqrt(Rs^2 + (tm * v - target(i, 1))^2); % 计算本次回波目标距离雷达距离 r(j, :) = r(j, :) + (abs(v * tm - target(i, 1)) \u0026lt; Ls/2) ... * (abs(t - 2 * R / c) \u0026lt; 1e-6) .* exp(-1i * 4 * pi * R / lambda) ... .* exp(1j * pi * mu * (t - 2 * R / c) .^ 2); % 忽略了一些常数项 end end 然后对目标回波作快时间维脉冲压缩的同时，进行距离徙动矫正（注意，傅里叶变换具有线性性质，因此交换两次变换维度的顺序不影响最终结果）\nfor j = 1 : size(r, 2) % 在慢时间维上进行FFT r(:, j) = fftshift(fft(r(:, j))); end Rs = h; % 假设投影区域中心恰好为原点 tt = -1e-6:1/fs:1e-6; % 这个时间与接收到的回波长度相一致 h1 = exp(1j * pi * mu * tt .^ 2); H1 = fft(h1, size(r, 2)); for j = 1 : size(r, 1) f1 = linspace(-fd / 2, fd / 2, size(r, 1)); f = f1(j); dt = 2 / c * lambda^2 * Rs * f^2 / (8 * v^2); % 计算需要补偿的时延 r(j, :) = ifft(fft(r(j, :)) .* conj(H1) .* exp(1i * 2 * pi .* linspace(0, 1, size(r, 1)) .* round(dt * fs))); % 在快时间维上作匹配滤波，不考虑调频斜率变化 end 最后对目标作慢时间维上的脉冲压缩\nr = r(:, 100:200); % 为了方便，仅截取部分数据 tt = -0.5:1/fd:0.5; Ka = 2 * v^2 / (lambda * Rs); % 计算慢时间维上的多普勒调频率 h2 = exp(1j * pi * Ka * tt .^ 2); H2 = fft(h2, size(r, 1)); for j = 1 : size(r, 2) r(:, j) = ifft(fftshift(r(:, j)) .* conj(H2)\u0026#39;); % 在慢时间维上作匹配滤波 end 最后，绘制出结果\nx = 1:size(r, 2); y = 1:size(r, 1); [X, Y] = meshgrid(x, y); mesh(X, Y, abs(r)); 图3-1：处理最终结果\r","permalink":"https://bingsz.github.io/en/posts/sarrcmc/","summary":"\u003cp\u003e  最近学到了合成孔径雷达的成像算法，但在看陈老师的书时发现看得一头雾水，并且在书中省略了很多细节。经过资料查找与整理，在这里给出个人见解。\u003c/p\u003e","title":"合成孔径雷达的RD成像算法及距离徙动矫正"},{"content":" 漫谈系列是我在平时突然想到的一些东西的随笔，所以文中可能有不严谨的表达。这篇文章是我突然想到多普勒滤波器组和数字波束形成方面的联系，所以就记录下来。\n多普勒滤波器组和数字波束形成这两个技术都可以用$\\text{FFT}$来实现，而这两者我觉得本质也是一样的。多普勒滤波器组的提出背景是因为我们事先并不能知道目标的速度以及多普勒频移，因此需要在一些频率点上分布许多个窄带滤波器用以得到各个多普勒频移下的目标回波。例如在$\\frac{2\\pi k}{N}$点上的一个$n$点窄带滤波器系数可以表示为$[1, e^{-j2\\pi \\frac{k}{N}\\cdot 1}, e^{-j2\\pi \\frac{k}{N}\\cdot 2},\u0026hellip;,e^{-j2\\pi \\frac{k}{N}\\cdot (n-1)}]$。如果我们要获得在$[0, 2\\pi )$上等间隔的滤波器组，一个方法便是令$k$等间隔取值，例如$k$可以取值为$[0, 1, 2, \u0026hellip;, N-1]$。那么组合起来就会发现第$k$个滤波器的输出为$\\sum_{n=0}^{N-1}x[i]e^{-j2\\pi \\frac{k}{N}n}$。仔细观察上式可以发现，这个就是一个$N$点$\\text{FFT}$的第$k$个点的值。因此从这个角度来说，多普勒滤波器组可以使用$\\text{FFT}$来加速这个计算过程。\n那么数字波束形成的原理与多普勒滤波器组原理类似，都是需要构造一系列系数，然后发现使用$\\text{FFT}$可以加速这个过程。因此从公式上来说，这两者的公式实际上是一样的。\n现在我们来考虑波束形成这个过程，为了方便，我们仅考虑线阵情形。假设有$n$个线阵，第$0$个线阵接收到的信号为$x(t)$，目标回波与阵面的法相夹角为$\\theta$，那么每个线阵接收到的信号相对于$0$号线阵的相位可以表示为$[1, e^{j\\frac{2\\pi}{\\lambda}d \\sin \\theta}, e^{j\\frac{2\\pi}{\\lambda}2d \\sin \\theta}, \u0026hellip;, e^{j\\frac{2\\pi}{\\lambda}(n-1)d \\sin \\theta}]$。为了使得在$\\theta$方向上的回波信号最大，可以对于每个线阵接收到的信号作一个相移。对第$k$个线阵作相移$e^{-j \\frac{2\\pi}{\\lambda}kd \\sin \\theta}$，于是相移后的线阵信号相加可以使得在$\\theta$方向上的回波同相相加，从而使得在这个方向上的信号增强，而在其它方向上的信号减弱。这就达到了波束形成的目的。\n但现在我们需要在一系列方位上进行扫描，这就需要形成一系列相移系数，使得这个虚拟波束在一个空间上扫描。于是可以形成一系列相移系数，如下所示\n$$ [1, e^{j\\frac{2\\pi}{\\lambda}d \\sin \\theta_1}, e^{j\\frac{2\\pi}{\\lambda}2d \\sin \\theta_1}, \u0026hellip;, e^{j\\frac{2\\pi}{\\lambda}(n-1)d \\sin \\theta_1}] $$\n$$ [1, e^{j\\frac{2\\pi}{\\lambda}d \\sin \\theta_2}, e^{j\\frac{2\\pi}{\\lambda}2d \\sin \\theta_2}, \u0026hellip;, e^{j\\frac{2\\pi}{\\lambda}(n-1)d \\sin \\theta_2}] $$\n$$ \u0026hellip; $$\n$$ [1, e^{j\\frac{2\\pi}{\\lambda}d \\sin \\theta_m}, e^{j\\frac{2\\pi}{\\lambda}2d \\sin \\theta_m}, \u0026hellip;, e^{j\\frac{2\\pi}{\\lambda}(n-1)d \\sin \\theta_m}] $$\n其中$m$为所需要扫描的角度个数。上述一系列相移系数使得相控阵雷达可以在多个角度进行扫描，但如果每次在形成不同波束时都重新相乘一次，那么必然会消耗掉大量的运算资源。如果我们对于各个角度值可以舍去一些精度，从而作一些近似，那么可以作如下近似\n$$ [1, e^{j\\frac{2\\pi}{N}0\\cdot 1}, e^{j\\frac{2\\pi}{N}0\\cdot 2}, \u0026hellip;, e^{j\\frac{2\\pi}{N}0\\cdot (N-1)}] $$\n$$ [1, e^{j\\frac{2\\pi}{N}1\\cdot 1}, e^{j\\frac{2\\pi}{N}1\\cdot 2}, \u0026hellip;, e^{j\\frac{2\\pi}{N}1\\cdot (N-1)}] $$\n$$ \u0026hellip; $$\n$$ [1, e^{j\\frac{2\\pi}{N}(N-1)\\cdot 1}, e^{j\\frac{2\\pi}{N}(N-1)\\cdot 2}, \u0026hellip;, e^{j\\frac{2\\pi}{N}(N-1)\\cdot (N-1)}] $$\n也就是说，我们在$[0, 2\\pi)$上作了等间隔采样，然后用这些采样值来近似各个角度值。这种做法虽然牺牲了一些精确度，但却使得可以用$\\text{FFT}$来解决这个问题，换个角度来说，等间隔采样近似通过牺牲精确度来换取性能。\n当看到数字波束形成时，第一个想到的是什么呢？总之我第一个想到的是毫米波雷达的角度测量方法。毫米波雷达的角度测量方法也是使用多个天线，然后使用比相法来测量角度，这个本质是因为天线之间的间隔导致相位按照某一频率变化，而这个频率可以通过$\\text{FFT}$捕捉到，因此可以反推出目标角度。数字波束形成的原理也是如此。\n","permalink":"https://bingsz.github.io/en/posts/dbf/","summary":"\u003cp\u003e  漫谈系列是我在平时突然想到的一些东西的随笔，所以文中可能有不严谨的表达。这篇文章是我突然想到多普勒滤波器组和数字波束形成方面的联系，所以就记录下来。\u003c/p\u003e","title":"漫谈：数字波束形成"},{"content":" 最近学到了陈伯孝的《现代雷达系统的分析与设计》中的CFAR部分，里面有一些结论并没有给出严谨证明，在这里进行补充证明。\n1. 前置知识：噪声概率分布 在雷达信号处理中，通常使用中频正交采样的方式，将接收到的信号转换成两路$\\text{IQ}$信号，而在处理时再将两路信号合成为一路复信号，如下所示\n$$ r(t)=A(t) e^{j2\\pi f_0\\ t + \\phi(t)} $$\n其中$r(t)$表示接收到的信号，$A(t)$表示信号振幅，$f_0$表示载频，$\\phi(t)$表示接收信号的相位变化。\n在目标检测方法中，一般是设立一个门限值，若接收到的信号振幅超过这个门限值，则表明有目标存在，反之则没有目标存在。因此目标检测理论中的一个重要问题便是如何去寻找这个门限值。为了讨论这个问题，我们要引入两个定义，一个是检测概率，记为$P_d$，表示当目标存在时，系统将其检测出来的概率；另一个是虚警概率，记为$P_{fd}$，表示当回波信号仅存在噪声时，系统误警的概率。\n为了方便讨论，接下来仅考虑非起伏目标的检测，即目标回波的振幅不发生变化。假设$\\text{IQ}$通道中的两路噪声均服从零均值、方差为$\\sigma_n^2$的正态分布，概率密度函数如下所示\n$$ P_n(r) = \\frac{1}{\\sqrt{2\\pi} \\sigma_n}e^{-\\frac{r^2}{2\\sigma_n^2}} $$\n由于$\\text{IQ}$两路均存在噪声，因此合成之后的噪声振幅服从瑞利分布，接下来推导瑞利分布的概率密度函数。记$r_a$为合成噪声的振幅，定义如下所示\n$$ r_a = \\sqrt{r_I^2+r_Q^2} $$\n记$F_{r_I^2}(r)$为$r_I^2$的分布函数，于是有\n$$ F_{r_I^2}(r) = P_n(-\\sqrt{r} \\leq x \\leq \\sqrt{r}) = \\frac{1}{\\sqrt{2\\pi} \\sigma_n}\\int_{-\\sqrt{r}}^{\\sqrt{r}}e^{-\\frac{x^2}{2\\sigma_n^2}} \\mathrm{d}x \\tag{1.1} $$\n记$P_{r_I^2}$为$r_I^2$的概率密度函数，则有\n$$ P_{r_I^2}(r) = \\frac{\\mathrm{d}F_{r_I^2}(r)}{\\mathrm{d}r} = \\frac{1}{\\sqrt{2\\pi} \\sigma_n}\\frac{1}{\\sqrt{r}}e^{-\\frac{r}{2\\sigma_n^2}} \\tag{1.2} $$\n对于$r_Q^2$同理，有\n$$ P_{r_Q^2}(r) = \\frac{1}{\\sqrt{2\\pi} \\sigma_n}\\frac{1}{\\sqrt{r}}e^{-\\frac{r}{2\\sigma_n^2}} $$\n记$P_A(r)$为$r_I^2+r_Q^2$的概率密度函数，则有\n$$ \\begin{align*} P_A(r)=\u0026amp;P_{r_I^2}(r)*P_{r_Q^2}(r) \\\\ =\u0026amp; \\frac{e^{-\\frac{r}{2\\sigma_n^2}}}{2\\pi \\sigma_n^2}\\int_{0}^{r}\\frac{1}{\\sqrt{\\tau}}\\frac{1}{\\sqrt{r-\\tau}} \\mathrm{d} \\tau \\\\ =\u0026amp; \\frac{e^{-\\frac{r}{2\\sigma_n^2}}}{2\\sigma_n^2} \\tag{1.3} \\end{align*} $$\n其中，$*$表示卷积。当$\\sigma_n^2=1$时，上式就是自由度为2的卡方分布。与$(1.1)$式、$(1.2)$式的推导方法相同，可得到$r_a$的概率密度函数。\n$$ F_{r_a}(r) = P_A(x \\leq r^2) = \\frac{1}{2\\sigma_n^2}\\int_{0}^{r^2}e^{-\\frac{x}{2\\sigma_n^2}}\\mathrm{d}x $$\n$$ P_{r_a}(r) = \\frac{\\mathrm{d}F_{r_a}(r)}{\\mathrm{d}r} = \\frac{r}{\\sigma_n^2}e^{-\\frac{r^2}{2\\sigma_n^2}} \\tag{1.4} $$\n$(1.4)$式即为瑞利分布。当然瑞利分布的推导过程并不需要上面那么繁琐，可以假设一个二维正态分布，然后使用这个二维正态分布进行推导，会比上述方法简单许多。如果检波时使用平方律检波，那么噪声的概率密度函数服从$(1.3)$式，为了方便，后续推导时假设使用平方律检波，即噪声振幅服从指数分布。\n2. 前置知识：矩母函数 在介绍下面章节之前，要先介绍一下矩母函数。设$\\xi$为一随机变量，那么记$M_{\\xi}(t)=E[e^{t\\xi}]$为$\\xi$的矩母函数。接下来我们给出几条关于矩母函数的性质。\n性质1： $M_{\\xi}(t)=1+\\frac{\\mu_1t}{1!}+\\frac{\\mu_2t^2}{2!}+\u0026hellip;$，其中$\\mu_1$, $\\mu_2$, \u0026hellip;分别表示$\\xi$的一阶矩、二阶矩、\u0026hellip;\n证明：\n对$e^{t\\xi}$作泰勒展开，由定义得\n$$ \\begin{align*} M_{\\xi}(t)=\u0026amp;\\int_{-\\infty}^{\\infty}e^{t\\xi}P(\\xi)\\mathrm{d}\\xi \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}(1+\\frac{t\\xi}{1!}+\\frac{(t\\xi)^2}{2!}+\u0026hellip;)P(\\xi)\\mathrm{d}\\xi \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}P(\\xi)\\mathrm{d}\\xi + \\frac{t}{1!}\\int_{-\\infty}^{\\infty}\\xi P(\\xi)\\mathrm{d}\\xi+\u0026hellip; \\\\ =\u0026amp; 1+\\frac{\\mu_1t}{1!}+\\frac{\\mu_2t^2}{2!}+\u0026hellip; \\end{align*} $$\n性质2： 设$\\alpha$，$\\beta$为常数，那么$M_{\\alpha \\xi + \\beta}(t) = e^{\\beta t}M_{\\xi}(\\alpha t)$\n证明：\n直接代入公式可得\n$$ \\begin{align*} M_{\\alpha \\xi + \\beta}(t) =\u0026amp; \\int_{-\\infty}^{\\infty}e^{(\\alpha \\xi + \\beta)t}P(\\xi) \\mathrm{d} \\xi \\\\ =\u0026amp; e^{\\beta t}\\int_{-\\infty}^{\\infty}e^{\\alpha \\xi t}P(\\xi) \\mathrm{d} \\xi \\\\ =\u0026amp; e^{\\beta t}M_{\\xi}(\\alpha t) \\end{align*} $$\n性质3： 若$X_1$，$X_2$为两个独立的随机变量，那么有$M_{X_1+X_2}(t)=M_{X_1}(t)M_{X_2}(t)$\n证明：\n由定义得$M_{X_1+X_2}(t)=E[e^{t(X_1+X_2)}]=E[e^{tX_1}e^{tX_2}]$，由于随机变量独立，因此$M_{X_1+X_2}(t)=E[e^{tX_1}]E[e^{tX_2}]$\n定理1： 当$X \\text{~} Ga(\\alpha, \\beta),(\\alpha, \\beta \\in \\mathbb{Z}^+)$时，$M_X(t)=\\frac{1}{(1-\\frac{t}{\\beta})^{\\alpha}}$，其中$Ga(\\alpha, \\beta)$为伽马分布。\n证明：\n已知$X$的概率密度函数为\n$$ P(x) = \\frac{\\beta^{\\alpha}}{(\\alpha-1)!}x^{\\alpha-1}e^{-x \\beta} $$\n将上式代入矩母函数中可得\n$$ \\begin{align*} M_{X}(t) =\u0026amp; \\int_{0}^{\\infty}\\frac{\\beta^{\\alpha}}{(\\alpha-1)!}x^{\\alpha-1}e^{x(t - \\beta)} \\mathrm{d}x \\\\ =\u0026amp; \\frac{\\beta^{\\alpha}}{(\\beta - t)^{\\alpha}} = \\frac{1}{(1-\\frac{t}{\\beta})^{\\alpha}} \\tag{2.1} \\end{align*} $$\n3. CA-CFAR原理及仿真 3.1. CA-CFAR原理 首先来介绍CA-CFAR（单元平均CFAR）的工作原理以及背后的概率证明。对回波信号进行采样，共有$N$个采样点，记为$x[i](i \\in {0, 1, \u0026hellip;, N-1})$。现要判断$x[k]$是否为目标回波，CA-CFAR的做法是，首先取一系列参考点，随后计算这些点的和，记为$x_0$，选定一个系数$K$，若$x[k]$大于$Kx_0$，则该采样点判断为目标回波\n首先来考虑取一系列参考点这个操作。通常来说，这一系列点在待检测点的周围，但又间隔一定距离。例如待检测点为$x[k]$，通常选取$x[k-D-\\frac{M}{2}]$, $x[k-D-\\frac{M}{2}+1]$, \u0026hellip;, $x[k-D-1]$, $x[k+D+1]$, $x[k+D+2]$, \u0026hellip;, $x[k+D+\\frac{M}{2}]$。其中$x[k-D]$, $x[k-D+1]$, \u0026hellip;, $x[k-1]$, $x[k+1]$, \u0026hellip;, $x[k+D]$表示保护单元，用于消除与待检测点之间的相关性，同时为了防止长目标回波信号被自身淹没。\n然后我们来计算发生虚警的概率，已知此时门限值为$Kx_0$，于是虚警概率的期望可表示为\n$$ E[P_{fd}] = E[P_{r_a}(r \\geq Kx_0)] = E[\\int_{Kx_0}^{\\infty}\\frac{e^{-\\frac{r}{2\\sigma_n^2}}}{2\\sigma_n^2}\\mathrm{d}r] = E[e^{-\\frac{Kx_0}{2\\sigma_n^2}}] \\tag{3.1} $$\n因此虚警概率的期望为$M_{x_0}(-\\frac{K}{2\\sigma_n^2})$，其中$M_{x_0}(\\cdot)$为矩母函数。首先我们来求$x_0$的概率密度函数，当只有两点相加时，有\n$$ P_{x_0}(r) = \\frac{1}{4\\sigma_n^4} \\int_{0}^{r}e^{-\\frac{r}{2\\sigma_n^2}}\\mathrm{d}\\tau = \\frac{r}{4\\sigma_n^4}e^{-\\frac{r}{2\\sigma_n^2}} $$\n当三点相加时，有\n$$ P_{x_0}(r) = \\frac{1}{8\\sigma_n^6} \\int_{0}^{r}\\tau e^{-\\frac{r}{2\\sigma_n^2}}\\mathrm{d}\\tau = \\frac{1}{8\\sigma_n^6}\\frac{r^2}{2}e^{-\\frac{r}{2\\sigma_n^2}} $$\n归纳可得，当$M$点相加时，有\n$$ P_{x_0}(r) = \\frac{1}{(2\\sigma_n^2)^M}\\frac{r^{M-1}}{(M-1)!}e^{-\\frac{r}{2\\sigma_n^2}} $$\n事实上，上述便是伽马分布的概率密度函数。因此$(3.1)$即为伽马分布的矩母函数，将其代入到之前所求的公式中，可得\n$$ E[P_{fd}] = E[e^{-\\frac{Kx_0}{2\\sigma_n^2}}] = M_{x_0}(-\\frac{K}{2\\sigma_n^2}) = \\frac{1}{(1+K)^{M}} \\tag{3.2} $$\n因此，当给定一个虚警概率$P_{fd}$，与所选点数$M$时，可通过$(3.2)$式求得$K$，从而确定对于某一个待检测点的门限值。\n3.2. CA-CFAR的Matlab仿真 接下来进行Matlab仿真，假设虚警概率$P_{fd}=10^{-6}$，所选参考点数为10个，保护单元个数为20个，代入$(3.2)$中可求得$K \\approx 3$。于是可编写如下Matlab代码\nK = 3; % 阈值为3 M = 10; % 参考单元共10个 D = 20; % 保护单元共20个 t = 0:0.001:1; x = zeros(1, length(t)); x(150:155) = 20; % 模拟目标回波信号 x = awgn(complex(x), -10); % 加入噪声 x = abs(x).^2; % 模拟平方律检波 figure plot(x) % 绘制回波信号图 hold on T = zeros(1, length(t)); for i = (M+D)/2+1 : length(t)-(M+D)/2 T(i) = sum(x(i-(M+D)/2 : i-D/2)) + sum(x(i+D/2 : i+(M+D)/2)); % 计算自适应门限 end plot(T \\* K) % 绘制门限图 图1：仿真结果（仅截取部分）\r其中橙色线为门限值，蓝色线为回波信号。可以看到在保护单元个数与阈值选取合理的情况下，较好地进行了目标检测。\n4. GO-CFAR原理及仿真 4.1. GO-CFAR原理 与CA-CFAR的原理类似，GO-CFAR（最大选择CFAR）在计算门限值的时候取$K\\max(x[i])$来作为门限值，其中$x[i]$为选择的参考点。接下来我们来计算在这种情况下对应的虚警概率。与前面的步骤同理，我们首先来求出$\\max(x[i])$服从的概率分布。若记$F_m(r)$为$\\max(x[i])$的分布函数，那么有\n$$ F_m(r) = P(x[i] \\leq r) = F_x(r)^M $$\n于是可得$\\max(x[i])$的概率密度函数为\n$$ P_m(r) = \\frac{\\mathrm{d}F_m(r)}{\\mathrm{d}r} = M P_x(r) F_x(r)^{M-1} = \\frac{M}{2\\sigma_n^2}e^{-\\frac{r}{2\\sigma_n^2}}(1 - e^{-\\frac{r}{2\\sigma_n^2}})^{M-1} \\tag{4.1} $$\n与$(3.1)$相同的推导方法，可得在这种情况下的虚警概率为\n$$ E[P_{fd}] = E[e^{-\\frac{Kx_m}{2\\sigma_n^2}}] $$\n其中$x_m$为$\\max(x[i])$。将$(4.1)$式代入上式，可得\n$$ \\begin{align*} E[P_{fd}] =\u0026amp; E[e^{-\\frac{Kx_m}{2\\sigma_n^2}}] \\\\ =\u0026amp; \\frac{M}{2\\sigma_n^2}\\int_{0}^{\\infty}e^{-\\frac{Kr}{2\\sigma_n^2}}e^{-\\frac{r}{2\\sigma_n^2}}(1 - e^{-\\frac{r}{2\\sigma_n^2}})^{M-1}\\mathrm{d}r \\\\ =\u0026amp; M\\int_{0}^{1}t^{K}(1-t)^{M-1}\\mathrm{d}t\\ (t \\rightarrow e^{-\\frac{r}{2\\sigma_n^2}}) \\tag{4.2} \\end{align*} $$\n若假设$K$为正整数，则对$\\int_{0}^{1}t^{K+1}(1-t)^{M-1}\\mathrm{d}t$反复使用分部积分法，可得\n$$ \\begin{align*} \\int_{0}^{1}t^{K}(1-t)^{M-1}\\mathrm{d}t =\u0026amp; -\\frac{1}{M}\\int_{0}^{1}t^{K}\\mathrm{d}(1-t)^{M} \\\\ =\u0026amp; \\frac{K}{M}\\int_{0}^{1}(1-t)^{M}t^{K-1}\\mathrm{d}t \\\\ =\u0026amp;\u0026hellip; \\\\ =\u0026amp; \\frac{K!}{M(M+1)\u0026hellip;(K+M-1)}\\int_{0}^{1}(1-t)^{K+M-1} \\mathrm{d}t \\\\ =\u0026amp; \\frac{(M-1)!K!}{(K+M)!} \\tag{4.3} \\end{align*} $$\n将$(4.3)$式代入$(4.2)$式，可得\n$$ E[P_{fd}] = \\frac{M!K!}{(K+M)!} $$\n当$K$为一个正实数时，由于笔者水平问题，此处只给出一个级数表达式\n$$ \\begin{align*} E[P_{fd}] =\u0026amp; M\\int_{0}^{1}t^{K}(1-t)^{M-1}\\mathrm{d}t \\\\ =\u0026amp; K\\int_{0}^{1}(1-t)^{M}t^{K-1}\\mathrm{d}t \\\\ =\u0026amp; K\\int_{0}^{1}(t^{\\frac{K-1}{M}} - t^{\\frac{K-1}{M}+1})^{M} \\mathrm{d}t \\\\ =\u0026amp; K\\int_{0}^{1}\\sum_{j=0}^{M}{M \\choose j} t^{K+M-1-j}(-1)^{M-j}\\mathrm{d}t \\\\ =\u0026amp; K\\sum_{j=0}^{M}{M \\choose j} \\frac{(-1)^{M-j}}{K+M-j} \\tag{4.4} \\end{align*} $$\n4.2. GO-CFAR仿真 假设虚警概率$P_{fd}=10^{-6}$，所选参考点数为10个，保护单元个数为20个，代入计算机穷举可求得$K \\approx 12.75$。于是可编写如下Matlab代码\nK = 12.75; % 阈值为12.75 M = 10; % 参考单元共10个 D = 20; % 保护单元共20个 t = 0:0.001:1; x = zeros(1, length(t)); x(150:155) = 20; % 模拟目标回波信号 x = awgn(complex(x), -10); % 加入噪声 x = abs(x).^2; % 模拟平方律检波 figure plot(x) % 绘制回波信号图 hold on T = zeros(1, length(t)); for i = (M+D)/2+1 : length(t)-(M+D)/2 T(i) = max([x(i-(M+D)/2 : i-D/2), x(i+D/2 : i+(M+D)/2)]); % 计算自适应门限 end disp(sum(T\\*K \u0026lt; x) - M - D) plot(T \\* K) % 绘制门限图 图2：仿真结果（仅截取部分）\r与3.2节相同，橙色线为门限值，蓝色线为回波信号。可以看到相较于CA-CFAR，GO-CFAR可能具有更低的检测概率，相对而言，在杂波边缘便能取得更好的效果。\n5. SO-CFAR原理及仿真 5.1. SO-CFAR原理 与GO-CFAR的原理类似，不同的是SO-CFAR（最小选择CFAR）在计算门限值的时候取$K\\min(x[i])$来作为门限值。沿用4.1节的记号，可得\n$$ F_m(r) = 1 - P(x_m \u0026gt; r) = 1 - (1 - F_x(r))^M = 1 - e^{-\\frac{Mr}{2\\sigma_n^2}} $$\n$$ P_m(r) = \\frac{M}{2\\sigma_n^2}e^{-\\frac{Mr}{2\\sigma_n^2}} $$\n根据$(3.1)$式可得\n$$ \\begin{align*} E[P_{fd}] =\u0026amp; E[e^{-\\frac{Kx_m}{2\\sigma_n^2}}] \\\\ =\u0026amp; \\frac{M}{2\\sigma_n^2}\\int_{0}^{\\infty}e^{-\\frac{K+M}{2\\sigma_n^2}r} \\mathrm{d}r \\\\ =\u0026amp; \\frac{M}{K+M} \\tag{5.1} \\end{align*} $$\n5.2. SO-CFAR仿真 当所选参考点数为10个，保护单元个数为20个，$K = 100$时，代入$(5.1)$可求得虚警概率为$9.1\\%$。于是可编写如下Matlab代码\nK = 100; % 阈值为100 M = 10; % 参考单元共10个 D = 20; % 保护单元共20个 t = 0:0.001:1; x = zeros(1, length(t)); x(150:155) = 20; % 模拟目标回波信号 x = awgn(complex(x), -10); % 加入噪声 x = abs(x).^2; % 模拟平方律检波 figure plot(x) % 绘制回波信号图 hold on T = zeros(1, length(t)); for i = (M+D)/2+1 : length(t)-(M+D)/2 T(i) = min([x(i-(M+D)/2 : i-D/2-1), x(i+D/2+1 : i+(M+D)/2)]); % 计算自适应门限 end disp(sum(T\\*K) / (length(t) - M - D)) disp(sum(T\\*K \u0026lt; x) - M - D) plot(T \\* K) % 绘制门限图 图3：仿真结果（仅截取部分）\r可以看到，此时的虚警概率比较高，但同时如果加大门限阈值，会使得目标检测变得困难，这是SO-CFAR的一个缺点。\n","permalink":"https://bingsz.github.io/en/posts/cfarprob/","summary":"\u003cp\u003e  最近学到了陈伯孝的《现代雷达系统的分析与设计》中的CFAR部分，里面有一些结论并没有给出严谨证明，在这里进行补充证明。\u003c/p\u003e","title":"CFAR中的概率问题证明"},{"content":" 最近笔者学到频率步进脉冲雷达的相参积累，觉得其中的原理比较有趣，所以作一个记录。\n1. 矩形调幅脉冲雷达的相参积累方法 在讨论频率步进脉冲雷达的相参积累前，先来复习一下普通矩形调幅脉冲雷达的相参积累方法。假设积累脉冲数为$M$，如果目标无多普勒频移，那么此时积累的方法便是将积累脉冲简单相加（假设各重复脉冲的初始相位相等），如下所示\n$$ x[n] = \\sum_{k=0}^{M-1}x_{k}[n] $$\n其中$x[n]$表示积累后的输出，$x_k[n]$表示第$k$个积累脉冲在第$n$个采样点的值。如果记噪声的功率为$\\sigma_n^2$，那么$M$个噪声求和之后得到的功率为$M\\sigma_n^2$，而信号功率由于与振幅的平方成正比，因此有信号功率$S = N^2S_0$，于是改善后的信噪比为\n$$ \\text{SNR}=\\frac{S}{N} = \\frac{M^2}{M}\\frac{S_0}{\\sigma_n^2} = M\\text{SNR}_0 $$\n其中$\\text{SNR}_0$为单个脉冲的信噪比。\n换言之，如果目标存在多普勒频移$f_d$，那就需要对接收的脉冲作一个频移补偿$-f_d$，以此抵消多普勒频移，从而使接收信号振幅之和最大。此时的积累方法如下所示\n$$ x[n] = \\sum_{k=0}^{M-1}x_{k}[n]e^{-j2\\pi f_d\\ T_r} \\tag{1.1} $$\n其中$T_r$为脉冲重复周期。但是由于事先并不知道目标的多普勒频移，因此一个实用的方法是对$x_k[n]$在$k$方向上作$\\text{FFT}$，从而得到各个频率处的积累。事实上，在$k$方向上作$\\text{FFT}$对应的便是慢时间维$\\text{FFT}$。换言之，慢时间维$\\text{FFT}$本质上是一种相参积累。\n从相参积累的角度也可以推导出毫米波雷达中的测速公式，若慢时间维$\\text{FFT}$上的尖峰位于$n_0$处，那么由$(1.1)$可得目标多普勒频移为\n$$ f_d = \\frac{n_0f_r}{N} = \\frac{n_0}{NT_r} $$\n其中$N$为采样点数（与刚刚信噪比处的$N$不同）。\n于是可得目标速度为\n$$ v = \\frac{\\lambda f_d}{2} = \\frac{\\lambda n_0}{2NT_r} $$\n与毫米波雷达的测速公式相同。\n2. 频率步进脉冲雷达的相参积累方法 从前文已经知道，矩形调幅脉冲雷达的相参积累方法是对积累脉冲在慢时间维上作$\\text{FFT}$，那么频率步进脉冲雷达的相参积累方法是什么样的呢。考虑如下频率步进脉冲信号\n$$ u(t) = \\sum_{k=0}^{N-1}e^{j2\\pi (f_0+k\\Delta f) t}W_T(t - kT_r) $$\n其中$W(t)$如下定义\n$$ W(t)=\\begin{cases} 1,\\ \\ \\ \\ \u0026amp;0 \\leq t \\leq T \\\\ 0, \u0026amp;Others \\end{cases} $$\n假设回波信号仅仅是发射信号的一个延迟，于是回波信号如下所示\n$$ \\begin{align*} u_r(t) =\u0026amp; \\sum_{k=0}^{N-1}e^{j2\\pi (f_0+k\\Delta f) (t-\\tau)}W_T(t - \\tau - kT_r) \\\\ =\u0026amp; \\sum_{k=0}^{N-1}e^{j2\\pi f_0 (t-\\tau)}W_T(t - \\tau - kT_r)e^{-j2\\pi k\\Delta f(t-\\tau)} \\end{align*} $$\n可以发现，回波信号相当于对处于基础频率$f_0$的回波信号作了一个傅里叶变换。那么从这个公式就可以发现，如果要对频率步进脉冲雷达作相参积累，只需要对积累信号作逆傅里叶变换即可。\n对脉冲积累序列作逆傅里叶变换可得\n$$ u_d[n] = \\frac{1}{N}\\sum_{k=0}^{N-1}e^{j2\\pi f_0 (t - \\tau)} W_T(t-\\tau) e^{-j2\\pi k (t\\Delta f - \\tau \\Delta f - \\frac{n}{N})} $$\n当$0 \\leq |t-\\tau| \\leq T$时，有\n$$ \\begin{align*} u_d[n] =\u0026amp; \\frac{1}{N}e^{j2\\pi f_0 (t - \\tau)}\\sum_{k=0}^{N-1}e^{-j2\\pi k (t\\Delta f - \\tau \\Delta f - \\frac{n}{N})} \\\\ =\u0026amp; \\frac{1}{N}e^{j2\\pi f_0 (t - \\tau)} \\frac{1-e^{-j2\\pi (Nt\\Delta f - N \\tau \\Delta f - n)}}{1-e^{-j2\\pi (t\\Delta f - \\tau \\Delta f - \\frac{n}{N})}} \\\\ =\u0026amp; \\frac{1}{N}e^{j2\\pi f_0 (t - \\tau)}\\frac{e^{-j\\pi (Nt\\Delta f - N \\tau \\Delta f - n)}}{e^{-j\\pi (t\\Delta f - \\tau \\Delta f - \\frac{n}{N})}} \\frac{\\sin(\\pi (Nt\\Delta f - N \\tau \\Delta f - n))}{\\sin(\\pi (t\\Delta f - \\tau \\Delta f - \\frac{n}{N}))} \\end{align*} $$\n于是模为\n$$ |u_d[n]| = \\frac{1}{N}|\\frac{\\sin(\\pi (Nt\\Delta f - N \\tau \\Delta f - n))}{\\sin(\\pi (t\\Delta f - \\tau \\Delta f - \\frac{n}{N}))}| $$\n其它情况下，$u_d[n]$为$0$。因此可得时间差$\\Delta t$为\n$$ \\Delta t = t - \\tau = \\frac{n_0}{N\\Delta f} $$\n其中$n_0$为模最大值处的序号。由上式可得最大不模糊时间差为\n$$ \\Delta t_{max} = \\frac{1}{\\Delta f} $$\n因此，一个$\\Delta f$的良好定义可以是$\\frac{1}{T_s}$，其中$T_s$为采样间隔。在不考虑其它因素的情况下，这可使在不产生模糊的情况下，有最大的时间分辨率。\n从上式可以看出，对频率步进脉冲信号作相参积累相当于在不提高采样频率的情况下，扩展了原有的分辨率。原时间分辨率为$T_s$，而经过相参积累后，时间分辨率可达到$\\frac{T_s}{N}$。\n总结一下上文提到的频率步进脉冲信号的相参积累方法。首先对每个脉冲回波进行采样，得到一个$M \\times N$的二维矩阵$X_{M, N}$，其中$M$为积累脉冲数，$N$为对每一个回波信号的采样点数。因此该矩阵的每一行为一个脉冲的$N$点采样。随后，在这个二维矩阵的列方向进行逆$\\text{FFT}$，得到更精细的距离分辨率。最后将该二维矩阵进行重排，合成一个具有高距离分辨率的回波信号。\n3. Matlab仿真 Ts = 0.1; % 假设ADC采样间隔0.1s，同时假设脉冲长度即为Ts n = 10; % 采样点数10个 m = 5; % 积累脉冲数5个 f0 = 10; % 基频10Hz df = 10; % 频率步进步长10Hz dt1 = 0.22; % 第一个目标回波时间为0.22s dt2 = 0.27; % 第二个目标回波时间为0.27s w = zeros(m, n); % m * n的二维矩阵 for i = 1:m tmp = exp(1i * 2 * pi * f0 * (floor(dt / Ts)+1 - dt1)) .* exp(-1i * 2 * pi * (i - 1) * df * dt1); % 计算回波信号 w(i, floor(dt / Ts)+1) = w(i, floor(dt / Ts)+1) + tmp; % 默认目标回波仅占一个单元 end for i = 1:m tmp = exp(1i * 2 * pi * f0 * (floor(dt / Ts)+1 - dt2)) .* exp(-1i * 2 * pi * (i - 1) * df * dt2); w(i, floor(dt / Ts)+1) = w(i, floor(dt / Ts)+1) + tmp; end w = awgn(w, 10); % 添加噪声，信噪比10dB for i = 1:n w(:, i) = abs(ifft(w(:, i)\u0026#39;)\u0026#39;); % 进行相参积累 end ret = zeros(1, m*n); for i = 1:n ret((i-1)*m+1:i*m) = w(:, i)\u0026#39;; % 进行重排 end plot(ret) Matlab程序如上所示，设置脉冲宽度为0.1s，而目标出现在0.22s与0.27s处，理论上无法将两个目标分开。而经过相参积累后，便可以将两个目标分开，结果如下所示\n图1：两种方法比较\r","permalink":"https://bingsz.github.io/en/posts/steppedfreqcoherentint/","summary":"\u003cp\u003e  最近笔者学到频率步进脉冲雷达的相参积累，觉得其中的原理比较有趣，所以作一个记录。\u003c/p\u003e","title":"频率步进脉冲雷达的相参积累"},{"content":" 在陈伯孝的《现代雷达系统分析与设计》中给出了模糊函数的若干性质，但书上缺少了详细证明，此处给出这些性质的详细证明。\n0. 模糊函数的频域形式 $$ \\chi(\\tau, f_d\\ ) = \\int_{-\\infty}^{\\infty}u(t)u^*(t+\\tau)e^{j2\\pi f_d\\ t} \\mathrm{d}t = \\int_{-\\infty}^{\\infty}U(f-f_d\\ )U^*(f)e^{-j2\\pi f \\tau} \\mathrm{d}f $$\n证明：\n记$u(t)$的傅里叶变换为$U(f)$，则$u^*(t)e^{-j2\\pi f_dt}$的傅里叶变换为$U^*(-f-f_d)$，$u^*(t+\\tau)$的傅里叶变换为$U^*(-f)e^{j2\\pi f\\tau}$\n根据帕塞瓦尔定理可得\n$$ \\begin{align*} \\chi(\\tau, f_d)=\u0026amp;\\int_{-\\infty}^{\\infty}u(t)u^*(t+\\tau)e^{j2\\pi f_d t} \\mathrm{d}t \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}U(-f-f_d)U^*(-f)e^{j2\\pi f\\tau} \\mathrm{d}f \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}U(f-f_d)U^*(f)e^{-j2\\pi f \\tau} \\mathrm{d}f \\end{align*} $$\n1. 关于原点的对称性 $$ |\\chi(\\tau, f_d\\ )| = |\\chi(-\\tau, -f_d\\ )| $$\n证明：\n由定义得\n$$ \\begin{align*} \\chi(-\\tau, -f_d\\ ) =\u0026amp; \\int_{-\\infty}^{\\infty}u(t)u^*(t-\\tau)e^{-j2\\pi f_d\\ t} \\mathrm{d} t \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}u(t+\\tau)u^*(t)e^{-j2\\pi f_d\\ (t+\\tau)} \\mathrm{d} t \\text{(令}t-\\tau \\rightarrow t\\text{)} \\\\ =\u0026amp; e^{-j2\\pi f_d\\ \\tau}[\\int_{-\\infty}^{\\infty}u(t)u^*(t+\\tau)e^{j2\\pi f_d\\ t} \\mathrm{d} t]^* \\\\ =\u0026amp; e^{-j2\\pi f_d\\ \\tau}\\chi^*(\\tau, f_d\\ ) \\end{align*}$$\n因此\n$$ |\\chi(\\tau, f_d\\ )| = |\\chi(-\\tau, -f_d\\ )| $$\n2. 原点的最大值性 $$ |\\chi(\\tau, f_d\\ )| \\leq |\\chi(0, 0)| $$\n证明：\n由定义式可知\n$$ \\begin{align*} |\\chi(\\tau, f_d\\ )| =\u0026amp; |\\int_{-\\infty}^{\\infty}u(t)u^*(t+\\tau)e^{j2\\pi f_d\\ t} \\mathrm{d} t| \\\\ \\leq \u0026amp;\\int_{-\\infty}^{\\infty}|u(t)u^*(t+\\tau)e^{j2\\pi f_d\\ t}| \\mathrm{d} t \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}|u(t)u^*(t+\\tau)| \\mathrm{d} t \\tag{2.1} \\end{align*}$$\n对$|\\chi(0, 0)|$，有\n$$ |\\chi(0, 0)| = \\int_{-\\infty}^{\\infty}u(t)u^*(t) \\mathrm{d} t = \\int_{-\\infty}^{\\infty}|u(t)u^*(t)| \\mathrm{d} t \\tag{2.2} $$\n比较$(2.1)$与$(2.2)$可知\n$$ |\\chi(\\tau, f_d\\ )| \\leq |\\chi(0, 0)| $$\n3. 模糊体积不变性 $$ \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} |\\chi(\\tau, f_d\\ )|^2 \\mathrm{d} \\tau \\mathrm{d} f_d\\ = |\\chi(0, 0)|^2 $$\n证明：\n已知\n$$ \\begin{align*} \u0026amp;\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} |\\chi(\\tau, f_d\\ )|^2 \\mathrm{d} \\tau \\mathrm{d} f_d\\ \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty}u(t_1)u^*(t_1+\\tau)e^{j2\\pi f_d\\ t_1} \\mathrm{d} t_1 \\int_{-\\infty}^{\\infty}u^*(t_2)u(t_2+\\tau)e^{-j2\\pi f_d\\ t_2} \\mathrm{d} t_2 \\mathrm{d} \\tau \\mathrm{d} f_d\\ \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t_1)u^*(t_1+\\tau)u^*(t_2)u(t_2+\\tau)e^{j2\\pi f_d\\ (t_1-t_2)} \\mathrm{d}t_1\\mathrm{d}t_2\\mathrm{d}\\tau\\mathrm{d}f_d\\ \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t_1)u^*(t_1+\\tau)u^*(t_2)u(t_2+\\tau)\\int_{-\\infty}^{\\infty}e^{j2\\pi f_d\\ (t_1-t_2)} \\mathrm{d}f_d\\mathrm{d}t_1\\mathrm{d}t_2\\mathrm{d}\\tau\\ \\tag{3.1} \\end{align*} $$\n考虑常函数$y(\\omega)=1$的逆傅里叶变换，我们有\n$$ \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}e^{j\\omega t} \\mathrm{d}\\omega=\\delta(t) $$\n因此可得\n$$ \\int_{-\\infty}^{\\infty}e^{j2\\pi f t} \\mathrm{d}f = \\delta(t) $$\n于是$(3.1)$可变为\n$$ \\begin{align*} \u0026amp;\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} |\\chi(\\tau, f_d\\ )|^2 \\mathrm{d} \\tau \\mathrm{d} f_d\\ \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t_1)u^*(t_1+\\tau)u^*(t_2)u(t_2+\\tau)\\delta(t_1-t_2)\\mathrm{d}t_1\\mathrm{d}t_2\\mathrm{d}\\tau \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t)u^*(t+\\tau)u^*(t)u(t+\\tau)\\mathrm{d}t\\mathrm{d}\\tau \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t+\\tau)u^*(t+\\tau)\\mathrm{d}\\tau u(t)u^*(t)\\mathrm{d}t \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t+\\tau)u^*(t+\\tau)\\mathrm{d}(t+\\tau) u(t)u^*(t)\\mathrm{d}t \\\\ =\u0026amp; [\\int_{-\\infty}^{\\infty}u(t)u^*(t)\\mathrm{d}t]^2 = |\\chi(0, 0)|^2 \\end{align*} $$\n4. 自变换特性 $$ \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} |\\chi(\\tau, f_d\\ )|^2 e^{j2\\pi (f_d\\ x - \\tau y)} \\mathrm{d} \\tau \\mathrm{d} f_d\\ = |\\chi(x, y)|^2 $$\n证明：\n前半过程与性质3证明类似，可得\n$$ \\begin{align*} \u0026amp;\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} |\\chi(\\tau, f_d\\ )|^2 \\mathrm{d} \\tau \\mathrm{d} f_d\\ \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t_1)u^*(t_1+\\tau)u^*(t_2)u(t_2+\\tau)e^{-j2\\pi \\tau y}\\int_{-\\infty}^{\\infty}e^{j2\\pi f_d\\ (t_1-t_2+x)} \\mathrm{d}f_d\\mathrm{d}t_1\\mathrm{d}t_2\\mathrm{d}\\tau \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t_1)u^*(t_1+\\tau)u^*(t_2)u(t_2+\\tau)e^{-j2\\pi \\tau y}\\delta(t_1-t_2+x)\\mathrm{d}t_1\\mathrm{d}t_2\\mathrm{d}\\tau \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t)u^*(t+\\tau)u^*(t+x)u(t+x+\\tau)e^{-j2\\pi \\tau y}\\mathrm{d}t\\mathrm{d}\\tau \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}[\\int_{-\\infty}^{\\infty}u(t+\\tau)u^*(t+x+\\tau)e^{j2\\pi (t+\\tau)y} \\mathrm{d}(t+\\tau)]^*u(t)u^*(t+x)e^{j2\\pi ty}\\mathrm{d}t \\\\ =\u0026amp; \\chi(x, y)^*\\int_{-\\infty}^{\\infty}u(t)u^*(t+x)e^{j2\\pi ty}\\mathrm{d}t \\\\ =\u0026amp; \\chi(x, y)\\chi(x, y)^* = |\\chi(x, y)|^2 \\end{align*} $$\n5. 模糊体积分布限制 $$ \\int_{-\\infty}^{\\infty}|\\chi(\\tau, f_d\\ )|^2 \\mathrm{d}\\tau = \\int_{-\\infty}^{\\infty}|\\chi(\\tau, 0)|^2 e^{-j2\\pi\\tau f_d\\ } \\mathrm{d}\\tau $$\n$$ \\int_{-\\infty}^{\\infty}|\\chi(\\tau, f_d\\ )|^2 \\mathrm{d}f_d\\ = \\int_{-\\infty}^{\\infty}|\\chi(0, f_d\\ )|^2 e^{j2\\pi\\tau f_d\\ } \\mathrm{d}f_d\\ $$\n证明：\n先证明第一个式子，根据性质0可知等式左边为\n$$ \\begin{align*} \u0026amp;\\int_{-\\infty}^{\\infty}|\\chi(\\tau, f_d\\ )|^2 \\mathrm{d}\\tau \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}U(f_1-f_d\\ )U^*(f_1)e^{-j2\\pi f_1 \\tau} \\mathrm{d}f_1 \\int_{-\\infty}^{\\infty}U^*(f_2-f_d\\ )U(f_2)e^{j2\\pi f_2 \\tau} \\mathrm{d}f_2 \\mathrm{d}\\tau \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}U(f_1-f_d\\ )U^*(f_1)U^*(f_2-f_d\\ )U(f_2)\\int_{-\\infty}^{\\infty}e^{-j2\\pi \\tau (f_1 - f_2)} \\mathrm{d}\\tau\\mathrm{d}f_1 \\mathrm{d}f_2 \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}U(f_1-f_d\\ )U^*(f_1)U^*(f_2-f_d\\ )U(f_2)\\delta(f_1-f_2)\\mathrm{d}f_1 \\mathrm{d}f_2 \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}U(f-f_d\\ )U^*(f)U^*(f-f_d\\ )U(f) \\mathrm{d}f \\end{align*} $$\n而等式右边为\n$$ \\begin{align*} \u0026amp;\\int_{-\\infty}^{\\infty}|\\chi(\\tau, 0)|^2 e^{-j2\\pi \\tau f_d\\ } \\mathrm{d}\\tau \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}U(f_1)U^*(f_1)e^{-j2\\pi f_1 \\tau} \\mathrm{d}f_1 \\int_{-\\infty}^{\\infty}U(f_2)U^*(f_2)e^{j2\\pi f_2 \\tau} \\mathrm{d}f_2 e^{-j2\\pi \\tau f_d\\ } \\mathrm{d}\\tau \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}U(f_1)U^*(f_1)U(f_2)U^*(f_2)\\int_{-\\infty}^{\\infty}e^{-j2\\pi \\tau (f_1 - f_2 + f_d)}\\mathrm{d}\\tau \\mathrm{d}f_1 \\mathrm{d}f_2 \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}U(f_1)U^*(f_1)U(f_2)U^*(f_2)\\delta(f_1 - f_2 + f_d) \\mathrm{d}f_1 \\mathrm{d}f_2 \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}U(f-f_d\\ )U^*(f)U^*(f-f_d\\ )U(f) \\mathrm{d}f \\end{align*} $$\n比较可知，第一个式子等式左右两边相等，因此成立。\n对于第二个式子，等式左边有\n$$ \\begin{align*} \u0026amp;\\int_{-\\infty}^{\\infty}|\\chi(\\tau, f_d\\ )|^2 \\mathrm{d}f_d\\ \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t_1)u^*(t_1+\\tau)e^{j2\\pi f_d\\ t_1} \\mathrm{d} t_1 \\int_{-\\infty}^{\\infty}u^*(t_2)u(t_2+\\tau)e^{-j2\\pi f_d\\ t_2} \\mathrm{d} t_2 \\mathrm{d}f_d\\ \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t_1)u^*(t_1+\\tau) u^*(t_2)u(t_2+\\tau)\\int_{-\\infty}^{\\infty}e^{j2\\pi f_d\\ (t_1 - t_2)} \\mathrm{d}f_d\\ \\mathrm{d} t_1 \\mathrm{d} t_2 \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}u(t)u^*(t+\\tau)u^*(t)u(t+\\tau)\\mathrm{d}t \\end{align*} $$\n等式右边有\n$$ \\begin{align*} \u0026amp;\\int_{-\\infty}^{\\infty}|\\chi(0, f_d\\ )|^2 e^{j2\\pi\\tau f_d\\ } \\mathrm{d}f_d\\ \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t_1)u^*(t_1)e^{j2\\pi f_d\\ t_1} \\mathrm{d} t_1 \\int_{-\\infty}^{\\infty}u(t_2)u^*(t_2)e^{-j2\\pi f_d\\ t_2} \\mathrm{d} t_2 e^{j2\\pi \\tau f_d\\ } \\mathrm{d}f_d\\ \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t_1)u^*(t_1) u(t_2)u^*(t_2) \\int_{-\\infty}^{\\infty} e^{j2\\pi (t_1 - t_2 + \\tau) f_d\\ } \\mathrm{d}f_d\\ \\mathrm{d} t_1 \\mathrm{d} t_2 \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}u(t_1)u^*(t_1) u(t_2)u^*(t_2) \\delta(t_1 - t_2 + \\tau) \\mathrm{d} t_1 \\mathrm{d} t_2 \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}u(t)u^*(t+\\tau)u^*(t)u(t+\\tau)\\mathrm{d}t \\end{align*} $$\n比较可知，第二个式子等式左右两边相等，同样成立。\n6. 组合性质 若$c(t)=a(t)+b(t)$，则有\n$$ \\chi_c(\\tau, f_d\\ ) = \\chi_a(\\tau, f_d\\ ) + \\chi_b(\\tau, f_d\\ ) + \\chi_{ab}(\\tau, f_d\\ ) + e^{-j2\\pi f_d\\ \\tau}\\chi_{ab}^*(-\\tau, -f_d\\ ) $$\n其中，$\\chi_{ab}(\\tau, f_d\\ )$为互模糊函数，如下定义\n$$ \\chi_{ab}(\\tau, f_d\\ ) = \\int_{-\\infty}^{\\infty}a(t)b^*(t+\\tau)e^{j2\\pi f_d\\ t} \\mathrm{d}t $$\n证明：\n将$c(t)$代入模糊函数定义式中，可得\n$$ \\begin{align*} \\chi_c(\\tau, f_d\\ ) =\u0026amp; \\int_{-\\infty}^{\\infty}(a(t)+b(t))(a^*(t+\\tau)+b^*(t+\\tau))e^{j2\\pi f_d\\ t} \\mathrm{d}t \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}a(t)a^*(t+\\tau)e^{j2\\pi f_d\\ t} \\mathrm{d}t \\\\ \u0026amp;+\\int_{-\\infty}^{\\infty}b(t)b^*(t+\\tau)e^{j2\\pi f_d\\ t} \\mathrm{d}t \\\\ \u0026amp;+ \\int_{-\\infty}^{\\infty}a(t)b^*(t+\\tau)e^{j2\\pi f_d\\ t} \\mathrm{d}t \\\\ \u0026amp;+ \\int_{-\\infty}^{\\infty}b(t)a^*(t+\\tau)e^{j2\\pi f_d\\ t} \\mathrm{d}t \\\\ =\u0026amp; \\chi_a(\\tau, f_d\\ ) + \\chi_b(\\tau, f_d\\ ) + \\chi_{ab}(\\tau, f_d\\ ) + \\int_{-\\infty}^{\\infty}b(t)a^*(t+\\tau)e^{j2\\pi f_d\\ t} \\mathrm{d}t \\tag{6.1} \\end{align*} $$\n注意到\n$$ \\begin{align*} \\int_{-\\infty}^{\\infty}b(t)a^*(t+\\tau)e^{j2\\pi f_d\\ t} \\mathrm{d}t =\u0026amp; [\\int_{-\\infty}^{\\infty}a(t+\\tau)b^*(t)e^{-j2\\pi f_d\\ t} \\mathrm{d} t]^* \\\\ =\u0026amp; [\\int_{-\\infty}^{\\infty}a(t)b^*(t-\\tau)e^{-j2\\pi f_d\\ t} \\mathrm{d} t]^* e^{-j2\\pi f_d\\ \\tau} \\text{(令} t \\rightarrow t-\\tau \\text{)} \\\\ =\u0026amp; \\chi_{ab}^*(-\\tau, -f_d\\ )e^{-j2\\pi f_d\\ \\tau} \\tag{6.2} \\end{align*} $$\n将$(6.2)$代入$(6.1)$中，可得\n$$ \\chi_c(\\tau, f_d\\ ) = \\chi_a(\\tau, f_d\\ ) + \\chi_b(\\tau, f_d\\ ) + \\chi_{ab}(\\tau, f_d\\ ) + e^{-j2\\pi f_d\\ \\tau}\\chi_{ab}^*(-\\tau, -f_d\\ ) $$\n7. 时间和频率偏移的影响 若$v(t)=u(t-t_0)e^{j2\\pi f_0\\ (t-t_0)}$，则\n$$ \\chi_v(\\tau, f_d\\ )=e^{j2\\pi (f_d\\ t_0 - f_0\\ \\tau)}\\chi_u(\\tau, f_d\\ ) $$\n证明：\n将$v(t)$代入原公式可得：\n$$ \\begin{align*} \\chi_v(\\tau, f_d) =\u0026amp; \\int_{-\\infty}^{\\infty}v(t)v^*(t+\\tau)e^{j2\\pi f_d t} \\mathrm{d} t \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}u(t-t_0)e^{j2\\pi f_0(t-t_0)}u^*(t-t_0+\\tau)e^{-j2\\pi f_0(t-t_0+\\tau)}e^{j2\\pi f_d t} \\mathrm{d} t \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty} u(t-t_0) u^*(t-t_0+\\tau) e^{-j2\\pi f_0 \\tau}e^{j2\\pi f_d t} \\mathrm{d} t \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty} u(t-t_0) u^*(t-t_0+\\tau) e^{-j2\\pi f_0 \\tau}e^{j2\\pi f_d (t-t_0)}e^{j2\\pi f_d t_0} \\mathrm{d} (t-t_0) \\\\ =\u0026amp; e^{j2\\pi (f_d t_0 - f_0 \\tau)} \\int_{-\\infty}^{\\infty} u(t-t_0) u^*(t-t_0+\\tau) e^{j2\\pi f_d (t-t_0)} \\mathrm{d} (t-t_0) \\\\ =\u0026amp; e^{j2\\pi (f_d t_0 - f_0 \\tau)}\\chi_u(\\tau, f_d) \\end{align*}$$\n8. 信号周期重复的影响 如果单个脉冲信号$u(t)$的模糊函数为$\\chi_u(\\tau, f_d\\ )$，将信号$u(t)$重复$N$个周期得到的信号$v(t)=\\sum_{i=0}^{N-1}c_iu(t-iT_r)$，其中$c_i$表示复加权系数，$T_r$为脉冲重复周期，则$v(t)$的模糊函数为\n$$ \\begin{align*} \\chi_v(\\tau, f_d\\ ) = \\sum_{m=1}^{N-1}e^{j2\\pi f_d\\ mT_r}\\chi_u(\\tau+mT_r, f_d\\ )\\sum_{i=0}^{N-1-m}c_i^*c_{i+m}e^{j2\\pi f_d\\ iT_r} \\\\ + \\sum_{m=0}^{N-1}\\chi_u(\\tau-mT_r, f_d\\ )\\sum_{i=0}^{N-1-m}c_ic_{i+m}^*e^{j2\\pi f_d\\ iT_r} \\end{align*} $$\n证明：\n将$v(t)=\\sum_{i=0}^{N-1}c_iu(t-iT_r)$代入模糊函数的定义式中，得到：\n$$ \\begin{align*} \\chi_v(\\tau, f_d) =\u0026amp; \\int_{-\\infty}^{\\infty}v(t)v^*(t+\\tau)e^{j2\\pi f_d t} \\mathrm{d}t \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty} [\\sum_{i=0}^{N-1}c_iu(t-iT_r) \\sum_{i=0}^{N-1}c_i^*u(t-iT_r+\\tau)]e^{j2\\pi f_d t} \\mathrm{d}t \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}c_ic_j^*u(t-iT_r)u^*(t-jT_r+\\tau)e^{j2\\pi f_dt} \\mathrm{d}t \\tag{8.1} \\end{align*}$$\n考虑积分号内的求和，注意到：\n$$\\begin{align*} \u0026amp;\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}c_ic_j^*u(t-iT_r)u^*(t-jT_r+\\tau) \\\\ =\u0026amp; \\sum_{i=0}^{N-1}\\sum_{j=0,j\u0026lt;i}^{N-1}c_ic_j^*u(t-iT_r)u^*(t-jT_r+\\tau) \\\\ \u0026amp;+\\sum_{i=0}^{N-1}\\sum_{j=0,j \\geq i}^{N-1}c_ic_j^*u(t-iT_r)u^*(t-jT_r+\\tau) \\tag{8.2} \\end{align*}$$\n将$(8.2)$代入$(8.1)$中可得\n$$\\begin{align*} \\chi_v(\\tau, f_d) =\u0026amp;\\int_{-\\infty}^{\\infty} \\sum_{i=0}^{N-1}\\sum_{j=0,j\u0026lt;i}^{N-1}c_ic_j^*u(t-iT_r)u^*(t-jT_r+\\tau) \\\\ \u0026amp;+\\sum_{i=0}^{N-1}\\sum_{j=0,j \\geq i}^{N-1}c_ic_j^*u(t-iT_r)u^*(t-jT_r+\\tau) \\mathrm{d}t \\end{align*}$$\n对于积分号内前一项求和，作增量代换，我们有\n$$ \\begin{align*} \u0026amp;\\sum_{i=0}^{N-1}\\sum_{j=0,j\u0026lt;i}^{N-1}c_ic_j^*u(t-iT_r)u^*(t-jT_r+\\tau) \\\\ =\u0026amp; \\sum_{i=0}^{N-1}\\sum_{m=1}^{i}c_ic^*_{i-m}u(t-iT_r)u^*(t-(i-m)T_r+\\tau) \\\\ =\u0026amp; \\sum_{m=1}^{N-1}\\sum_{i=m}^{N-1}c_ic^*_{i-m}u(t-iT_r)u^*(t-(i-m)T_r+\\tau) \\\\ =\u0026amp; \\sum_{m=1}^{N-1}\\sum_{i=0}^{N-1-m}c_{i+m}c^*_iu(t-(i+m)T_r)u^*(t-iT_r+\\tau) \\end{align*} $$\n根据性质7可得，$u(t-(i+m)T_r)$的自相似度为$e^{j2\\pi f_d(i+m)T_r}\\chi_u(\\tau, f_d)$，因此积分号内前一项求和为\n$$\\begin{align*} \u0026amp;\\int_{-\\infty}^{\\infty} \\sum_{m=1}^{N-1}\\sum_{i=0}^{N-1-m}c_{i+m}c^*_iu(t-(i+m)T_r)u^*(t-iT_r+\\tau)e^{j2\\pi f_dt} \\mathrm{d}t \\\\ =\u0026amp; \\sum_{m=1}^{N-1}\\sum_{i=0}^{N-1-m} c_{i+m}c^*_i \\int_{-\\infty}^{\\infty} u(t-(i+m)T_r)u^*(t-iT_r+\\tau)e^{j2\\pi f_dt} \\mathrm{d}t \\\\ =\u0026amp; \\sum_{m=1}^{N-1}\\sum_{i=0}^{N-1-m} c_{i+m}c^*_i \\\\ \u0026amp; \\int_{-\\infty}^{\\infty} u(t-(i+m)T_r)u^*(t-(i+m)T_r+mT_r+\\tau)e^{j2\\pi f_dt} \\mathrm{d}t \\\\ =\u0026amp; \\sum_{m=1}^{N-1}\\sum_{i=0}^{N-1-m}c_{i+m}c^*_ie^{j2\\pi f_d(i+m)T_r}\\chi_u(\\tau+mT_r, f_d) \\\\ =\u0026amp; \\sum_{m=1}^{N-1}e^{j2\\pi f_d\\ mT_r}\\chi_u(\\tau+mT_r, f_d\\ )\\sum_{i=0}^{N-1-m}c_i^*c_{i+m}e^{j2\\pi f_d\\ iT_r} \\end{align*}$$\n对于积分号内后一项求和同理，因此综合可得\n$$ \\begin{align*} \\chi_v(\\tau, f_d\\ ) = \\sum_{m=1}^{N-1}e^{j2\\pi f_d\\ mT_r}\\chi_u(\\tau+mT_r, f_d\\ )\\sum_{i=0}^{N-1-m}c_i^*c_{i+m}e^{j2\\pi f_d\\ iT_r} \\\\ + \\sum_{m=0}^{N-1}\\chi_u(\\tau-mT_r, f_d\\ )\\sum_{i=0}^{N-1-m}c_ic_{i+m}^*e^{j2\\pi f_d\\ iT_r} \\end{align*} $$\n","permalink":"https://bingsz.github.io/en/posts/ambiguityfuncattribution/","summary":"\u003cp\u003e  在陈伯孝的《现代雷达系统分析与设计》中给出了模糊函数的若干性质，但书上缺少了详细证明，此处给出这些性质的详细证明。\u003c/p\u003e","title":"模糊函数相关性质证明"},{"content":" 目前毫米波雷达芯片，如IWR系列或者AWR系列，采用的测距原理均是通过测量发射脉冲与接收脉冲的频率差来测量距离（与连续波雷达相似），那么在该种情况下距离分辨率应当是多少呢？\n1. 背景介绍 在考虑TI毫米波雷达的距离分辨率之前，要先了解TI的毫米波雷达芯片的工作原理，这里用IWR6843ISK评估版作例子。通过查阅手册可以发现，IWR6843ISK的工作原理如下图所示：\n图1：IWR6843工作原理图\r从上图可知，虽然该雷达芯片发射的是调频脉冲信号，但数据处理方式与连续波雷达相似，接收信号通过低噪声放大器，随后与发射信号作混频得到中频信号，然后通过一个中频放大器后被ADC器件采样得到结果。当然，此处的采样使用数字中频正交采样得到两路$\\text{IQ}$信号。\n需要注意的是，此处采集到的数据已经经过了混频，因此对采集到的数据作$\\text{FFT}$实质上是在求接收信号与发射信号的频率差。\n这意味着这个雷达的测距原理是使用$\\text{FFT}$来得到ADC采集到的数据的频率来得到物体的距离。在单目标情况下（不考虑杂波），ADC采集到的数据频率越高（即与发射信号的频率差越大），物体距离越远；ADC采集到的频率越低，物体距离越近。\n在多目标情况下，就要考虑距离分辨率，即两个频率多么相近的信号可以被区分开来。这就是本文的重点。\n2. 问题引入 调皮哥在这篇文章《毫米波雷达能实现短距离亚毫米级的检测精度吗？》中指出，可以通过增加$\\text{FFT}$点数来增加毫米波雷达的距离精度，如下图所示：\n图2：毫米波雷达距离精度\r那么距离分辨率又与什么因素有关系呢？\n本文首先来讨论距离分辨率的求法，然后给出另一种可以增加距离分辨率的方法，这种方法基于《如何快速地将信号中两个频率很接近的信号成分识别出来？》这篇演化而来。\n首先通过如下$\\text{Matlab}$代码生成一段频率相近的两个信号的叠加，然后绘制这个信号的傅里叶变换以及增加点数后的傅里叶变换。\n%%% 测试频率相近信号的区分能力 t = 0:0.2:5; f1 = 1; % 第一个信号频率 f2 = 1.1; % 第二个信号频率 x1 = cos(2 * pi * f1 * t); x2 = cos(2 * pi * f2 * t); x_total = x1 + x2; % 将两个信号相叠加 plot(t, x_total); title(\u0026#34;原信号波形\u0026#34;); figure plot(abs(fft(x_total))); title(\u0026#34;26点FFT结果\u0026#34;); figure plot(abs(fft(x_total, 1024))); title(\u0026#34;1024点FFT结果\u0026#34;); 上述代码得到的结果如下图所示：\n图3：原信号波形\r图4：FFT结果\r图5：补零后的FFT结果\r从上述结果可以发现，通过单纯增加$\\text{FFT}$点数并不能将这两段信号区分开来，现在我们来讨论一下在这种情况下，距离分辨率应当怎么求解，即求解可以将频率离得多近的两段信号区分开来。\n3.1 从窗函数角度的距离分辨率求解 首先，在现实世界中并不能无限长时间的采样，因此采样这个过程可以被理解为，一个无限长离散信号与一个矩形窗相乘，可表示为如下公式：\n$$ x_s[n] = x[n]w_\\tau[n] \\tag{1} $$\n其中，$x_s[n]$为采集到的信号，$x[n]$为离散域上的原始信号（即无限长采样后的离散信号），$w_\\tau[n]$如下式所定义：\n$$ w_\\tau[n]= \\begin{cases} 1\u0026amp; \\text{0} \\leq \\text{n \u0026lt;} \\tau \\\\ 0\u0026amp; \\text{Others} \\end{cases}$$\n那么对$(1)$作离散时间傅里叶变换，可得\n$$ X_s(\\omega) = \\frac{1}{2\\pi} X(\\omega)*W(\\omega) $$\n其中，$*$表示卷积，$W(\\omega)$如下定义：\n$$ W(\\omega)=e^{-j\\omega \\frac{\\tau - 1}{2}}\\frac{\\sin(\\omega \\frac{\\tau}{2})}{\\sin(\\frac{\\omega}{2})} $$\n可以看到，现实世界中的有限长离散时间信号实际上是无限长离散时间信号的一个模糊。如果使用4dB带宽来衡量距离分辨率，那么可得频率分辨率为：\n$$ \\Delta f = \\frac{F_s}{\\tau} = \\frac{1}{\\tau T_s} = \\frac{1}{T_{Dwell}} \\tag{2} $$\n其中，$T_{Dwell}$为采集时长。将上式代入距离求解公式中，可以得到距离分辨率为：\n$$ \\Delta R = \\frac{c}{2k}\\frac{1}{T_{Dwell}} = \\frac{cT}{2BT_{Dwell}} \\tag{3} $$\n若$T=T_{Dwell}$（在IWR6843中，应当取$T \\approx 2T_{Dwell}$），那么有\n$$ \\Delta R = \\frac{c}{2B} $$\n在IWR6843中，已知带宽$B=4\\text{GHz}$，可得到距离分辨率为$\\Delta R = \\frac{3 \\times 10^8 \\times 2}{2 \\times 4 \\times 10^9}=7.5\\text{cm}$。\n比较反常的是，该结论表明，频率分辨率仅与采样时间有关，而与采样频率无关。如下图所示，可以发现提高采样频率后，并不能区分开两个信号，而提高采样时间后可以顺利区分开两个信号。\n图6：提高采样时间后的结果\r图7：提高采样频率后的结果（仅显示部分点）\r同时，从上图可以看到，$\\Delta f = \\frac{1}{T_{Dwell}}$指出的是极限频率分辨率，所谓极限频率分辨率指的是通过增加$\\text{FFT}$点数后所能达到的最大频率分辨率。换言之，增加$\\text{FFT}$点数只能在有限范围内增加分辨率，而最终的分辨率由$(2)$所决定。\n事实上，上述结论在陈伯孝的《现代雷达系统分析与设计》中已经有类似结论，在该书的第四章第九节 连续波信号与连续波雷达 中指出，窄带滤波器的频率分辨率与驻留时间（即上文中所提到的采样时间）满足如下关系：\n$$ \\Delta f = \\frac{1}{T_{Dwell}} $$\n从形式上来看，上式可以作如下理解（当然，不作为严谨证明，只作为理解与记忆）\n$$ \\Delta f = \\frac{F_s}{n} = \\frac{1}{nT_s} = \\frac{1}{T_{Dwell}} $$\n因此，从上文分析来看，提高$\\text{FFT}$可以有限地提高距离分辨率，但这种提高并不是无限的，最多仅能达到$(2)$式所指出的极限分辨率。当然，为了增加$\\text{FFT}$点数来接近极限分辨率，可以通过细化$\\text{FFT}$方法（即$\\text{ZoomFFT}$）来实现。\n3.2 从模糊函数角度的距离分辨率求解 模糊函数是用来衡量不同维度差异下的信号波形差异的一种量化方法，定义如下所示：\n$$ \\chi(\\tau, f_d) = \\int_{-\\infty}^{\\infty}u(t)u^*(t+\\tau)e^{j2\\pi f_d\\ t} \\mathrm{d}t $$\n其中$u(t)$为信号的复包络，在线性调频信号中为$u(t)=W_T(t)e^{j\\pi \\mu t^2}$，其中为了方便，将$W_T(t)$的中心平移到了原点。有些地方会在$u(t)$前乘上一个系数$\\frac{1}{\\sqrt{T}}$，这是为了保证信号能量的归一化。将线性调频信号的复包络代入模糊函数的计算公式中，可得到如下结果：\n$$ \\begin{align*} \\chi(\\tau, f_d) =\u0026amp; \\int_{-\\infty}^{\\infty}u(t)u^*(t+\\tau)e^{j2\\pi f_d\\ t} \\mathrm{d}t \\\\ =\u0026amp; \\int_{-\\infty}^{\\infty}W_T(t)e^{j\\pi \\mu t^2}W_T(t+\\tau)e^{-j\\pi \\mu (t+\\tau)^2} e^{j2\\pi f_d\\ t} \\mathrm{d}t \\end{align*} $$\n当$|\\tau|$大于$T$时，$W_T(t)W_T(t+\\tau)$恒为$0$。\n当$|\\tau|$小于$T$，且$\\tau$大于$0$时，上式变为：\n$$\\begin{align*} \\chi(\\tau, f_d) =\u0026amp; \\int_{-\\frac{T}{2}}^{\\frac{T}{2}-\\tau}e^{j\\pi \\mu t^2}e^{-j\\pi \\mu (t+\\tau)^2} e^{j2\\pi f_d\\ t} \\mathrm{d}t \\\\ =\u0026amp; e^{-j\\pi \\mu \\tau^2}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}-\\tau} e^{j2\\pi (f_d\\ -\\mu \\tau)t} \\mathrm{d}t \\\\ =\u0026amp; \\frac{e^{-j\\pi \\mu \\tau^2}}{j2\\pi(f_d\\ - \\mu \\tau)}(e^{j2\\pi (f_d\\ - \\mu \\tau)(\\frac{T}{2} - \\tau)} - e^{-j2\\pi (f_d\\ - \\mu \\tau)\\frac{T}{2}}) \\\\ =\u0026amp; \\frac{e^{-j\\pi \\mu \\tau^2}e^{-j\\pi (f_d\\ - \\mu \\tau)\\tau}}{j2\\pi(f_d\\ - \\mu \\tau)}(e^{j\\pi (f_d\\ - \\mu \\tau)(T - \\tau)} - e^{-j\\pi (f_d\\ - \\mu \\tau)(T - \\tau)}) \\\\ =\u0026amp; \\frac{e^{-j\\pi \\mu \\tau^2}e^{-j\\pi (f_d\\ - \\mu \\tau)\\tau}}{\\pi(f_d\\ - \\mu \\tau)}\\sin(\\pi (f_d\\ - \\mu \\tau)(T-\\tau)) \\end{align*} $$\n于是可得\n$$\\begin{align*} |\\chi(\\tau, f_d)| =\u0026amp; |(T-\\tau)\\frac{\\sin(\\pi (f_d\\ - \\mu \\tau)(T-\\tau))}{\\pi (f_d\\ - \\mu \\tau)(T-\\tau)}| \\\\ =\u0026amp; |(T-\\tau)\\mathrm{Sa}(\\pi (f_d\\ - \\mu \\tau)(T-\\tau))| \\end{align*} $$\n当$|\\tau|$小于$T$，且$\\tau$小于$0$时，与上式求法同理。综合来看，结果如下：\n$$ |\\chi(\\tau, f_d)|= \\begin{cases} |(T-|\\tau|)\\mathrm{Sa}(\\pi (f_d\\ - \\mu \\tau)(T-|\\tau|))|\u0026amp; |\\tau|\u0026lt;T \\\\ 0\u0026amp; \\text{Others} \\end{cases} \\tag{4} $$\n对于一个$15\\text{m}$处的目标，回波延时为$0.1\\mu s$，而上式中的二次项与一次项的比值为$\\frac{\\tau}{T} \\ll 1$，因此在考虑距离分辨率时，可以将上述二次项忽略。于是可得到4dB处的时间分辨率为：\n$$ \\Delta \\tau = \\frac{1}{\\mu T} = \\frac{1}{B} $$\n当然，正如前文所述，毫米波雷达的距离分辨率从频率分辨率进行考量，而$|\\chi(0, f_d)|=|T\\mathrm{Sa}(\\pi f_d\\ T)|$，因此可得频率分辨率为：\n$$ \\Delta f = \\frac{1}{T} $$\n与前文得到的结论相同。\n那么在采样时间长度一定时，有没有相关的方法来获得超分辨率呢？\n4. 通过解卷积实现的超分辨率 关于使用解卷积（有些地方也称去卷积）来实现超分辨率的方法在几十年前就已经被大量研究，本节将要介绍的超分辨率方法基于下面这篇文章：\n图8：通过解卷积实现超分辨率\r（笔者还没学随机信号处理与现代信号处理，先鸽了）\n","permalink":"https://bingsz.github.io/en/posts/mmwavedistanceaccuracy/","summary":"\u003cp\u003e  目前毫米波雷达芯片，如IWR系列或者AWR系列，采用的测距原理均是通过测量发射脉冲与接收脉冲的频率差来测量距离（与连续波雷达相似），那么在该种情况下距离分辨率应当是多少呢？\u003c/p\u003e","title":"TI毫米波雷达的距离分辨率"},{"content":" 通常的频率取样法设计$\\text{FIR}$滤波器是通过对频域的采样取逆傅里叶变换得到，而$\\text{Matlab}$中的做法则不同。\n1. 两种方法结果比较 我之前打算实现一个信号处理函数库，当然并没有考虑性能方面的事情，仅仅是熟悉算法。而在实现$\\text{FIR}$的频率响应设计滤波器时便遇到了这个问题，因为我发现我所使用的一般频率取样算法与$\\text{Matlab}$得到的结果并不完全一样，如下所示：\n图1：两种方法比较\r其中，蓝色线为$\\text{Matlab}$生成的$\\text{FIR}$滤波器的频域响应，橙色线为一般频率取样算法得到的结果（加了海明窗）。可以看到，$\\text{Matlab}$的算法得到的结果具有更好的过渡带响应及旁瓣电平。\n如果对于一般的频率取样算法不加海明窗（即最基本的频率取样法设计$\\text{FIR}$滤波器），那么可以得到如下结果：\n图2：两种方法比较（2）\r可以发现，橙色线的过渡带性能更好，但同时带来的一个问题是，通带波纹性能较差，并且阻带性能较$\\text{Matlab}$算法较差。\n根据$\\text{Matlab}$官方手册上的叙述，fir2函数首先对输入频域响应进行插值，生成一个称为“密集网格”的东西，随后使用逆傅里叶变换得到冲激响应，最后使用海明窗进行截断，获得想要的冲激响应。如下图所示：\n图3：fir2函数描述\r也就是说，$\\text{Matlab}$中的实现方法与一般的频率取样法的差别在于，$\\text{Matlab}$对频率响应进行了更加密集的插值，然后使用密集插值后的结果进行处理输出（也就是加窗截断，获得所需要阶数）。为了搞清楚这种方法带来的差别，要从频域采样说起。\n2. 采样后时域频域关系 如果在时域中进行采样周期为 $T_s$ （对应的采样角频率为$\\omega_s$） 的采样，即\n$$ x[n] = x(nT_s) $$\n那么在频域上便存在如下关系：\n$$ X_d(\\omega) = \\frac{1}{T_s}\\sum_{k=-\\infty}^{\\infty}X_c(\\omega - \\omega_s) $$\n其中$X_d$表示离散时间傅里叶变换（即$x[n]$的离散时间傅里叶变换），下标$d$表示离散（$\\text{Discrete}$）；$X_c$表示连续时间傅里叶变换，下标$c$表示连续（$\\text{Continuous}$）。\n由于时域与频域本就是一个对应关系，所以上述关系在频域上同样成立。换言之，如果在频域中进行采样\n$$ X_d[n] = X_c(n\\omega_s) $$\n那么，在时域中将会产生信号混叠，即将有如下等式成立：\n$$ x_d[n] = \\frac{1}{\\omega_s}\\sum_{k=-\\infty}^{\\infty}x_c[n - T_s] \\tag{1} $$\n其中，$x_d[n]$为逆傅里叶变换后的结果，$x_c[n]$为原始信号（其离散时间傅里叶变换对应$X_c$）。\n证明过程与时域采样定理的证明过程一致，主要运用的是“频域乘积对应时域卷积”定理。记$X_s(\\omega)$为采样后的频谱，则有如下关系成立：\n$$ X_s(\\omega) = X_c(\\omega) \\sum_{k=-\\infty}^{\\infty}\\delta(\\omega - k\\omega_s) $$\n令$D(\\omega) = \\sum_{k=-\\infty}^{\\infty}\\delta(\\omega - k\\omega_s)$，那么根据逆傅里叶变换，可得到：\n$$ d(t) = \\frac{T_s}{2\\pi} \\sum_{k=-\\infty}^{\\infty}\\delta(\\omega - k\\omega_s) = \\frac{1}{\\omega_s} \\sum_{k=-\\infty}^{\\infty}\\delta(\\omega - k\\omega_s) $$\n将上式与原信号$x_c[n]$作卷积，便可得到如下关系，与$\\text{(1)}$式相同：\n$$ x_d[n] = \\frac{1}{\\omega_s}\\sum_{k=-\\infty}^{\\infty}x_c[n - T_s] $$\n事实上，从这个角度来理解离散傅里叶变换可以发现，由于离散傅里叶变换本质便是对于离散时间傅里叶变换的一个采样，因此$N$点离散傅里叶变换正是时域信号频谱不混叠的最小点数。\n3. 问题解决 当明白了上述关系后，结论也就自然而然地出来了。一般的频率取样设计滤波器方法由于在点数较少的时候会产生时域混叠现象，因此得到的冲激信号将会产生一定的失真；而$\\text{Matlab}$的“密集网格”方法便能很好的避免这个问题，但是在时间上可能会花费更多。同时，为了得到指定的滤波器点数，需要对结果进行截断，在$\\text{Matlab}$中使用海明窗进行截断。\n事实上，可以通过对密集网格的结果使用不同的窗来获得不同的性能，经过测试，对密集网格使用矩形窗可得到与普通频率取样法相似结果，但具有更好的频域响应（这个原因在第二节已经讨论过了，主要原因在于密集网格减少了时域混叠）。\n4. $\\text{Matlab}$方法缺点 同时，由于$\\text{Matlab}$使用fir2函数设计$\\text{FIR}$滤波器时，在结果处使用了海明窗进行截断，因此便会带来一些缺点，这些缺点本质上并不是由密集网格方法带来的，而是由海明窗带来的。使用海明窗对结果进行截断带来的问题在于对目标频域响应的拟合效果较普通方法较差，这主要是因为海明窗比矩形窗具有较宽的主瓣宽度（当然，使用海明窗的话，通带波纹会比矩形窗小，这是因为矩形窗的旁瓣较高）。\n此处我用一个公式来衡量这种性能，定义“频域响应误差”如下所示：\n$$ E = \\int_{0}^{2\\pi}(H_c(\\omega) - H_d(\\omega))^2\\mathrm{d} \\omega $$\n其中，$H_c(\\omega)$为期望得到的频域响应，$H_d(\\omega)$为生成的滤波器系数得到的频域响应。为了使计算机计算地更加方便，对上式进行改写，用如下公式替代：\n$$ E = \\sum_{k=0}^{N-1}(H_c[n] - H_d[n])^2 $$\n对于不同点数的$\\text{FIR}$滤波器，可以得到如下误差曲线：\n图4：两种方法误差曲线\r其中，蓝色为$\\text{Matlab}$所生成滤波器的误差，橙色为不加窗的频率取样法设计的滤波器的误差。\n综上所述，如果应用中对于通带波纹比较敏感，则可以对频率取样法得到的结果进行加窗（当然，可以事先生成密集网格，然后进行频率取样法）；如果对于通带波纹不太敏感，而比较看重过渡带性能，则可以使用普通的频率取样法（或使用密集网格加矩形窗截断的方法）。\n","permalink":"https://bingsz.github.io/en/posts/matlabfirdifference/","summary":"\u003cp\u003e  通常的频率取样法设计$\\text{FIR}$滤波器是通过对频域的采样取逆傅里叶变换得到，而$\\text{Matlab}$中的做法则不同。\u003c/p\u003e","title":"Matlab中频率取样法设计FIR滤波器的不同"},{"content":"这是一个个人博客，主要用于记录一些本人日常中碰到的问题。\n如果有任何疑问可以联系：1016574101@qq.com\n","permalink":"https://bingsz.github.io/en/about/","summary":"这是一个个人博客，主要用于记录一些本人日常中碰到的问题。 如果有任何疑问可以联系：1016574101@qq.com","title":"关于"}]